<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[git秘钥生成]]></title>
    <url>%2F2018%2F08%2F09%2Fgit%E7%A7%98%E9%92%A5%E7%94%9F%E6%88%90%2F</url>
    <content type="text"><![CDATA[前言 重装系统是真的难过，每次环境都要自己配一遍，浪费了好多时间呀，有钱要买台macpro，专门用来敲代码，不装任何其他垃圾软件。系统慢了真拖延时间 记录 以后直接复制粘贴配置name和email git config –global user.name ‘aymfx’ git config –global user.email &#39;1095731371@qq.com‘ 获取公私key ssh-keygen -t rsa -C &#39;1095731371@qq.com‘ 将公钥放入github的ssh 进入 C:\Users\aymfx.ssh id_rsa中的内容便是私钥，id_rsa.pub中的内容便是公钥 将id_rsa.pub 上传 https://github.com/settings/keys 好了,可以将自己的博客文章上传了。重装系统真麻烦，都要重头来，8月，对我和我妈都好点，希望她身体赶紧康复，我也尽快找到自己满意的工作。 问题，上传出现问题 Host key verification failed. fatal: Could not read from remote repository. 删除 .deploy_git文件 没有丝毫作用 报错 Error: ssh_exchange_identification: read: Connection reset by peer 看官网 https://hexo.io/docs/troubleshooting.html 没有 可能是秘钥不对 测试 ssh -v git@github.com 确认之后有报错 Connection reset by 52.74.223.119 port 22]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[docker初探]]></title>
    <url>%2F2018%2F07%2F21%2Fdocker%E5%88%9D%E6%8E%A2%2F</url>
    <content type="text"><![CDATA[安装 sudo yum install docker 启动 Docker 后台服务 service docker start 停止 Docker 后台服务 service docker stop 安装加速镜像 vi /etc/docker/daemon.json 123&#123; "registry-mirrors": ["http://hub-mirror.c.163.com"]&#125; 测试运行 hello-world警告WARNING: IPv4 forwarding is disabled. Networking will not work. vi /etc/sysctl.conf 1net.ipv4.ip_forward = 1; 重启 network 服务 systemctl restart network 查看是否修改成功 sysctl net.ipv4.ip_forward 成功返回 net.ipv4.ip_forward = 1 命令查看容器是否在运行 docker ps 在 ubuntu:15.10 的镜像下用 /bin/echo 输出 “Hello world” 如果不存在镜像，先下载再运行 docker run ubuntu:15.10 /bin/echo “Hello world” docker run -i -t ubuntu:15.10 /bin/bash t:在新容器内指定一个伪终端或终端。 i:允许你对容器内的标准输入(STDIN) 进行交互。 ctrl+D 退出新容器创建的终端 在容器内使用 docker logs 命令，查看容器内的标准输出 docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 22e838e0b7a9 ubuntu:15.10 “/bin/sh -c ‘while…” 8 minutes ago Up 8 minutes sharp_darwin 通过 CONTAINER ID 或者 NAMES 查看运行日志 docker logs 22e838e0b7a9 docker logs sharp_darwin 停止容器 docker stop 22e838e0b7a9 docker stop sharp_darwin 创建一个 node web 服务拉取 node 镜像 docker pull node 查看镜像是否下载 docker image 创建 package.json123456789101112131415&#123; "name": "demo", "version": "1.0.0", "description": "", "main": "app.js", "scripts": &#123; "test": "echo \"Error: no test specified\" &amp;&amp; exit 1" &#125;, "keywords": [], "author": "", "license": "ISC", "dependencies": &#123; "express": "^4.16.3" &#125;&#125; Dockerfile12345678FROM node:8.9-alpineENV NODE_ENV productionWORKDIR /usr/src/appCOPY ["package.json", "package-lock.json*", "npm-shrinkwrap.json*", "./"]RUN npm install --production --silent &amp;&amp; mv node_modules ../COPY . .EXPOSE 3000CMD npm start app.js12345678910111213"use strict";var express = require("express");var PORT = 3000;var app = express();app.get("/", function(req, res) &#123; res.send("Hello Docker\n");&#125;);app.listen(PORT);console.log("Running on http://localhost:" + PORT); 建一个文件夹 mkdir app cd app 把所有文件放到里面 当前文件夹执行下列命令 docker build -t mynodeapp . 创建 image docker image 查看我们创建的镜像 运行镜像 docker run -d -p 3000:3000 297513a264fd -d 容器会在后台运行 -p 表示端口映射，把本机的 3000 映射到容器的 3000 端口这样外网就能通过本机的 3000 访问我们的 web 了 297513a264fd 我们的 image id 可以访问成功-_-开心]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mysql配置]]></title>
    <url>%2F2018%2F07%2F16%2Fmysql%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[mysql 安装以及配置安装 wget https://dev.mysql.com/get/mysql57-community-release-el7-11.noarch.rpm sudo rpm -Uvh mysql57-community-release-el7-11.noarch.rpm sudo yum install mysql-community-server 修改密码 1.获取密码 sudo grep ‘temporary password’ /var/log/mysqld.log 2.似乎没有获取到，如果获取到了就跳过吧 执行这个 mysqld –initialize 在执行上面的，获取到密码 登录 mysql -uroot -p 输入密码 1.报错 Can’t connect to local MySQL server through socket ‘/var/lib/mysql/mysql.sock 执行了下列命令好了 1、停止命令： sudo systemctl stop mysqld.service 2、启动命令： sudo systemctl start mysqld.service 不行的话再执行 chown mysql:mysql -R /var/lib/mysqlservice mysqld start 按照网上的解释因为服务没重启，所以没有生成这个临时的套接字文件 输入密码，登录成功 修改密码 ALTER USER ‘root‘@’localhost’ IDENTIFIED BY ‘23456’; 刷新下 flush privileges; 设置外网访问 1.特定 ip 访问 grant all privileges on _._ to ‘root‘@’192.168.1.1’ identified by ‘123456’ with grant option; flush privileges; 2.都可以链接 grant all privileges on _._ to ‘root‘@’%’ identified by ‘123456’ with grant option; flush privileges;]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[实现nodejs+express+nginx+mysql线上环境配置1]]></title>
    <url>%2F2018%2F07%2F16%2F%E5%AE%9E%E7%8E%B0nodejs-express-nginx-mysql%E7%BA%BF%E4%B8%8A%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE1%2F</url>
    <content type="text"><![CDATA[前言 想学习下 nodejs 服务器的搭建全过程，毕竟这也是迈向后端的一大步，用的是 centos 服务器 需要实现 nodejs 环境配置 nginx 反向代理 mysql 的环境配置及使用 express 服务器的使用,防火墙的策略开关 创建 ssh https://cloud.tencent.com/developer/article/1157620 安装 node 安装 git yum install git -y 安装 nvm 服务，这个是用来管理 node 版本的工具，可以在服务器上切换不同的 node 环境 curl -o- https://raw.githubusercontent.com/creationix/nvm/v0.33.9/install.sh | bash 注：安装 nvm 后如果是使用 xshell 等工具连接服务器，则需要重新连接一次，不然会提示没有 nvm 使用 nvm 进行安装 nodejs nvm install vxxxx xxx 表示版本 如果没有自动启用当前下载的版本，使用下面命令 nvm use vxxx 当然如果要是没有自动配置成默认的 node 版本的话，执行下面命令 nvm alias default vxxx 使用淘宝源安装最新的 npm npm install -g cnpm –registry=https://registry.npm.taobao.org nginx 配置 cd /usr/local 运行以下命令安装 PCRE 和 zlib 库。 yum -y install pcre pcre-devel zlib-devel 下载 Nginx wget http://nginx.org/download/nginx-1.12.2.tar.gz 解压安装包 tar -xvzf nginx-1.12.2.tar.gz 下载 OpenSSL wget https://www.openssl.org/source/openssl-1.1.0g.tar.gz 解压安装包 tar -xvzf openssl-1.1.0g.tar.gz cd nginx-1.12.2 执行下列命令 1./configure --prefix=/usr/local/nginx --with-http_stub_status_module --with-http_gzip_static_module --with-http_ssl_module --with-openssl=/usr/local/openssl-1.1.0g 报错:./configure: error: C compiler cc is not found yum install gcc 继续安装 1make &amp;&amp; make install 生成证书 openssl req -new -x509 -nodes -out server.crt -keyout server.key 123456789101112131415server &#123; listen 443; server_name www.ldyldy.cn; #填写绑定证书的域名 ssl on; ssl_certificate 1_www.ldyldy.com_bundle.crt; ssl_certificate_key 2_www.ldyldy.com.key; ssl_session_timeout 5m; ssl_protocols TLSv1 TLSv1.1 TLSv1.2; #按照这个协议配置 ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:HIGH:!aNULL:!MD5:!RC4:!DHE;#按照这个套件配置 ssl_prefer_server_ciphers on; location / &#123; root html; #站点目录 index index.html index.htm; &#125; &#125; 添加防火墙配置查看防火墙状态是否开启 firewall-cmd –state 启动服务 systemctl start firewalld 设为开机启动 systemctl enable firewalld 查看端口列表 firewall-cmd –permanent –list-port 添加防火墙端口号 firewall-cmd –permanent –zone=public –add-port=80/tcp 移除防火墙端口号 firewall-cmd –permanent –zone=public –remove-port=80/tcp 重启 firewall-cmd –reload 命令含义： --zone #作用域 --add-port=80/tcp #添加端口，格式为：端口/通讯协议 --permanent #永久生效，没有此参数重启后失效 查看防火墙状态 systemctl status firewalld.service 启动防火墙 systemctl start firewalld.service 关闭防火墙 systemctl stop firewalld.service 重新启动防火墙 systemctl restart firewalld.service 查看端口占用 lsof -i:8080]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webapck4升级踩记录]]></title>
    <url>%2F2018%2F07%2F11%2Fwebapck4%E5%8D%87%E7%BA%A7%E8%B8%A9%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[问题1. (node:49596) DeprecationWarning: Tapable.plugin is deprecated. Use new API on .hooks instead 原因: 由于 extract-text-webpack-plugin 目前还没有 webpack4 版本。 解决方案:cnpm install –save-dev extract-text-webpack-plugin@next]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[node技术分享]]></title>
    <url>%2F2018%2F07%2F10%2Fnode%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB%2F</url>
    <content type="text"><![CDATA[node 技术分享node 是什么？ Node.js 是 JavaScript 在服务器端的一个运行环境，也是一个工具库，用来与服务器端其他软件互动。它的 JavaScript 解释器，采用了 Google 公司的 V8 引擎。是由 Ryan Dahl 写的。他做 nodejs 的初衷是为了做一个高性能是 web 服务器。 简单的说 Node.js 就是运行在服务端的 JavaScript,于是对于前端工程师也就可以接触后台的东西了 node 特点有哪些 事件驱动 node 中，客户端的链接，提交数据等都会触发相应的事件,每个事件都会进入一个事件队列，在事件的循环中，执行一些异步操作，比如查询数据库，获取磁盘文件，最后成功后会执行回调函数，这一过程不会阻塞新的事件。 非阻塞 I/O（异步 I/O） 当在访问数据库数据的时候，需要一段时间进行 I/O 操作，在传统的单线程处理机制中，在执行了访问数据库代码之后，这个线程都将先停下来，等待数据库返回数据结果，才能执行后面的代码，也就是说 I/O 阻塞了线程的执行，极大的降低了程序的执行效率。 由于 Node.js 执行了非阻塞 I/O 机制，因此在执行了访问数据库代码之后，将立即执行后面的代码，把数据库执行返回结果的处理放到了代码的执行回调函数中，从而以提高了函数的执行效率。 当某个 I/O 执行完毕时，将以事件的形式通知执行 I/O 操作的线程，线程执行这个事件的回调函数，是为了处理异步 I/O，线程必须有事件循环，不断的检查有没有未处理的事件，依次予以处理。 在传统阻塞模式下，一个线程只能处理一项任务，要想处理连接的吞吐量必须通过多线程。而在 Node.js 这种非阻塞模式下，一个线程永远在执行计算操作，这个线程的 CPU 利用率永远是 100%，所以这是一种也别有哲理的设计方案，人多，但是好多人都闲着，还不如人少，往死里干活。 单线程 Node.js 不为每个客户连接创建一个新的线程。而仅仅使用一个线程，当有用户连接了，就会触发一个内部事件，通过非阻塞 I/O，事件驱动机制，让 Node.js 程序宏观上也是并行的，使用 Node.js，一个 8GB 的内存条，理论上就可以支持 40000 个用户连接了。另外单线程的好处就是，还有操作系统不在由创建，销毁销毁线程的时间。 node 的优缺点 优点 高并发（最重要的优点） 适合 I/O 密集型应用 缺点 不适合 CPU 密集型应用,由于是单线程如果进行长时间的计算（大循环）会导致 cpu 无法释放，后续的 i/o 不能发起 代码的健壮性不高，一旦代码某个环节崩溃，整个系统都崩溃 解决方案（1）: 在代码设计阶段我们需要将可能的大型运算分解成多个小任务，使得运算能够适时释放，不阻塞 I/O 调用的发起 解决方案（2）: 1.Nnigx 反向代理，负载均衡，开多个进程，绑定多个端口 2.开多个进程监听同一个端口，使用 cluster 模块；也可以使用 forever 或 pm2 模块 创建一个最简单的服务器123456789const http = require("http");http .createServer(function(req, res) &#123; res.end("Hello Node.js\n"); &#125;) .listen(3000, "127.0.0.1");console.log("服务运行在 http://127.0.0.1:3000/"); 用 express 搭建 node 服务器 基于 Node.js 平台，快速、开放、极简的 web 开发框架。 Express 不对 Node.js 已有的特性进行二次抽象，我们只是在它之上扩展了 Web 应用所需的基本功能 12345678910var express = require("express");var app = express();app.get("/", function(req, res) &#123; res.send("Hello World!");&#125;);var server = app.listen(3000, function() &#123; console.log("服务运行在 http://127.0.0.1:3000/");&#125;); 利用这个框架操作数据库 mysql，实现增删查改 先介一个模板 ejs 12345678910111213141516var express = require("express");var app = express();app.set("views", "./views");app.set("view engine", "ejs");app.get("/", function(req, res) &#123; res.render("index", &#123; name: "ly", age: "18" &#125;);&#125;);app.listen(3000, function() &#123; console.log("服务运行在 http://127.0.0.1:3000/");&#125;); 通过并发处理检测 node 的性能,(事件的轮询) 测试工具:ab ab 是 apache bench 命令的缩写 ab 的原理：ab 命令会创建多个并发访问线程，模拟多个访问者同时对某一 URL 地址进行访问。它的测试目标是基于 URL 的，因此，它既可以用来测试 apache 的负载压力，也可以测试 nginx、lighthttp、tomcat、IIS 等其它 Web 服务器的压力 ab 命令对发出负载的计算机要求很低，它既不会占用很高 CPU，也不会占用很多内存。但却会给目标服务器造成巨大的负载，其原理类似 CC 攻击。自己测试使用也需要注意，否则一次上太多的负载。可能造成目标服务器资源耗完，严重时甚至导致死机。 ab -n1000 -c10 http://localhost:3000/ -n 表示测试会话中所执行的请求个数，-c 表示 一次产生的请求个数 单独一个线程运行的情况 1234567891011121314151617181920212223242526272829303132333435Server Software:Server Hostname: localhostServer Port: 3000Document Path: /Document Length: 7570 bytesConcurrency Level: 10Time taken for tests: 3.167 secondsComplete requests: 1000Failed requests: 0Total transferred: 7774000 bytesHTML transferred: 7570000 bytesRequests per second: 315.77 [#/sec] (mean)Time per request: 31.668 [ms] (mean)Time per request: 3.167 [ms] (mean, across all concurrent requests)Transfer rate: 2397.29 [Kbytes/sec] receivedConnection Times (ms) min mean[+/-sd] median maxConnect: 0 0 0.3 0 1Processing: 17 31 8.6 29 67Waiting: 16 30 8.6 28 67Total: 17 31 8.6 29 67Percentage of the requests served within a certain time (ms) 50% 29 66% 32 75% 34 80% 36 90% 43 95% 49 98% 58 99% 62 100% 67 (longest request) 开启多进程的性能情况 安装一个 pm2 包，进行开启多线程操作 pm2 是一个带有负载均衡功能的 Node 应用的进程管理器.当你要把你的独立代码利用全部的服务器上的所有 CPU,并保证进程永远都活着,0 秒的重载, PM2 是完美的, PM2 （github 上的源码）是开源的基于 Nodejs 的进程管理器，包括守护进程，监控，日志的一整套完整的功能，基本是 Nodejs 应用程序不二的守护进程选择 命令行: pm2 start app.js -i max max 表示启用最大核心数，PM2 则会根据你 CPU 核心的数量来生成对应的工作线程 1234567891011121314151617181920212223242526272829303132333435Server Software:Server Hostname: localhostServer Port: 3000Document Path: /Document Length: 7570 bytesConcurrency Level: 10Time taken for tests: 2.196 secondsComplete requests: 1000Failed requests: 0Total transferred: 7774000 bytesHTML transferred: 7570000 bytesRequests per second: 455.34 [#/sec] (mean)Time per request: 21.961 [ms] (mean)Time per request: 2.196 [ms] (mean, across all concurrent requests)Transfer rate: 3456.88 [Kbytes/sec] receivedConnection Times (ms) min mean[+/-sd] median maxConnect: 0 0 0.3 0 1Processing: 10 21 10.7 17 82Waiting: 10 21 10.6 17 82Total: 10 21 10.7 18 82Percentage of the requests served within a certain time (ms) 50% 18 66% 20 75% 23 80% 25 90% 33 95% 48 98% 58 99% 65 100% 82 (longest request) 开启集群 任何时候，如果你需要增加工作线程的数量，可以通过 pm2 scale 来对集群进行扩展。参数指定工作线程的数量，被用来增加或减少集群数。你也可以通过 pm2 scale app +3 的方式来指定要增加多少工作线程。 1234567891011121314151617181920212223242526272829303132333435Server Software:Server Hostname: localhostServer Port: 3000Document Path: /Document Length: 7570 bytesConcurrency Level: 10Time taken for tests: 2.344 secondsComplete requests: 1000Failed requests: 0Total transferred: 7774000 bytesHTML transferred: 7570000 bytesRequests per second: 426.59 [#/sec] (mean)Time per request: 23.441 [ms] (mean)Time per request: 2.344 [ms] (mean, across all concurrent requests)Transfer rate: 3238.62 [Kbytes/sec] receivedConnection Times (ms) min mean[+/-sd] median maxConnect: 0 0 0.3 0 1Processing: 13 23 13.5 20 318Waiting: 12 22 13.4 19 318Total: 13 23 13.5 20 318Percentage of the requests served within a certain time (ms) 50% 20 66% 22 75% 23 80% 25 90% 31 95% 39 98% 57 99% 79 100% 318 (longest request)]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>编程</tag>
        <tag>感悟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux安装MongoDB]]></title>
    <url>%2F2018%2F07%2F01%2Flinux%E5%AE%89%E8%A3%85MongoDB%2F</url>
    <content type="text"><![CDATA[下载 官网地址 https://www.mongodb.com/download-center#atlas 我下的版本 curl -O https://fastdl.mongodb.org/linux/mongodb-linux-x86_64-rhel62-4.0.0.tgz 解压存放 我的存放位置 /usr/local/mongose cp -r mongodb-linux-x86_64-rhel62-4.0.0.tgz /usr/local/mongose 解压 tar -zxvf mongodb-linux-x86_64-rhel62-4.0.0.tgz 配置全局变量 vi /etc/profile 12export MONGODB_HOME=/usr/local/mongoseexport PATH=$PATH:$MONGODB_HOME/bin 保存后，重启系统配置 source /etc/profile mongodb 启动配置 cd /usr/local/mongose/bin vi mongodb.conf 1234dbpath = /usr/local/mongodb/data/db #数据文件存放目录logpath = /usr/local/mongodb/logs/mongodb.log #日志文件存放目录port = 27017 #端口fork = true #以守护程序的方式启用，即在后台运行 启动数据库 ./mongod -f mongodb.conf 进入数据库 ./mongo mongodb 开机启动 cd /lib/systemd/system vi mongodb.service 1234567891011121314[Unit]Description=mongodbAfter=network.target remote-fs.target nss-lookup.target[Service]Type=forkingExecStart=/usr/local/mongose/bin/mongod --config /usr/local/mongodb/bin/mongodb.confExecReload=/bin/kill -s HUP $MAINPIDExecStop=/usr/local/mongose/bin/mongod --shutdown --config /usr/local/mongodb/bin/mongodb.confPrivateTmp=truebind_ip = 0.0.0.0[Install]WantedBy=multi-user.target 赋值权限 chmod 754 mongodb.service 启动命令启动服务 systemctl start mongodb.service 关闭服务 systemctl stop mongodb.service 开机启动 systemctl enable mongodb.service 可视化操作工具 https://robomongo.org/download 关闭 https://www.cnblogs.com/joshua317/articles/5190385.html]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>mongose</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[趣味题]]></title>
    <url>%2F2018%2F06%2F15%2F%E8%B6%A3%E5%91%B3%E9%A2%98%2F</url>
    <content type="text"><![CDATA[趣味js 周五了。学点趣味的东西放松下 [“1”, “2”, “3”].map(parseInt) 输出的是啥? 答案: [1, NaN, NaN] map里面的函数有三个参数 数组的值、 数组的下标 数组 parseInt 接收两个值 string 必需。要被解析的字符串。 radix 可选。表示要解析的数字的基数。该值介于 2 ~ 36 之间。如果省略该参数或其值为 0，则数字将以 10 为基础来解析。如果它以 “0x” 或 “0X” 开头，将以 16 为基数。如果该参数小于 2 或者大于 36，则 parseInt() 将返回 NaN 即 parseInt(‘1’,0) 1 parseInt(‘2’,1) NaN parseInt(‘3’,2) NaN 二进制 [typeof null, null instanceof Object] 输出的是啥? 答案: [[“object”, false]] 常识不解释 [ [3,2,1].reduce(Math.pow), [].reduce(Math.pow) ] 输出的是啥? 答案: 数组为空时会报错 reduce 四个参数 total 必需。初始值, 或者计算结束后的返回值。 currentValue 必需。当前元素 currentIndex 可选。当前元素的索引 arr 可选。当前元素所属的数组对象。 即 Math.pow(3,2) Math.pow(9,1) 下面输出啥？12var val = 'smtg';console.log('Value is ' + (val === 'smtg') ? 'Something' : 'Nothing'); 答案: Something +运算符大于三目 下面输出啥？123var ary = [0,1,2];ary[10] = 10;ary.filter(function(x) &#123; return x === undefined;&#125;); 答案: [] Array.prototype.filter不会为空元素调用的 下面输出啥？12345var two = 0.2var one = 0.1var eight = 0.8var six = 0.6[two - one == one, eight - six == two] 答案:[true, false] js精度问题 下面输出啥？12345678910111213141516function showCase(value) &#123; switch(value) &#123; case 'A': console.log('Case A'); break; case 'B': console.log('Case B'); break; case undefined: console.log('undefined'); break; default: console.log('Do not know!'); &#125;&#125;showCase(new String('A')); 答案:switch uses === internally and new String(x) !== x 内部是全等的？？ 下面输出啥？12345678910111213141516function showCase2(value) &#123; switch(value) &#123; case 'A': console.log('Case A'); break; case 'B': console.log('Case B'); break; case undefined: console.log('undefined'); break; default: console.log('Do not know!'); &#125;&#125;showCase2(String('A')); 答案:Case A String（x）不会创建一个对象，但会返回一个字符串，即typeof String（1）===“string” 下面输出啥？1234567891011function isOdd(num) &#123; return num % 2 == 1;&#125;function isEven(num) &#123; return num % 2 == 0;&#125;function isSane(num) &#123; return isEven(num) || isOdd(num);&#125;var values = [7, 4, '13', -9, Infinity];values.map(isSane); 答案:[true, true, true, false, false] 无穷大％2给出NaN，-9％2给出-1（模运算符保持符号，所以它的结果只是可靠的，而不是0） 下面输出啥？123parseInt(3, 8)parseInt(3, 2)parseInt(3, 0) 答案:3, NaN, NaN 3在基数2中不存在，所以显然这是一个NaN，但是0呢？ parseInt会考虑一个假基数，并假设你的意思是10，所以它返回3。 下面输出啥？1Array.isArray( Array.prototype ) 答案true Array.prototype是一个数组 下面输出啥？123456var a = [0];if ([0]) &#123; console.log(a == true);&#125; else &#123; console.log("wut");&#125; 答案false 作为一个布尔值被认为是真的[0]。唉，在比较中使用它时，它会以不同的方式转换 下面输出啥？1[]==[] 答案false 比较运算符按照啥来比较？？]]></content>
      <categories>
        <category>js娱乐</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[typescript-模块]]></title>
    <url>%2F2018%2F06%2F15%2Ftypescript-%E6%A8%A1%E5%9D%97%2F</url>
    <content type="text"><![CDATA[前言 模块在其自身的作用域里执行，而不是在全局作用域里；这意味着定义在一个模块里的变量，函数，类等等在模块外部是不可见的，除非你明确地使用export形式之一导出它们。 相反，如果想使用其它模块导出的变量，函数，类，接口等的时候，你必须要导入它们，可以使用 import形式之一。 模块是自声明的；两个模块之间的关系是通过在文件级别上使用imports和exports建立的。 TypeScript与ECMAScript 2015一样，任何包含顶级import或者export的文件都被当成一个模块。相反地，如果一个文件不带有顶级的import或者export声明，那么它的内容被视为全局可见的（因此对模块也是可见的）。 导出 任何声明（比如变量，函数，类，类型别名或接口）都能够通过添加export关键字来导出 123export interface StringValidator &#123; isAcceptable(s: string): boolean;&#125; 导出重命名 用 as 1234567class ZipCodeValidator implements StringValidator &#123; isAcceptable(s: string) &#123; return s.length === 5 &amp;&amp; numberRegexp.test(s); &#125;&#125;export &#123; ZipCodeValidator &#125;;export &#123; ZipCodeValidator as mainValidator &#125;; 重新导出 12345678export class ParseIntBasedZipCodeValidator &#123; isAcceptable(s: string) &#123; return s.length === 5 &amp;&amp; parseInt(s).toString() === s; &#125;&#125;// 导出原先的验证器但做了重命名,不会增加新的局部变量export &#123;ZipCodeValidator as RegExpBasedZipCodeValidator&#125; from "./ZipCodeValidator"; 或者一个模块可以包裹多个模块，并把他们导出的内容联合在一起通过语法：export * from “module”。 123export * from "./StringValidator"; // exports interface StringValidatorexport * from "./LettersOnlyValidator"; // exports class LettersOnlyValidatorexport * from "./ZipCodeValidator"; // exports class ZipCodeValidator 导入 导入一个模块中的某个导出内容 1234import &#123; ZipCodeValidator &#125; from "./ZipCodeValidator";let myValidator = new ZipCodeValidator(); 可以对导入内容重命名 12import &#123; ZipCodeValidator as ZCV &#125; from "./ZipCodeValidator";let myValidator = new ZCV(); 将整个模块导入到一个变量，并通过它来访问模块的导出部分 12import * as validator from "./ZipCodeValidator";let myValidator = new validator.ZipCodeValidator(); 具有副作用的导入模块 尽管不推荐这么做，一些模块会设置一些全局状态供其它模块使用。 这些模块可能没有任何的导出或用户根本就不关注它的导出。 使用下面的方法来导入这类模块 1import "./my-module.js"; 默认导出 每个模块都可以有一个default导出。 默认导出使用 default关键字标记；并且一个模块只能够有一个default导出。 需要使用一种特殊的导入形式来导入 default导出 1234567891011//JQuery.d.tsdeclare let $: JQuery;export default $;// App.tsimport $ from "JQuery";$("button.continue").html( "Next Step..." ); 导出静态类 123456789101112//ZipCodeValidator.tsexport default class ZipCodeValidator &#123; static numberRegexp = /^[0-9]+$/; isAcceptable(s: string) &#123; return s.length === 5 &amp;&amp; ZipCodeValidator.numberRegexp.test(s); &#125;&#125;//Test.tsimport validator from "./ZipCodeValidator";let myValidator = new validator(); export = 和 import = require() 用这种方式我们兼容传统的CommonJS和AMD的工作流模型 1234567891011121314151617181920212223//ZipCodeValidator.tslet numberRegexp = /^[0-9]+$/;class ZipCodeValidator &#123; isAcceptable(s: string) &#123; return s.length === 5 &amp;&amp; numberRegexp.test(s); &#125;&#125;export = ZipCodeValidator;//Test.tsimport zip = require("./ZipCodeValidator");// Some samples to trylet strings = ["Hello", "98052", "101"];// Validators to uselet validator = new zip();// Show whether each string passed each validatorstrings.forEach(s =&gt; &#123; console.log(`"$&#123; s &#125;" - $&#123; validator.isAcceptable(s) ? "matches" : "does not match" &#125;`);&#125;); 生成模块代码 根据不同的规范生成不同的代码 Node.js来说，使用–module commonjs； 对于Require.js来说，使用–module amd。比如： tsc –module commonjs Test.ts 可选的模块加载和其它高级加载场景 有时候，你只想在某种条件下才加载某个模块。 在TypeScript里，使用下面的方式来实现它和其它的高级加载场景，我们可以直接调用模块加载器并且可以保证类型完全 编译器会检测是否每个模块都会在生成的JavaScript中用到。 如果一个模块标识符只在类型注解部分使用，并且完全没有在表达式中使用时，就不会生成 require这个模块的代码。 省略掉没有用到的引用对性能提升是很有益的，并同时提供了选择性加载模块的能力。 这种模式的核心是import id = require(“…”)语句可以让我们访问模块导出的类型。 模块加载器会被动态调用（通过 require），就像下面if代码块里那样。 它利用了省略引用的优化，所以模块只在被需要时加载。 为了让这个模块工作，一定要注意 import定义的标识符只能在表示类型处使用（不能在会转换成JavaScript的地方） 为了确保类型安全性，我们可以使用typeof关键字。 typeof关键字，当在表示类型的地方使用时，会得出一个类型值，这里就表示模块的类型 123456789declare function require(moduleName: string): any;import &#123; ZipCodeValidator as Zip &#125; from "./ZipCodeValidator";if (needZipValidation) &#123; let ZipCodeValidator: typeof Zip = require("./ZipCodeValidator"); let validator = new ZipCodeValidator(); if (validator.isAcceptable("...")) &#123; /* ... */ &#125;&#125; 模块里不要使用命名空间]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>ts</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[typescript-Symbol]]></title>
    <url>%2F2018%2F06%2F14%2Ftypescript-Symbol%2F</url>
    <content type="text"><![CDATA[前言 Symbol 新的原生类型 symbol类型的值是通过Symbol构造函数创建的 123let sym1 = Symbol();let sym2 = Symbol("key"); // 可选的字符串key Symbols是不可改变且唯一的 1234let sym2 = Symbol("key");let sym3 = Symbol("key");sym2 === sym3; // false, symbols是唯一的 像字符串一样，symbols也可以被用做对象属性的键。 12345678let sym = Symbol();let obj = &#123; [sym]: "value"&#125;;console.log(obj[sym]); // "value" Symbols也可以与计算出的属性名声明相结合来声明对象的属性和类成员。 1234567891011const getClassNameSymbol = Symbol();class C &#123; [getClassNameSymbol]()&#123; return "C"; &#125;&#125;let c = new C();let className = c[getClassNameSymbol](); // "C" Symbol.hasInstance 方法，会被instanceof运算符调用。构造器对象用来识别一个对象是否是其实例。 Symbol.isConcatSpreadable 布尔值，表示当在一个对象上调用Array.prototype.concat时，这个对象的数组元素是否可展开 Symbol.iterator 方法，被for-of语句调用。返回对象的默认迭代器 Symbol.match 方法，被String.prototype.match调用。正则表达式用来匹配字符串。 Symbol.replace 方法，被String.prototype.search调用。正则表达式返回被匹配部分在字符串中的索引。 Symbol.species 函数值，为一个构造函数。用来创建派生对象。 Symbol.split 方法，被String.prototype.split调用。正则表达式来用分割字符串。 Symbol.toPrimitive 方法，被ToPrimitive抽象操作调用。把对象转换为相应的原始值。 Symbol.toStringTag 方法，被内置方法Object.prototype.toString调用。返回创建对象时默认的字符串描述。 Symbol.unscopables 对象，它自己拥有的属性会被with作用域排除在外]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>ts</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[typescript-高级类型]]></title>
    <url>%2F2018%2F06%2F14%2Ftypescript-%E9%AB%98%E7%BA%A7%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[前言 学了好几天的ts感觉自己还在门口徘徊，依然不得ts的门道。 交叉类型（Intersection Types） 交叉类型是将多个类型合并为一个类型,先看下例子 1234567891011121314151617181920212223242526272829303132333435function extend&lt;T,U&gt;(first: T, second: U): T &amp; U &#123; let result = &lt;T &amp; U&gt;&#123;&#125;; for (let id in first) &#123; (&lt;any&gt;result)[id] = (&lt;any&gt;first)[id]; &#125; for(let id in second) &#123; if (!result.hasOwnProperty(id))&#123; (&lt;any&gt;result)[id] = (&lt;any&gt;second)[id]; &#125; &#125; return result;&#125;class Person &#123; constructor(public name:string)&#123; &#125;&#125;interface Loggable &#123; log():void;&#125;class ConsoleLogger implements Loggable&#123; log() &#123; &#125;&#125;var jim = extend(new Person('jim'),new ConsoleLogger());var n = jim.name;jim.log(); 这个是将两个类型合并成一个类型，最后返回 通过 &lt;T&amp;U&gt; 联合类型（Union Types） 联合类型与交叉类型很有关联，但是使用上却完全不同。 偶尔你会遇到这种情况，一个代码库希望传入 number或 string类型的参数 1234567891011function padLeft(value: string, padding: any) &#123; if (typeof padding === "number") &#123; return Array(padding + 1).join(" ") + value; &#125; if (typeof padding === "string") &#123; return padding + value; &#125; throw new Error(`Expected string or number, got '$&#123;padding&#125;'.`);&#125;padLeft("Hello world", 4); // returns " Hello world" 虽然这样在编译期间不会报错但是它在运行期会报错，比如传的类型不是string和number 123456function padLeft(value: string, padding: string | number) &#123; // ...&#125;let indentedString = padLeft("Hello world", true); // errors during compilation 上面的联合类型就避免了这样的情况 如果一个值是联合类型，我们只能访问此联合类型的所有类型里共有的成员。 1234567891011121314151617interface Bird &#123; fly(); layEggs();&#125;interface Fish &#123; swim(); layEggs();&#125;function getSmallPet(): Fish | Bird &#123; // ...&#125;let pet = getSmallPet();pet.layEggs(); // okaypet.swim(); // errors 类型保护与区分类型（Type Guards and Differentiating Types） 假如我们要用这个避免这个编译错误，我们就要这么改,用断言进行保护 12345678let pet = getSmallPet();if ((&lt;Fish&gt;pet).swim) &#123; (&lt;Fish&gt;pet).swim();&#125;else &#123; (&lt;Bird&gt;pet).fly();&#125; 用户自定义的类型保护 TypeScript里的 类型保护机制让它成为了现实。 类型保护就是一些表达式，它们会在运行时检查以确保在某个作用域里的类型。 要定义一个类型保护，我们只要简单地定义一个函数，它的返回值是一个 类型谓词 1234567891011function isFish(pet: Fish | Bird): pet is Fish &#123; return (&lt;Fish&gt;pet).swim !== undefined;&#125;// 'swim' 和 'fly' 调用都没有问题了if (isFish(pet)) &#123; pet.swim();&#125;else &#123; pet.fly();&#125; 注意TypeScript不仅知道在 if分支里 pet是 Fish类型； 它还清楚在 else分支里，一定 不是 Fish类型，一定是 Bird类型 typeof类型保护1234567891011121314151617function isNumber(x: any): x is number &#123; return typeof x === "number";&#125;function isString(x: any): x is string &#123; return typeof x === "string";&#125;function padLeft(value: string, padding: string | number) &#123; if (isNumber(padding)) &#123; return Array(padding + 1).join(" ") + value; &#125; if (isString(padding)) &#123; return padding + value; &#125; throw new Error(`Expected string or number, got '$&#123;padding&#125;'.`);&#125; 用 parameterName is Type 太麻烦 还有更简洁的方式 123456789function padLeft(value: string, padding: string | number) &#123; if (typeof padding === "number") &#123; return Array(padding + 1).join(" ") + value; &#125; if (typeof padding === "string") &#123; return padding + value; &#125; throw new Error(`Expected string or number, got '$&#123;padding&#125;'.`);&#125; instanceof类型保护 instanceof类型保护是通过构造函数来细化类型的一种方式 123456789101112131415161718192021222324252627282930313233interface Padder &#123; getPaddingString(): string&#125;class SpaceRepeatingPadder implements Padder &#123; constructor(private numSpaces: number) &#123; &#125; getPaddingString() &#123; return Array(this.numSpaces + 1).join(" "); &#125;&#125;class StringPadder implements Padder &#123; constructor(private value: string) &#123; &#125; getPaddingString() &#123; return this.value; &#125;&#125;function getRandomPadder() &#123; return Math.random() &lt; 0.5 ? new SpaceRepeatingPadder(4) : new StringPadder(" ");&#125;// 类型为SpaceRepeatingPadder | StringPadderlet padder: Padder = getRandomPadder();if (padder instanceof SpaceRepeatingPadder) &#123; padder; // 类型细化为'SpaceRepeatingPadder'&#125;if (padder instanceof StringPadder) &#123; padder; // 类型细化为'StringPadder'&#125; 通过 instanceof 将类型细化成更准确的类型 可以为null的类型 null和undefined是可以所有类型的子类，所以可以赋值给任何类型，通过加–strictNullChecks来解决此错误 123456let s = "foo";s = null; // 错误, 'null'不能赋值给'string'let sn: string | null = "bar";sn = null; // 可以sn = undefined; // error, 'undefined'不能赋值给'string | null' 可选参数和可选属性 使用了 –strictNullChecks，可选参数会被自动地加上 | undefined 123456789101112131415161718function f(x: number, y?: number) &#123; return x + (y || 0);&#125;f(1, 2);f(1);f(1, undefined);f(1, null); // error, 'null' is not assignable to 'number | undefined'class C &#123; a: number; b?: number;&#125;let c = new C();c.a = 12;c.a = undefined; // error, 'undefined' is not assignable to 'number'c.b = 13;c.b = undefined; // okc.b = null; // error, 'null' is not assignable to 'number | undefined' 类型保护和类型断言 通过加一个！符号进行断言的判断 12345678910111213141516function broken(name: string | null): string &#123; function postfix(epithet: string) &#123; return name.charAt(0) + '. the ' + epithet; // error, 'name' is possibly null ===&gt;并没有警告 &#125; name = name || "Bob"; return postfix("great");&#125;function fixed(name: string | null): string &#123; function postfix(epithet: string) &#123; return name!.charAt(0) + '. the ' + epithet; // ok &#125; name = name || "Bob"; return postfix("great");&#125; 类型别名 类型别名会给一个类型起个新名字。 类型别名有时和接口很像，但是可以作用于原始值，联合类型，元组以及其它任何你需要手写的类型 123456789101112type Name = string;type NameResolver = () =&gt; string;type NameOrResolver = Name | NameResolver;function getName(n: NameOrResolver): Name &#123; if (typeof n === 'string') &#123; return n; &#125; else &#123; return n(); &#125;&#125; 接口 vs. 类型别名 类型别名可以像接口一样 1234567891011type LinkedList&lt;T&gt; = T &amp; &#123; next: LinkedList&lt;T&gt; &#125;;interface Person &#123; name: string;&#125;var people: LinkedList&lt;Person&gt;;var s = people.name;var s = people.next.name;var s = people.next.next.name;var s = people.next.next.next.name; 但是他们还是有些差别 其一，接口创建了一个新的名字，可以在其它任何地方使用。 类型别名并不创建新名字—比如，错误信息就不会使用别名 另一个重要区别是类型别名不能被 extends和 implements（自己也不能 extends和 implements其它类型） 字符串字面量类型 字符串字面量类型允许你指定字符串必须的固定值。 在实际应用中，字符串字面量类型可以与联合类型，类型保护和类型别名很好的配合。 通过结合使用这些特性，你可以实现类似枚举类型的字符串。 12345678910111213141516171819type Easing = "ease-in" | "ease-out" | "ease-in-out";class UIElement &#123; animate(dx: number, dy: number, easing: Easing) &#123; if (easing === "ease-in") &#123; // ... &#125; else if (easing === "ease-out") &#123; &#125; else if (easing === "ease-in-out") &#123; &#125; else &#123; // error! should not pass null or undefined. &#125; &#125;&#125;let button = new UIElement();button.animate(0, 0, "ease-in");button.animate(0, 0, "uneasy"); // error: "uneasy" is not allowed here 数字字面量类型123function rollDie(): 1 | 2 | 3 | 4 | 5 | 6 &#123; // ...&#125; 枚举成员类型 可辨识联合（Discriminated Unions） 具有普通的单例类型属性— 可辨识的特征。 一个类型别名包含了那些类型的联合— 联合。 此属性上的类型保护。 12345678910111213141516171819202122232425262728interface Square &#123; kind: "square"; size: number;&#125;interface Rectangle &#123; kind: "rectangle"; width: number; height: number;&#125;interface Circle &#123; kind: "circle"; radius: number;&#125;//定义联合接口type Shape = Square | Rectangle | Circle;//可辨识度联合function area(s: Shape) &#123; switch (s.kind) &#123; case "square": return s.size * s.size; case "rectangle": return s.height * s.width; case "circle": return Math.PI * s.radius ** 2; &#125;&#125; 完整性检查 上面如果我们新增了类型，我们需要在添加一个 12345678910type Shape = Square | Rectangle | Circle | Triangle;function area(s: Shape) &#123; switch (s.kind) &#123; case "square": return s.size * s.size; case "rectangle": return s.height * s.width; case "circle": return Math.PI * s.radius ** 2; &#125; // should error here - we didn't handle case "triangle"&#125; 第一种方式实现 12345678//启用 --strictNullChecks并且指定一个返回值类型function area(s: Shape): number &#123; // error: returns number | undefined switch (s.kind) &#123; case "square": return s.size * s.size; case "rectangle": return s.height * s.width; case "circle": return Math.PI * s.radius ** 2; &#125;&#125; 第二种 12345678910111213//第二种方法使用 never类型，编译器用它来进行完整性检查function assertNever(x: never): never &#123; throw new Error("Unexpected object: " + x);&#125;function area(s: Shape) &#123; switch (s.kind) &#123; case "square": return s.size * s.size; case "rectangle": return s.height * s.width; case "circle": return Math.PI * s.radius ** 2; default: return assertNever(s); // error here if there are missing cases &#125;&#125; 多态的 this类型 多态的 this类型表示的是某个包含类或接口的 子类型。 这被称做 F-bounded多态性。 它能很容易的表现连贯接口间的继承 123456789101112131415161718192021class BasicCalculator &#123; public constructor(protected value: number = 0) &#123; &#125; public currentValue(): number &#123; return this.value; &#125; public add(operand: number): this &#123; this.value += operand; return this; &#125; public multiply(operand: number): this &#123; this.value *= operand; return this; &#125; // ... other operations go here ...&#125;let v = new BasicCalculator(2) .multiply(5) .add(1) .currentValue(); 索引类型（Index types） 通过 索引类型查询和 索引访问操作符 12345678910111213function pluck&lt;T, K extends keyof T&gt;(o: T, names: K[]): T[K][] &#123; return names.map(n =&gt; o[n]);&#125;interface Person &#123; name: string; age: number;&#125;let person: Person = &#123; name: 'Jarid', age: 35&#125;;let strings: string[] = pluck(person, ['name']); // ok, string[]x 编译器会检查 name是否真的是 Person的一个属性。 本例还引入了几个新的类型操作符。 首先是 keyof T， 索引类型查询操作符。 对于任何类型 T， keyof T的结果为 T上已知的公共属性名的联合。 例如： 1let personProps: keyof Person; // 'name' | 'age' 索引类型和字符串索引签名 keyof和 T[K]与字符串索引签名进行交互。 如果你有一个带有字符串索引签名的类型，那么 keyof T会是 string。 并且 T[string]为索引签名的类型 123456interface Map&lt;T&gt; &#123; [key: string]: T;&#125;let keys: keyof Map&lt;number&gt;; // stringlet value: Map&lt;number&gt;['foo']; // number 映射类型 一个常见的任务是将一个已知的类型每个属性都变为可选的： 1234interface PersonPartial &#123; name?: string; age?: number;&#125;]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>typescript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[typescript-类型兼容性]]></title>
    <url>%2F2018%2F06%2F13%2Ftypescript-%E7%B1%BB%E5%9E%8B%E5%85%BC%E5%AE%B9%E6%80%A7%2F</url>
    <content type="text"><![CDATA[前言 TypeScript里的类型兼容性是基于结构子类型的,也就是说结构相同就好123456789101112interface Named &#123; name: string;&#125;class Person &#123; name: string;&#125;let p: Named;// OK, because of structural typingp = new Person(); Named和person是两个不同的东西，但是结构类似，于是不报错，因为JavaScript里广泛地使用匿名对象，例如函数表达式和对象字面量，所以使用结构类型系统来描述这些类型比使用名义类型系统更好。 关于可靠性的注意事项 TypeScript的类型系统允许某些在编译阶段无法确认其安全性的操作。当一个类型系统具此属性时，被当做是“不可靠”的。TypeScript允许这种不可靠行为的发生是经过仔细考虑的 开始123456789101112interface Named &#123; name: string;&#125;let x: Named;// y's inferred type is &#123; name: string; location: string; &#125;let y = &#123; name: 'Alice', location: 'Seattle' &#125;;x = y;function greet(n: Named) &#123; alert('Hello, ' + n.name);&#125;greet(y); // OK 这里要检查y是否能赋值给x，编译器检查x中的每个属性，看是否能在y中也找到对应属性。 在这个例子中， y必须包含名字是name的string类型成员。y满足条件，因此赋值正确 比较两个函数 原始类型和对象比较起来容易理解，但是对象怎么比较？ 通过比较参数来判断,x可以赋值给y是因为在js中参数可以忽略 12345let x = (a: number) =&gt; 0;let y = (b: number, s: string) =&gt; 0;y = x; // OKx = y; // Error 通过返回值来判断，类型系统强制源函数的返回值类型必须是目标函数返回值类型的子类型。 12345let x = () =&gt; (&#123;name: 'Alice'&#125;);let y = () =&gt; (&#123;name: 'Alice', location: 'Seattle'&#125;);x = y; // OKy = x; // Error because x() lacks a location property 函数参数双向协变 当比较函数参数类型时，只有当源函数参数能够赋值给目标函数或者反过来时才能赋值成功。 这是不稳定的，因为调用者可能传入了一个具有更精确类型信息的函数，但是调用这个传入的函数的时候却使用了不是那么精确的类型信息。 实际上，这极少会发生错误，并且能够实现很多JavaScript里的常见模式。 1234567891011121314151617181920enum EventType &#123; Mouse, Keyboard &#125;interface Event &#123; timestamp: number; &#125;interface MouseEvent extends Event &#123; x: number; y: number &#125;interface KeyEvent extends Event &#123; keyCode: number &#125;function listenEvent(eventType: EventType, handler: (n: Event) =&gt; void) &#123; /* ... */&#125;// Unsound, but useful and commonlistenEvent(EventType.Mouse, (e: MouseEvent) =&gt; console.log(e.x + ',' + e.y));// Undesirable alternatives in presence of soundnesslistenEvent(EventType.Mouse, (e: Event) =&gt; console.log((&lt;MouseEvent&gt;e).x + ',' + (&lt;MouseEvent&gt;e).y));listenEvent(EventType.Mouse, &lt;(e: Event) =&gt; void&gt;((e: MouseEvent) =&gt; console.log(e.x + ',' + e.y)));// Still disallowed (clear error). Type safety enforced for wholly incompatible typeslistenEvent(EventType.Mouse, (e: number) =&gt; console.log(e)); 可选参数及剩余参数 比较函数兼容性的时候，可选参数与必须参数是可互换的。 源类型上有额外的可选参数不是错误，目标类型的可选参数在源类型里没有对应的参数也不是错误 当一个函数有剩余参数时，它被当做无限个可选参数。 这对于类型系统来说是不稳定的，但从运行时的角度来看，可选参数一般来说是不强制的，因为对于大多数函数来说相当于传递了一些undefinded。 123456789function invokeLater(args: any[], callback: (...args: any[]) =&gt; void) &#123; /* ... Invoke callback with 'args' ... */&#125;// Unsound - invokeLater "might" provide any number of argumentsinvokeLater([1, 2], (x, y) =&gt; console.log(x + ', ' + y));// Confusing (x and y are actually required) and undiscoverableinvokeLater([1, 2], (x?, y?) =&gt; console.log(x + ', ' + y)); 函数重载 对于有重载的函数，源函数的每个重载都要在目标函数上找到对应的函数签名。 这确保了目标函数可以在所有源函数可调用的地方调用。 枚举 枚举类型与数字类型兼容，并且数字类型与枚举类型兼容。不同枚举类型之间是不兼容的。 123456enum Status &#123; Ready, Waiting &#125;;enum Color &#123; Red, Blue, Green &#125;;let status1 = Status.Ready;status = Color.Green; //error 类 类与对象字面量和接口差不多，但有一点不同：类有静态部分和实例部分的类型。 比较两个类类型的对象时，只有实例的成员会被比较。 静态成员和构造函数不在比较的范围内。 123456789101112131415class Animal &#123; feet: number; constructor(name: string, numFeet: number) &#123; &#125;&#125;class Size &#123; feet: number; constructor(numFeet: number) &#123; &#125;&#125;let a: Animal;let s: Size;a = s; //OKs = a; //OK 类的私有成员 私有成员会影响兼容性判断。 当类的实例用来检查兼容时，如果目标类型包含一个私有成员，那么源类型必须包含来自同一个类的这个私有成员。 这允许子类赋值给父类，但是不能赋值给其它有同样类型的类。 泛型 因为TypeScript是结构性的类型系统，类型参数只影响使用其做为类型一部分的结果类型。 123456interface Empty&lt;T&gt; &#123;&#125;let x: Empty&lt;number&gt;;let y: Empty&lt;string&gt;;x = y; // okay, y matches structure of x 当存在内容时，两者又不一样。 1234567interface NotEmpty&lt;T&gt; &#123; data: T;&#125;let x: NotEmpty&lt;number&gt;;let y: NotEmpty&lt;string&gt;;x = y; // error, x and y are not compatible 对于没指定泛型类型的泛型参数时，会把所有泛型参数当成any比较。 然后用结果类型进行比较123456789let identity = function&lt;T&gt;(x: T): T &#123; // ...&#125;let reverse = function&lt;U&gt;(y: U): U &#123; // ...&#125;identity = reverse; // Okay because (x: any)=&gt;any matches (y: any)=&gt;any]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>typescript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[typescript-类型推断]]></title>
    <url>%2F2018%2F06%2F13%2Ftypescript-%E7%B1%BB%E5%9E%8B%E6%8E%A8%E6%96%AD%2F</url>
    <content type="text"><![CDATA[前言 这节写的是类型是怎样被推断出来的 最佳通用类型1let arr = [1,null,2,'string']; //let arr: (string | number)[] 对于未定义类型的数组，编译器会自动选择最佳通用类型 let arr: (string | number)[] 1234567891011121314151617181920212223interface tongyong &#123; name:string; age:number;&#125;interface Animal &#123; [index: number]:tongyong&#125;class Rhino implements tongyong&#123; name = 'Rhino'; age = 12;&#125;class fish implements tongyong&#123; name = 'fish'; age = 12;&#125;class jafish implements tongyong&#123; name = 'jafish'; age = 12;&#125;let zoo = [new Rhino(), new fish(), new jafish()] //let zoo: (Rhino | fish | jafish)[] 上面的zoo最佳推断类型就是这个 let zoo: (Rhino | fish | jafish)[]，其实可以改下 12345678910111213141516171819202122interface Animal &#123; name:string; age:number;&#125;class Rhino implements Animal&#123; name = 'Rhino'; age = 12;&#125;class fish implements Animal&#123; name = 'fish'; age = 12;&#125;class jafish implements Animal&#123; name = 'jafish'; age = 12;&#125;let zoo:Animal[] = [new Rhino(), new fish(), new jafish()] //let zoo: (Rhino | fish | jafish)[] 上下文类型123window.onmousedown = function(mouseEvent) &#123; console.log(mouseEvent.button); //&lt;- Error&#125;; 官网文档说这样写会报错，但是实际并没有，有点头晕，下面官方写法 1234window.onmousedown = function(mouseEvent: any) &#123; console.log(mouseEvent.button); //&lt;- Now, no error is given&#125;;//这个函数表达式有明确的参数类型注解，上下文类型被忽略]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>typescript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[typescript-泛型]]></title>
    <url>%2F2018%2F06%2F13%2Ftypescript-%E6%B3%9B%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[前言 泛型来创建可重用的组件，一个组件可以支持多种类型的数据 ###泛型初探 没有泛型之前，我们需要传入的参数和返回的参数一致，我们可能会这样处理,但是最后导致输入输出并一定一致123function indentify(arg:any) any&#123; return arg&#125; 用泛型的话可以避免了，通T来捕获用户传的值类型，同时使用T作为类型返回，保证了一致性123function indentify&lt;T&gt;(arg:T): T&#123; return arg;&#125; 第一种调用写法 let output = indentify(‘ly’) //传参必须是string类型 第二种调用写法let output = identity(“myString”); //传参必须是string类型 泛型类型 泛型函数的类型与非泛型函数的类型没什么不同，只是有一个类型参数在最前面，像函数声明一样 123456789101112131415function identity&lt;T&gt;(arg: T): T &#123; return arg;&#125;//几种类型//let a1: &lt;T&gt;(arg: T)=&gt; T = identity;//我们也可以使用不同的泛型参数名，只要在数量上和使用方式上能对应上就可以。let a2: &lt;U&gt;(arg: U) =&gt; U = identity;// 我们还可以使用带有调用签名的对象字面量来定义泛型函数：let myIdentity: &#123;&lt;T&gt;(arg: T): T&#125; = identity; 定义一个泛型的接口 123456789interface IndentifyFn &#123; &lt;T&gt;(arg: T): T;&#125;function indentify&lt;T&gt;(arg: T):T&#123; return arg;&#125;let myIndentify: IndentifyFn = indentify; 把泛型参数当作整个接口的一个参数 12345678910interface IndentifyFn&lt;T&gt; &#123; &lt;T&gt;(arg: T): T;&#125;function indentify&lt;T&gt;(arg: T):T&#123; return arg;&#125;let myIndentify: IndentifyFn&lt;number&gt; = indentify; 泛型类 泛型类看上去与泛型接口差不多。 泛型类使用（ &lt;&gt;）括起泛型类型，跟在类名后面。 12345678class GenericNumber&lt;T&gt; &#123; zeroValue: T; add: (x: T, y: T) =&gt; T;&#125;let myGenericNumber = new GenericNumber&lt;number&gt;();myGenericNumber.zeroValue = 0;myGenericNumber.add = function(x, y) &#123; return x + y; &#125;; 类有两部分：静态部分和实例部分。 泛型类指的是实例部分的类型，所以类的静态属性不能使用这个泛型类型。 泛型约束1234function loggingIdentity&lt;T&gt;(arg: T): T &#123; console.log(arg.length); // Error: T doesn't have .length return arg;&#125; 由于arg是泛型，类型有很多不确定性，上面的.length会报错，所以我们需要定义一个约束12345678interface Lengthwise &#123; length: number;&#125;function loggingIdentity&lt;T extends Lengthwise&gt;(arg: T): T &#123; console.log(arg.length); // Now we know it has a .length property, so no more error return arg;&#125; 泛型被约束了，现在只有存在length的属性才能被放进来 1234567loggingIdentity(3) //Argument of type '3' is not assignable to parameter of type 'Lengthwise'.loggingIdentity('2323232') //okloggingIdentity([1,2,5,4,6])//okloggingIdentity(&#123;length: 10, value: 3&#125;); //ok 在泛型约束中使用类型参数 你可以声明一个类型参数，且它被另一个类型参数所约束,比如，现在我们想要用属性名从对象里获取这个属性。 并且我们想要确保这个属性存在于对象 obj上，因此我们需要在这两个类型之间使用约束 12345678function getProperty&lt;T, K extends keyof T&gt;(obj: T, key: K) &#123; return obj[key];&#125;let x = &#123; a: 1, b: 2, c: 3, d: 4 &#125;;getProperty(x, "a"); // okaygetProperty(x, "m"); //Argument of type '"m"' is not assignable to parameter of type '"a" | "b" | "c" | "d"'. 在泛型里使用类类型 在TypeScript使用泛型创建工厂函数时，需要引用构造函数的类类型 123function create&lt;T&gt;(c: &#123;new(): T; &#125;): T &#123; return new c();&#125; 高级例子123456789101112131415161718192021222324252627class BeeKeeper &#123; hasMask: boolean;&#125;class ZooKeeper &#123; nametag: string;&#125;class Animal &#123; numLegs: number;&#125;class Bee extends Animal &#123; keeper: BeeKeeper;&#125;class Lion extends Animal &#123; keeper: ZooKeeper;&#125;function createInstance&lt;A extends Animal&gt;(c: new () =&gt; A): A &#123; return new c();&#125;createInstance(Lion).keeper.nametag; // typechecks!createInstance(Bee).keeper.hasMask; // typechecks!]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>typescript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[typescript-function]]></title>
    <url>%2F2018%2F06%2F12%2Ftypescript-function%2F</url>
    <content type="text"><![CDATA[前言 函数是js的第一等公民，同样在typescript中，function也是不可缺少的存在 函数类型为函数定义类型123456789// 两种写法function add(x:number, y:number): number &#123; return x+y;&#125;let myAdd = function(x:number, y:number): number &#123; return x+y;&#125; 书写完整的函数类型123456let myAdd: (x: number, y: number) =&gt; number = function(x: number, y: number): number &#123; return x + y; &#125;;//吓到我了 ，编译后就是这么点var myAdd = function (x, y) &#123; return x + y; &#125;; 只要参数类型是匹配的，那么就认为它是有效的函数类型，而不在乎参数名是否正确。 1234let myAdd: (x: number, y: number) =&gt; number = function(x1: number, y2: number): number &#123; return x + y; &#125;;var myAdd = function (x, y) &#123; return x + y; &#125;; 推断类型 上面写肯定很繁琐，于是可以通过编译器的推断来写，比如 12345678// myAdd has the full function typelet myAdd = function(x: number, y: number): number &#123; return x + y; &#125;;// The parameters `x` and `y` have the type numberlet myAdd: (baseValue: number, increment: number) =&gt; number = function(x, y) &#123; return x + y; &#125;;//这叫做“按上下文归类”，是类型推论的一种。 它帮助我们更好地为程序指定类型。 可选参数和默认参数 期望参数和实际传的参数必须一致 1234567function buildName(firstName: string, lastName: string) &#123; return firstName + " " + lastName;&#125;let result1 = buildName("Bob"); // error, too few parameterslet result2 = buildName("Bob", "Adams", "Sr."); // error, too many parameterslet result3 = buildName("Bob", "Adams"); // ah, just right 可以少传参数 用?实现 12345678910function buildName(firstName: string, lastName?: string) &#123; if (lastName) return firstName + " " + lastName; else return firstName;&#125;let result1 = buildName("Bob"); // works correctly nowlet result2 = buildName("Bob", "Adams", "Sr."); // error, too many parameterslet result3 = buildName("Bob", "Adams"); // ah, just right 当然我们也可设置默认参数 12345678function buildName(firstName: string, lastName = "Smith") &#123; return firstName + " " + lastName;&#125;let result1 = buildName("Bob"); // works correctly now, returns "Bob Smith"let result2 = buildName("Bob", undefined); // still works, also returns "Bob Smith"let result3 = buildName("Bob", "Adams", "Sr."); // error, too many parameterslet result4 = buildName("Bob", "Adams"); // ah, just right 我们如何传多个参数呢，可通过扩展运算符来搞事情 12345function buildName(firstName: string, ...restOfName: string[]) &#123; return firstName + " " + restOfName.join(" ");&#125;let buildNameFun: (fname: string, ...rest: string[]) =&gt; string = buildName; thisthis和箭头函数12345678910111213let s = &#123; name:'ly', getname:function()&#123; console.log(this.name) //ly return function()&#123; console.log(this.name) //undefind &#125; &#125;&#125;let s1 = s.getname();s1() 上面的例子表明this的指向在第二个的时候已经变成了window了,这样很容易造成困扰，于是箭头函数出来了，他可以指向上下文对象 12345678910111213let s = &#123; name:'ly', getname()&#123; console.log(this.name) return ()=&gt;&#123; console.log(this.name) &#125; &#125;&#125;let s1 = s.getname();s1() 然而在typescript里面this的类型确是any，我们需要修改成我们需要的类型 1234567891011121314151617181920interface p1 &#123; name:string; age:number&#125;interface person &#123; name:string; age:number; getmessage(this:person):()=&gt;p1;&#125;let p2:person = &#123; name:'ly', age:18, getmessage(this:person)&#123; return ()=&gt;(&#123; name:this.name, age:this.age &#125;) &#125;&#125; 重载 对方法进行重载，根据参数选择使用哪个方法 12345678910111213141516171819var suits = ["hearts", "spades", "clubs", "diamonds"];function pickCard(x) &#123; // Check to see if we're working with an object/array // if so, they gave us the deck and we'll pick the card if (typeof x == "object") &#123; var pickedCard = Math.floor(Math.random() * x.length); return pickedCard; &#125; // Otherwise just let them pick the card else if (typeof x == "number") &#123; var pickedSuit = Math.floor(x / 13); return &#123; suit: suits[pickedSuit], card: x % 13 &#125;; &#125;&#125;var myDeck = [&#123; suit: "diamonds", card: 2 &#125;, &#123; suit: "spades", card: 10 &#125;, &#123; suit: "hearts", card: 4 &#125;];var pickedCard1 = myDeck[pickCard(myDeck)];console.log("card: " + pickedCard1.card + " of " + pickedCard1.suit);var pickedCard2 = pickCard(15);console.log("card: " + pickedCard2.card + " of " + pickedCard2.suit); 注意，function pickCard(x): any并不是重载列表的一部分，因此这里只有两个重载：一个是接收对象另一个接收数字。 以其它参数调用 pickCard会产生错误。v 我的写法 上面有点难懂 1234567891011121314151617181920let suits = ["hearts", "spades", "clubs", "diamonds"];function add(x:number):number;function add(x:string):number;function add(x:object):number;function add(x):any&#123; if(typeof x ==='object')&#123; console.log(1) &#125; if(typeof x ==='string')&#123; console.log(2) &#125; if(typeof x ==='number')&#123; console.log(3) &#125;&#125;;add(1);add('false')add(&#123;&#125;)]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>typescript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[typescript-类]]></title>
    <url>%2F2018%2F06%2F12%2Ftypescript-%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[前言 类是es6的概念，在typescript也是存在的，本身typescript是为了方便后台开发者也能迅速入手js而设计的，现在我们来学习下类 类 简单的类1234567891011class Greeter &#123; greeting:string; constructor(message:string)&#123; this.greeting = message; &#125; greet()&#123; return 'hello,'+this.greeting; &#125; &#125;let greeter = new Greeter('world') 声明一个 Greeter类。这个类有3个成员：一个叫做 greeting的属性，一个构造函数和一个 greet方法 引用任何一个类成员的时候都用了 this。 它表示我们访问的是类的成员。 使用 new构造了 Greeter类的一个实例。 它会调用之前定义的构造函数，创建一个 Greeter类型的新对象，并执行构造函数初始化它。 继承 继承和接口继承是一样的，通过继承来扩展基类 12345678910111213141516class Animal &#123; move(distanceInMeters: number = 0) &#123; console.log(`Animal moved $&#123;distanceInMeters&#125;m.`); &#125;&#125;class Dog extends Animal &#123; bark() &#123; console.log('Woof! Woof!'); &#125;&#125;const dog = new Dog();dog.bark();dog.move(10);dog.bark(); 类从基类中继承了属性和方法。 这里， Dog是一个 派生类，它派生自 Animal 基类，通过 extends关键字。 派生类通常被称作 子类，基类通常被称作 超类。 因为 Dog继承了 Animal的功能，因此我们可以创建一个 Dog的实例，它能够 bark()和 move()。 super()1234567891011121314151617181920212223242526272829class Animal &#123; name: string; constructor(theName: string) &#123; this.name = theName; &#125; move(distanceInMeters: number = 0) &#123; console.log(`$&#123;this.name&#125; moved $&#123;distanceInMeters&#125;m.`); &#125;&#125;class Snake extends Animal &#123; constructor(name: string) &#123; super(name); &#125; move(distanceInMeters = 5) &#123; console.log("Slithering..."); super.move(distanceInMeters); &#125;&#125;class Horse extends Animal &#123; constructor(name: string) &#123; super(name); &#125; move(distanceInMeters = 45) &#123; console.log("Galloping..."); super.move(distanceInMeters); &#125;&#125;let sam = new Snake("Sammy the Python");let tom: Animal = new Horse("Tommy the Palomino");sam.move();tom.move(34); 派生类包含了一个构造函数，它 必须调用 super()，它会执行基类的构造函数。 而且，在构造函数里访问 this的属性之前，我们 一定要调用 super()。 这个是TypeScript强制执行的一条重要规则。 这个例子演示了如何在子类里可以重写父类的方法。 Snake类和 Horse类都创建了 move方法，它们重写了从 Animal继承来的 move方法，使得 move方法根据不同的类而具有不同的功能。 注意，即使 tom被声明为 Animal类型，但因为它的值是 Horse，调用 tom.move(34)时，它会调用 Horse里重写的方法 公共，私有与受保护的修饰符 默认 public public 所有成员都可以访问 12345678910111213class Greeter &#123; public greeting:string; public constructor(message:string)&#123; this.greeting = message; &#125; public greet()&#123; return 'hello,'+this.greeting; &#125; &#125;let greeter = new Greeter('world');console.log(greeter.greeting) // world private 私有变量成员不能被访问 123456789101112class Greeter &#123; private greeting:string; public constructor(message:string)&#123; this.greeting = message; &#125; public greet()&#123; return 'hello,'+this.greeting; &#125; &#125;let greeter = new Greeter('world');console.log(greeter.greeting) // 属性“greeting”为私有属性，只能在类“Greeter”中访问 TypeScript使用的是结构性类型系统。 当我们比较两种不同的类型时，并不在乎它们从何处而来，如果所有成员的类型都是兼容的，我们就认为它们的类型是兼容的。 当我们比较带有 private或 protected成员的类型的时候，情况就不同了。 如果其中一个类型里包含一个 private成员，那么只有当另外一个类型中也存在这样一个 private成员， 并且它们都是来自同一处声明时，我们才认为这两个类型是兼容的。 对于 protected成员也使用这个规则。 1234567891011121314151617181920class Animal &#123; private name: string; constructor(theName: string) &#123; this.name = theName; &#125;&#125;class Rhino extends Animal &#123; constructor() &#123; super("Rhino"); &#125;&#125;class Employee &#123; private name: string; constructor(theName: string) &#123; this.name = theName; &#125;&#125;let animal = new Animal("Goat");let rhino = new Rhino();let employee = new Employee("Bob");animal = rhino;animal = employee; // 错误: Animal 与 Employee 不兼容. 这个例子中有 Animal和 Rhino两个类， Rhino是 Animal类的子类。 还有一个 Employee类，其类型看上去与 Animal是相同的。 我们创建了几个这些类的实例，并相互赋值来看看会发生什么。 因为 Animal和 Rhino共享了来自 Animal里的私有成员定义 private name: string，因此它们是兼容的。 然而 Employee却不是这样。当把 Employee赋值给 Animal的时候，得到一个错误，说它们的类型不兼容。 尽管 Employee里也有一个私有成员 name，但它明显不是 Animal里面定义的那个。 protected protected修饰符与 private修饰符的行为很相似，但有一点不同， protected成员在派生类中仍然可以访问 123456789101112131415161718192021class Person &#123; protected name: string; constructor(name: string) &#123; this.name = name; &#125;&#125;class Employee extends Person &#123; private department: string; constructor(name: string, department: string) &#123; super(name) this.department = department; &#125; public getElevatorPitch() &#123; return `Hello, my name is $&#123;this.name&#125; and I work in $&#123;this.department&#125;.`; &#125;&#125;let howard = new Employee("Howard", "Sales");console.log(howard.getElevatorPitch());console.log(howard.name); // 错误 构造函数也可以被派生，但是不能被实例化 12345678910111213141516171819202122class Person &#123; protected name: string; protected constructor(theName: string) &#123; this.name = theName; &#125;&#125;// Employee 能够继承 Personclass Employee extends Person &#123; private department: string; constructor(name: string, department: string) &#123; super(name); this.department = department; &#125; public getElevatorPitch() &#123; return `Hello, my name is $&#123;this.name&#125; and I work in $&#123;this.department&#125;.`; &#125;&#125;let howard = new Employee("Howard", "Sales");let john = new Person("John"); // 错误: 'Person' 的构造函数是被保护的. readonly修饰符 使用 readonly关键字将属性设置为只读的。 只读属性必须在声明时或构造函数里被初始化。 12345678910class Octopus &#123; readonly name: string; readonly numberOfLegs: number = 8; constructor (theName: string) &#123; this.name = theName; &#125;&#125;let dad = new Octopus("Man with the 8 strong legs");console.log(dad.name) //Man with the 8 strong legsdad.name = "Man with the 3-piece suit"; // 错误! name 是只读的. 参数属性 使用参数属性前 1234567class Animal &#123; name: string; constructor(theName: string) &#123; this.name = theName; &#125; move(distanceInMeters: number) &#123; console.log(`$&#123;this.name&#125; moved $&#123;distanceInMeters&#125;m.`); &#125;&#125; 使用后 1234567class Animal &#123; constructor(private name: string) &#123; &#125; move(distanceInMeters: number) &#123; console.log(`$&#123;this.name&#125; moved $&#123;distanceInMeters&#125;m.`); &#125;&#125; 我们是如何舍弃了 theName，仅在构造函数里使用 private name: string参数来创建和初始化 name成员。 我们把声明和赋值合并至一处。 存取器 TypeScript支持通过getters/setters来截取对对象成员的访问。 它能帮助你有效的控制对对象成员的访问。 没有get和set时 12345678910class Employee &#123; fullName: string;&#125;let employee = new Employee();employee.fullName = "Bob Smith";if (employee.fullName) &#123; console.log(employee.fullName);&#125; 有的情况 12345678910111213141516171819202122232425let passcode = "secret passcode";class Employee &#123; private _fullName: string; get fullName(): string &#123; return this._fullName; &#125; set fullName(newName: string) &#123; if (passcode &amp;&amp; passcode == "secret passcode") &#123; this._fullName = newName; &#125; else &#123; console.log("Error: Unauthorized update of employee!"); &#125; &#125;&#125;let employee = new Employee();employee.fullName = "Bob Smith";if (employee.fullName) &#123; alert(employee.fullName);&#125; 首先，存取器要求你将编译器设置为输出ECMAScript 5或更高。 不支持降级到ECMAScript 3。 其次，只带有 get不带有 set的存取器自动被推断为 readonly。 这在从代码生成 .d.ts文件时是有帮助的，因为利用这个属性的用户会看到不允许够改变它的值。 静态属性 静态属性必须通过类名调用，相当实例属性上面的this 12345678910111213141516class Grid &#123; static origin = &#123;x: 0, y: 0&#125;; calculateDistanceFromOrigin(point: &#123;x: number; y: number;&#125;) &#123; let xDist = (point.x - Grid.origin.x); let yDist = (point.y - Grid.origin.y); return Math.sqrt(xDist * xDist + yDist * yDist) / this.scale; &#125; constructor (public scale: number) &#123; &#125;&#125;let grid1 = new Grid(1.0); // 1x scalelet grid2 = new Grid(5.0); // 5x scaleconsole.log(grid1.calculateDistanceFromOrigin(&#123;x: 10, y: 10&#125;));console.log(grid2.calculateDistanceFromOrigin(&#123;x: 10, y: 10&#125;)); 抽象类 抽象类做为其它派生类的基类使用。 它们一般不会直接被实例化。 不同于接口，抽象类可以包含成员的实现细节。 abstract关键字是用于定义抽象类和在抽象类内部定义抽象方法。 123456789101112131415161718192021222324252627282930313233abstract class Department &#123; constructor(public name: string) &#123; &#125; printName(): void &#123; console.log('Department name: ' + this.name); &#125; abstract printMeeting(): void; // 必须在派生类中实现&#125;class AccountingDepartment extends Department &#123; constructor() &#123; super('Accounting and Auditing'); // 在派生类的构造函数中必须调用 super() &#125; printMeeting(): void &#123; console.log('The Accounting Department meets each Monday at 10am.'); &#125; generateReports(): void &#123; console.log('Generating accounting reports...'); &#125;&#125;let department: Department; // 允许创建一个对抽象类型的引用department = new Department(); // 错误: 不能创建一个抽象类的实例department = new AccountingDepartment(); // 允许对一个抽象子类进行实例化和赋值department.printName();department.printMeeting();department.generateReports(); // 错误: 方法在声明的抽象类中不存在 高级技巧构造函数 当创建了一个类时，其实声明了很多东西 首先就是类的实例类型 12345678910111213class Greeter &#123; greeting: string; constructor(message: string) &#123; this.greeting = message; &#125; greet() &#123; return "Hello, " + this.greeting; &#125;&#125;let greeter: Greeter; //类型 为 Greetergreeter = new Greeter("world");console.log(greeter.greet()); 创建了构造函数，这个函数会在我们使用 new创建类实例的时候被调用,我们也可以认为类具有 实例部分与 静态部分这两个部分。 12345678910111213141516171819202122class Greeter &#123; static standardGreeting = "Hello, there"; greeting: string; greet() &#123; if (this.greeting) &#123; return "Hello, " + this.greeting; &#125; else &#123; return Greeter.standardGreeting; &#125; &#125;&#125;let greeter1: Greeter;greeter1 = new Greeter();console.log(greeter1.greet()); //Hello, therelet greeterMaker: typeof Greeter = Greeter;greeterMaker.standardGreeting = "Hey there!";let greeter2: Greeter = new greeterMaker();console.log(greeter2.greet()); //Hey there! 我们创建了一个叫做 greeterMaker的变量。 这个变量保存了这个类或者说保存了类构造函数。 然后我们使用 typeof Greeter，意思是取Greeter类的类型，而不是实例的类型。 或者更确切的说，”告诉我 Greeter标识符的类型”，也就是构造函数的类型。 这个类型包含了类的所有静态成员和构造函数。 之后，就和前面一样，我们在 greeterMaker上使用 new，创建 Greeter的实例。 把类当做接口使用 类定义会创建两个东西：类的实例类型和一个构造函数。 因为类可以创建出类型，所以你能够在允许使用接口的地方使用类。 12345678910class Point &#123; x: number; y: number;&#125;interface Point3d extends Point &#123; z: number;&#125;let point3d: Point3d = &#123;x: 1, y: 2, z: 3&#125;;]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>typescript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[typescript接口的使用]]></title>
    <url>%2F2018%2F06%2F12%2Ftypescript%E6%8E%A5%E5%8F%A3%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[前言 TypeScript的核心原则之一是对值所具有的结构进行类型检查。 它有时被称做“鸭式辨型法”或“结构性子类型化”。 在TypeScript里，接口的作用就是为这些类型命名和为你的代码或第三方代码定义契约。 接口如何工作 先看一个例子 1234567891011function printLabel(labelledObj:&#123;label:string&#125;)&#123; console.log(labelledObj.label)&#125;let myObj = &#123; size:10, label:"Size 10 Object"&#125;printLabel(myObj); 类型检查器会查看printLabel的调用。 printLabel有一个参数，并要求这个对象参数有一个名为label类型为string的属性。 需要注意的是，我们传入的对象参数实际上会包含很多属性，但是编译器只会检查那些必需的属性是否存在，并且其类型是否匹配 换一种方式写 12345678910111213141516interface labelledObjValue &#123; label: string;&#125;function printLabel(labelledObj)&#123; console.log(labelledObj.label)&#125;let myObj = &#123; size:10, label:"Size 10 Object"&#125;printLabel(myObj); 类型检查器不会去检查属性的顺序，只要相应的属性存在并且类型也是对的就可以. 可选属性 接口的属性不全都是必须的，只是在某些条件下存在，所以可以通过?符号来确定它是可选择的 12345678910111213141516171819202122interface SquareConfig &#123; color?:string; width?:number;&#125;function createSquare(config:SquareConfig):&#123; color:string; area:number;&#125;&#123; let newSquare = &#123;color:'white',area:100&#125;; if(config.color)&#123; newSquare.color = config.color &#125; if(config.width)&#123; newSquare.area = config.width &#125; return newSquare;&#125;let mysquare = createSquare(&#123;color:'blue'&#125;);console.log(mysquare) 只读属性 readonly 一些对象属性只能在对象刚刚创建的时候修改其值。 1234567891011interface Point &#123; readonly x:number; readonly y:number;&#125;let p1: Point = &#123; x:100, y:99&#125;p1.x = 98; //无法分配到“x”，因为它是常数或只读属性 TypeScript具有ReadonlyArray类型，它与Array相似，只是把所有可变方法去掉了，因此可以确保数组创建后再也不能被修改 123456789101112131415161718let arr: number[] = [1,3,5,4,6];let ro : ReadonlyArray&lt;number&gt; = arr;ro[0] = 55; //类型“ReadonlyArray&lt;number&gt;”中的索引签名仅允许读取。arr[0] = 55;ro.push(6666) //类型“ReadonlyArray&lt;number&gt;”上不存在属性“push”。 ro.length = 100; //无法分配到“length”，因为它是常数或只读属性。arr = ro; //不能将类型“ReadonlyArray&lt;number&gt;”分配给类型“number[]”。类型“ReadonlyArray&lt;number&gt;”中缺少属性“push”。//可以通过 类型断言改变arr = ro as number[] 做为变量使用的话用 const，若做为属性则使用readonly 额外的属性检查12345678910interface SquareConfig &#123; color?: string; width?: number;&#125;function createSquare(config: SquareConfig): &#123; color: string; area: number &#125; &#123; // ...&#125;let mySquare = createSquare(&#123; colour: "red", width: 100 &#125;); //对象文字只能指定已知的属性，但“colour”中不存在类型“SquareConfig”。是否要写入 color? 对象字面量会被特殊对待而且会经过 额外属性检查，当将它们赋值给变量或作为参数传递的时候。 如果一个对象字面量存在任何“目标类型”不包含的属性时，你会得到一个错误。 通过类型断言我们可以绕过额外检查 let mySquare = createSquare({ width: 100, opacity: 0.5 } as SquareConfig); 最佳的方式是能够添加一个字符串索引签名，前提是你能够确定这个对象可能具有某些做为特殊用途使用的额外属性 12345interface SquareConfig &#123; color?: string; width?: number; [propName: string]: any;&#125; 还有最后一种跳过这些检查的方式，这可能会让你感到惊讶，它就是将这个对象赋值给一个另一个变量： 因为 squareOptions不会经过额外属性检查，所以编译器不会报错 12let squareOptions = &#123; colour: "red", width: 100 &#125;;let mySquare = createSquare(squareOptions); 函数类型 除了描述带有属性的普通对象外，接口也可以描述函数类型。 123456789interface SearchFunc &#123; (sourece:string,subString:string):boolean;&#125;let mySearch: SearchFunc;mySearch = function(src: string, subString: string) &#123; let result = src.search(subString); return result &gt; -1;&#125; 定义的函数可以省略 返回值类型，但是返回其他类型会报错 定义的函数可以不和接口相同 可索引的类型 可索引类型具有一个 索引签名，它描述了对象索引的类型，还有相应的索引返回值类型。 123456789interface StringArray &#123; [index: number]: string;&#125;let myArray: StringArray;myArray = ["Bob", "Fred"];let myStr: string = myArray[0]; 字符串索引签名能够很好的描述dictionary模式，并且它们也会确保所有属性与其返回值类型相匹配。 因为字符串索引声明了 obj.property和obj[“property”]两种形式都可以。12345interface NumberDictionary &#123; [index: string]: number; length: number; // 可以，length是number类型 name: string // 错误，`name`的类型与索引类型返回值的类型不匹配&#125; 类类型 与C#或Java里接口的基本作用一样，TypeScript也能够用它来明确的强制一个类去符合某种契约。 12345678910interface ClockInterface&#123; currentTime: Date;&#125;class Clock implements ClockInterface &#123; currentTime : Date; constructor(h:number,m:number)&#123; &#125;&#125; 在接口里定义的东西，在类里面也必须定义，接口只是一个模子，但是里面的实现内容可以各有各的样 1234567891011121314151617181920interface ClockInterface &#123; currentTime: Date; setTime(d: Date);&#125;class Clock1 implements ClockInterface &#123; currentTime: Date; setTime(d: Date) &#123; this.currentTime = d; &#125; constructor(h: number, m: number) &#123; &#125;&#125;class Clock2 implements ClockInterface &#123; currentTime: Date; setTime(d: Date) &#123; this.currentTime = d; console.log('我可以打印东西') &#125; constructor(h: number, m: number) &#123; &#125;&#125; 接口描述了类的公共部分，而不是公共和私有两部分。 它不会帮你检查类是否具有某些私有成员。 类静态部分与实例部分的区别 当一个类实现了一个接口时，只对其实例部分进行类型检查。 constructor存在于类的静态部分，所以不在检查的范围内,因此，我们应该直接操作类的静态部分。 12345678910111213141516171819202122232425262728interface ClockConstructor &#123; new (hour:number,minute:number):ClockInterface;&#125;interface ClockInterface &#123; tick();&#125;function createClock(ctor:ClockConstructor,hour:number,minute:number): ClockInterface &#123; return new ctor(hour,minute)&#125;class DigitalClock implements ClockInterface &#123; constructor(h:number,m:number)&#123;&#125; tick()&#123; console.log(1122) &#125;&#125;class AnalogClock implements ClockInterface &#123; constructor(h:number,m:number)&#123;&#125; tick()&#123; console.log(1122) &#125;&#125;let digital = createClock(DigitalClock, 12, 17);let analog = createClock(AnalogClock, 7, 32); 继承接口 类可以继承，接口也可以继承 12345678910111213interface Shape&#123; color:string;&#125;interface Square extends Shape &#123; sideLength:number&#125;let Square = &lt;Square&gt; &#123;&#125;;Square.color = 'blue';Square.sideLength = 10; 一个接口可以继承多个接口，创建出多个接口的合成接口。 12345678910111213141516interface Shape &#123; color: string;&#125;interface PenStroke &#123; penWidth: number;&#125;interface Square extends Shape, PenStroke &#123; sideLength: number;&#125;let square = &lt;Square&gt;&#123;&#125;;square.color = "blue";square.sideLength = 10;square.penWidth = 5.0; 混合类型 接口能够描述JavaScript里丰富的类型。 因为JavaScript其动态灵活的特点，有时你会希望一个对象可以同时具有上面提到的多种类型。 1234567891011121314151617181920interface Counter &#123; (start:number):string; interval:number; reset():void;&#125;function getCounter(): Counter &#123; let counter = &lt;Counter&gt; function (start:number) &#123;&#125;; counter.interval = 123; counter.reset = function()&#123;&#125; return counter;&#125;let c = getCounter();c(10);c.reset();c.interval = 5.0; 接口继承类 当接口继承了一个类类型时，它会继承类的成员但不包括其实现。 就好像接口声明了所有类中存在的成员，但并没有提供具体实现一样。 接口同样会继承到类的private和protected成员。 这意味着当你创建了一个接口继承了一个拥有私有或受保护的成员的类时，这个接口类型只能被这个类或其子类所实现（implement）。 123456789101112131415161718192021222324252627 class Control &#123; private state:any;&#125;interface SelectableControl extends Control &#123; select():void;&#125;class Button extends Control implements SelectableControl &#123; select()&#123; &#125;&#125;class TextBox extends Control &#123; select() &#123; &#125;&#125;// 错误：类“Image”错误实现接口“SelectableControl”。类型“Image”中缺少属性“state”。class Image implements SelectableControl &#123; select() &#123; &#125; //&#125;class Location &#123;&#125;]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>typescript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[typescript基础类型]]></title>
    <url>%2F2018%2F06%2F11%2Ftypescript%E5%9F%BA%E7%A1%80%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[前言 TypeScript 是一种由微软开发的自由和开源的编程语言，它是JavaScript的一个超集，扩展了JavaScript的语法。TypeScript 是 JavaScript 的超集，扩展了 JavaScript 的语法，因此现有的 JavaScript 代码可与 TypeScript 一起工作无需任何修改，TypeScript 通过类型注解提供编译时的静态类型检查。TypeScript 可处理已有的 JavaScript 代码，并只对其中的 TypeScript 代码进行编译 目前我感觉主要是把弱类型语言变成强类型的，但是不是强制性的 安装 npm install -g typescript 文件后缀 .ts 运行编译命令 tsc index.js 基础类型布尔值 boolean 类型 true 或者 false let isDone: boolean = false; 数字 number 类型 浮点数 支持十进制、二进制、十六进制、八进制 let decLiteral: number = 6; let hexLiteral: number = 0xf00d; let binaryLiteral: number = 0b1010; let octalLiteral: number = 0o744; 字符串 可以使用单引号或者双引号 根据指定的书写规范来 let name: string = “bob”; name = “smith”; 也可以使用字符串模板 12345 let name: string = `Gene`;let age: number = 37;let sentence: string = `Hello, my name is $&#123; name &#125;.I'll be $&#123; age + 1 &#125; years old next month.`; 数组 第一种 元素类型后接[]来定义此类型的元素组成的数组 let list: number[] = [1,2,3]; 第二种 使用数组的泛型 let list: Array = [1,2,3]; 元组 Tuple 元组类型允许表示一个已知元素数量和类型的数组，各元素的类型不必相同。 12345let x: [string,number];x = ['hello',10];x = ['hello',10,120]; //报错 长度和类型错误x = [,10,'hello']; //报错 类型错误 当访问索引值得时候，会得到正确的类型 123456let x: [string,number];x = ['hello',10];console.log(x[0].substr(1)); // OKconsole.log(x[1].substr(1)); // Error, 'number' does not have 'substr' 当访问一个越界的元素，会使用联合类型替代： 12345x[3] = 'world'; // OK, 字符串可以赋值给(string | number)类型console.log(x[5].toString()); // OK, 'string' 和 'number' 都有 toStringx[6] = true; // Error, 布尔不是(string | number)类型 枚举 enum类型是对JavaScript标准数据类型的一个补充 默认情况下 从零开始编号 12345enum Color &#123;Red, Green, Blue&#125;;let c: Color = Color.Green;console.log(c) //1 可以修改默认数值 12345678enum Color &#123;Red=1, Green, Blue&#125;;let c: Color = Color.Green;// 默认情况下 从零开始编号console.log(c) //2 我们也可以根据数值来查找名字 1234567enum Color &#123;Red=1, Green, Blue&#125;;let name: string = Color[1]// 默认情况下 从零开始编号console.log(name) //Red Any 当我们不清楚变量的类型的时候,这些值可能来自于动态的内容，比如来自用户输入或第三方代码库。 这种情况下，我们不希望类型检查器对这些值进行检查而是直接让它们通过编译阶段的检查。 那么我们可以使用 any类型来标记这些变量 1234567let notnumber: any = 4;notnumber = '1212';let differenType: any[] = [1,true,'hello'];differenType[1] = 100 Void 某种程度上来说，void类型像是与any类型相反，它表示没有任何类型。 当一个函数没有返回值时，你通常会见到其返回值类型是 void 123function warnUser(): void &#123; alert("This is my warning message");&#125; Null 和 Undefined TypeScript里，undefined和null两者各自有自己的类型分别叫做undefined和null。 和 void相似，它们的本身的类型用处不是很大 默认情况下他们是所有类型的子类型 1234567let num: number = 12;num = 'asdad'; //fail 报类型不正确num =null; //不会num = undefined; 如果编译加了 tsc .\index.ts –strictNullchecks –strictNullchecks 那么他只能给void 和他们本身的类型赋值了 Never never类型表示的是那些永不存在的值的类型。 例如， never类型是那些总是会抛出异常或根本就不会有返回值的函数表达式或箭头函数表达式的返回值类型； 变量也可能是 never类型，当它们被永不为真的类型保护所约束时 never类型是任何类型的子类型，也可以赋值给任何类型；然而，没有类型是never的子类型或可以赋值给never类型（除了never本身之外）。 即使 any也不可以赋值给never 123456789101112131415// 返回never的函数必须存在无法达到的终点function error(message: string): never &#123; throw new Error(message);&#125;// 推断的返回值类型为neverfunction fail() &#123; return error("Something failed");&#125;// 返回never的函数必须存在无法达到的终点function infiniteLoop(): never &#123; while (true) &#123; &#125;&#125; 类型断言 有时候你会遇到这样的情况，你会比TypeScript更了解某个值的详细信息。 通常这会发生在你清楚地知道一个实体具有比它现有类型更确切的类型。 通过类型断言这种方式可以告诉编译器，“相信我，我知道自己在干什么”。 类型断言好比其它语言里的类型转换，但是不进行特殊的数据检查和解构。 它没有运行时的影响，只是在编译阶段起作用。 TypeScript会假设你，程序员，已经进行了必须的检查。 “尖括号”语法 123let somevalues: any = 'i am a fe';let strlength: number = (&lt;string&gt;somevalues).length; as语法 123let somevalues: any = 'i am a fe';let strlength: number = (somevalues as string).length;]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>typescript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[test]]></title>
    <url>%2F2018%2F06%2F08%2Ftest%2F</url>
    <content type="text"></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>编程</tag>
        <tag>感悟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webpack4操作]]></title>
    <url>%2F2018%2F06%2F06%2Fwebpack4%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[前言 现在开始操作一波了，写了点理论的，该动手留点代码的印记了，嘿嘿 装webpack依赖 打开命令行工具 cmd or gitbash 创建一个一个文件夹 1mkdir webapck4 进入文件夹 1cd webapck4 创建package.json 1npm init -y 安装webpack依赖 1npm install webpack webpack-cli --save-dev 好的，我们把项目放入编辑器来操作吧 在当前目录下创建 1234-webpack4--package.json--src---index.js index.js 123//index.jsconsole.log('我是index'); 运行 npx webapck,生成了一个输出目录dist123456-webpack4--package.json--src---index.js--dist---main.js 删除dist,创建webpack.config.js 配置文件12345-webpack4--package.json--src---index.js--webpack.config.js webpack.config.js 123456789const path = require('path');module.exports = &#123; mode:'development', entry:'./src/index.js', output:&#123; path:path.resolve(__dirname,'build'), filename:'bundle.js' &#125;&#125; 在运行 npx webpack1234567-webpack4--package.json--src---index.js--webpack.config.js--build---bundle.js 方便起见，我们把命令行放在package.json的scripts 123456789101112131415161718&#123; "name": "demos", "version": "1.0.0", "description": "", "main": "index.js", "scripts": &#123; "test": "echo \"Error: no test specified\" &amp;&amp; exit 1", "start":"webpack --config webpack.config.js" &#125;, "keywords": [], "author": "", "license": "ISC", "devDependencies": &#123; "webpack": "^4.11.1", "webpack-cli": "^3.0.2" &#125;&#125; 运行 npm start 效果和之前一样 我们增加一个HTML12345678-webpack4--package.json--src---index.js--webpack.config.js--build---bundle.js---index.html 12345678910111213&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script src="./bundle.js"&gt;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 修改 index.js 1234567import _ from 'lodash';function component()&#123; var element = document.createElement('div'); element.innerHTML = _.join(['Hello', 'ly'], ' '); return element;&#125;document.body.appendChild(component()); 安装 npm install –save lodash 运行 npm start 打开index.html 在浏览器，可以看到hello ly 下一篇介绍loader]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webpack4-plugin]]></title>
    <url>%2F2018%2F06%2F05%2Fwebpack4-plugin%2F</url>
    <content type="text"><![CDATA[前言 来使用下插件,好像也没啥说的。 HtmlWebpackPlugin 到目前为止，我们在 index.html 文件中手动引入所有资源，然而随着应用程序增长，并且一旦开始对文件名使用哈希(hash)]并输出多个 bundle，手动地对 index.html 文件进行管理，一切就会变得困难起来。然而，可以通过HtmlWebpackPlugin插件，会使这个过程更容易操控。 安装 npm install –save-dev html-webpack-plugin 修改webpack.config.js 123456789101112131415161718192021222324252627282930313233343536const path = require('path');const HtmlWebpackPlugin = require('html-webpack-plugin');module.exports = &#123; mode: 'development', entry: './src/index.js', output: &#123; path: path.resolve(__dirname, 'build'), filename: '[hash]bundle.js' &#125;, module: &#123; rules: [&#123; test: /\.css$/, use: [ "style-loader", "css-loader" ] &#125;,&#123; test:/\.(png|svg|jpg|gif)$/, use:[ 'url-loader' ] &#125;,&#123; test:/\.(png|svg|jpg|gif)$/, use:[ 'url-loader' ] &#125;] &#125;, plugins:[ new HtmlWebpackPlugin(&#123; title:'改变世界' &#125;) ]&#125; clean-webpack-plugin 由于用了hash来生成目标文件，每次构建都生成新的，会很烦，我们需要及时清理构建的文件夹于是这个插件出来了 安装 npm install clean-webpack-plugin –save-dev 修改webpack.config.js 1234567891011121314151617181920212223242526272829303132333435363738const path = require('path');const HtmlWebpackPlugin = require('html-webpack-plugin');const CleanWebpackPlugin = require('clean-webpack-plugin');module.exports = &#123; mode: 'development', entry: './src/index.js', output: &#123; path: path.resolve(__dirname, 'build'), filename: '[hash]bundle.js' &#125;, module: &#123; rules: [&#123; test: /\.css$/, use: [ "style-loader", "css-loader" ] &#125;,&#123; test:/\.(png|svg|jpg|gif)$/, use:[ 'url-loader' ] &#125;,&#123; test:/\.(png|svg|jpg|gif)$/, use:[ 'url-loader' ] &#125;] &#125;, plugins:[ new CleanWebpackPlugin(['build']), new HtmlWebpackPlugin(&#123; title:'改变世界' &#125;) ]&#125; ###]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webpack4-loader]]></title>
    <url>%2F2018%2F06%2F05%2Fwebpack4-loader%2F</url>
    <content type="text"><![CDATA[前言 这个比较欢快点，理解起来可能比较麻烦，但是主要是给自己看的，我完全扒官网的例子，所以没必要看我的 加载css 安装 npm install –save-dev style-loader css-loader 修改 webpack.config.js 1234567891011121314151617181920const path = require('path');module.exports = &#123; mode: 'development', entry: './src/index.js', output: &#123; path: path.resolve(__dirname, 'build'), filename: 'bundle.js' &#125;, module: &#123; rules: [&#123; test: /\.css$/, use: [ "style-loader", "css-loader" ] &#125;] &#125;&#125; 在src/style.css 新增 123html,body&#123; background: #ff0;&#125; index.js 12345678import _ from 'lodash';import './style.css'function component()&#123; var element = document.createElement('div'); element.innerHTML = _.join(['Hello', 'ly'], ' '); return element;&#125;document.body.appendChild(component()); 加载图片 安装 npm install –save-dev file-loader url-loader 修改 webpack.config.js 123456789101112131415161718192021222324const path = require('path');module.exports = &#123; mode: 'development', entry: './src/index.js', output: &#123; path: path.resolve(__dirname, 'build'), filename: 'bundle.js' &#125;, module: &#123; rules: [&#123; test: /\.css$/, use: [ "style-loader", "css-loader" ] &#125;,&#123; test:/\.(png|svg|jpg|gif)$/, use:[ 'url-loader' ] &#125;] &#125;&#125; 新增一张图片 src/a.jpg 修改 index.js 123456789101112import _ from 'lodash';import './style.css';import tu from './a.jpg'function component()&#123; var element = document.createElement('div'); element.innerHTML = _.join(['Hello', 'ly'], ' '); var img = document.createElement('img'); img.src = tu; element.appendChild(img); return element;&#125;document.body.appendChild(component()); 字体也是一样的 修改webpack.config.js 1234567891011121314151617181920212223242526272829const path = require(&apos;path&apos;);module.exports = &#123; mode: &apos;development&apos;, entry: &apos;./src/index.js&apos;, output: &#123; path: path.resolve(__dirname, &apos;build&apos;), filename: &apos;bundle.js&apos; &#125;, module: &#123; rules: [&#123; test: /\.css$/, use: [ &quot;style-loader&quot;, &quot;css-loader&quot; ] &#125;,&#123; test:/\.(png|svg|jpg|gif)$/, use:[ &apos;url-loader&apos; ] &#125;,&#123; test:/\.(png|svg|jpg|gif)$/, use:[ &apos;url-loader&apos; ] &#125;] &#125;&#125; 新怎 src/ my-font.woff2 my-font.woff 字体 修改style.css 123456789101112@font-face &#123; font-family: &apos;MyFont&apos;; src: url(&apos;./my-font.woff2&apos;) format(&apos;woff2&apos;), url(&apos;./my-font.woff&apos;) format(&apos;woff&apos;); font-weight: 600; font-style: normal;&#125;html,body &#123; background: #ff0; font-family: &apos;MyFont&apos;;&#125;]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webpack4使用]]></title>
    <url>%2F2018%2F06%2F05%2Fwebpack4%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[前言 现在打算花一周时间把webpack研究下，虽然之前也花了不少力气学习，这次要通读下webpack官网，顺便学习一下webpack4的新特性，内容会有点枯燥，可能看不懂，但是也要多读啊 简单概念 这里有几个比较重要的概念 先理解下 Entry、Output、Loaders、Plugins 入口 Entry 入口起点指示webpack从哪里开始构建模块，从入口起点开始，webpack会找出其中的模块与库之间的关系，可能是直接的也可能是间接的 webpack一般默认的入口文件一般是 ./src/index.js 当然我们也可以在webpack.congfig.js 配置123module.exports = &#123; entry:'.src/main.js'&#125; 入口文件可以是一个也可以是多个，还有对象语法 单个入口entry: string|Array 字符串时，同上 数组时，将多个文件打包到一起，按顺序123456789const path = require('path') //用于操作文件路径module.exports = &#123; mode:'production', entry:['./src/index.js','./src/main.js'], output:&#123; path:path.resolve(__dirname,'dist'), //输出的文件夹 filename:'bundle.js' //文件名 &#125;&#125; 对象语法 entry: {[entryChunkName: string]: string|Array} 其实这个多入口写法123456789101112const path = require('path') //用于操作文件路径module.exports = &#123; mode:'production', entry:&#123; app:'./src/index.js', //app就是名字，后面就是路径 vender:'./src/main.js' &#125;, output:&#123; path:path.resolve(__dirname,'dist'), //输出的文件夹 filename:'bundle.js' //文件名 &#125;&#125; 上面的写法会报错 我们还需要指定每个文件出口文件，也是多入口的 12345678const path = require('path') //用于操作文件路径module.exports = &#123; ... output:&#123; path:path.resolve(__dirname,'dist'), //输出的文件夹 filename:'[name]bundle.js' //文件名 加这个name name就是输入文件的name &#125;&#125; 出口 Output 出口属性指示webpack在哪里输出它所创建的bundles，以及如何命名这些文件，所有有依赖关系的文件在编译后都会输出到你指定的输出文件夹里面 webpack一般默认的出口文件一般是 ./dist/main.js webpack.congfig.js 配置12345678const path = require('path') //用于操作文件路径module.exports = &#123; entry:'.src/main.js', output:&#123; path:path.resolve(___dirname,'dist'), //输出的文件夹 filename:'bundle.js' //文件名 &#125;&#125; Loaders webpack只能处理js文件，通过loader我们可以将其他文件类型转换成webpack可以处理的文件 test 属性通过正则来识别需要loader处理的文件 use 使用哪个loader来处理这个文件 12345678910111213141516const path = require('path') //用于操作文件路径module.exports = &#123; entry:'.src/main.js', output:&#123; path:path.resolve(___dirname,'dist'), //输出的文件夹 filename:'bundle.js' //文件名 &#125;, module:&#123; rules:[ &#123; test:/\.txt$/, use:'raw-loader' &#125; ] &#125;&#125; 我们还可以配置多个loader处理同一个文件，使得文件更加‘干净’,便于我们更好的操作 1234567891011121314151617module: &#123; rules: [ &#123; test: /\.css$/, use: [ &#123; loader: 'style-loader' &#125;, &#123; loader: 'css-loader', options: &#123; modules: true &#125; &#125; ] &#125; ] &#125; loder使用还有其他两种方法 内联:在需要导入其他文件的地方加入loder,通过前置所有规则及使用 !，可以对应覆盖到配置中的任意 loader。1import Styles from 'style-loader!css-loader?modules!./styles.css'; CLI1webpack --module-bind jade-loader --module-bind 'css=style-loader!css-loader' 插件(plugins) loader被用于转换某些文件，而插件则是用于更广泛的任务，如常用的热启动，打包优化，压缩，以及注入环境变量 通过require()来引入插件，并且增加一个插件的数组，插件可以被多次使用，于是我们可以通过new来实现，同事也可以通过选项进行配置1234567891011121314151617181920212223const path = require('path') //用于操作文件路径const HtmlWebpackPlugin = require('html-webpack-plugin'); //引入插件module.exports = &#123; entry:'.src/main.js', output:&#123; path:path.resolve(___dirname,'dist'), //输出的文件夹 filename:'bundle.js' //文件名 &#125;, module:&#123; rules:[ &#123; test:/\.txt$/, use:'raw-loader' &#125; ] &#125;, plugins:[ new HtmlWebpackPlugin(&#123; template:'/src/index.html' &#125;) ]&#125; mode 通过这个来区分生产环境和开发环境，在webpack4通过配置这个可以在生产环境自动进行压缩优化 production 生产环境 development 开发环境 123456789101112131415161718192021222324const path = require('path') //用于操作文件路径const HtmlWebpackPlugin = require('html-webpack-plugin'); //引入插件module.exports = &#123; mode:'development' entry:'.src/main.js', output:&#123; path:path.resolve(___dirname,'dist'), //输出的文件夹 filename:'bundle.js' //文件名 &#125;, module:&#123; rules:[ &#123; test:/\.txt$/, use:'raw-loader' &#125; ] &#125;, plugins:[ new HtmlWebpackPlugin(&#123; template:'/src/index.html' &#125;) ]&#125; 兼容性问题 兼容所有es5的浏览器，不支持ie8一下的浏览器，官网提供补丁间接支持以下浏览器]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常用的正则表达式]]></title>
    <url>%2F2018%2F06%2F04%2F%E5%B8%B8%E7%94%A8%E7%9A%84%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[写下几个常用的正则表达式 这是自己写的几个，可能仅仅适合我，但是参考价值还是有的嘛 手机号校验 校验规则 长度=11，文本0-9，首位=1 12345678910111213141516const PhoneReg = /^1\d&#123;10&#125;$/;let testSting = &apos;13798548658&apos;if (PhoneReg.test(testSting)) &#123; console.log(&apos;success&apos;)&#125;else&#123; console.error(&apos;fail&apos;)&#125; //测试用例let str1 = &apos;12548785487&apos; //successlet str2 = &apos;2158&apos; //faillet str3 = &apos;21587954863&apos; //faillet str4 = &apos;11587954863&apos; //successlet str5 = &apos;撒大大奥术大师多&apos; //faillet str6 = &apos;1387957ssas&apos; //fail 图形验证码 长度=4，文本0-9，a-z，A-Z 12345678910111213141516const PhoneReg = /^[A-Za-z0-9]&#123;4&#125;$/;let testSting = &apos; ascc&apos;if (PhoneReg.test(testSting)) &#123; console.log(&apos;success&apos;)&#125;else&#123; console.error(&apos;fail&apos;)&#125;// 测试用例// let testSting = &apos;1254&apos; success// let testSting = &apos;ass2&apos; success// let testSting = &apos;1ZAa&apos; success// let testSting = &apos;asss2&apos; fail // let testSting = &apos;--qa&apos; fail// let testSting = &apos; ascc&apos; fail 需要做去空格处理 手机验证码 长度=6，文本0-9 1234567891011121314151617const PhoneReg = /^[0-9]&#123;6&#125;$/;let testSting = &apos;999999&apos;if (PhoneReg.test(testSting)) &#123; console.log(&apos;success&apos;)&#125;else&#123; console.error(&apos;fail&apos;)&#125;// 测试用例// let testSting = &apos;999999&apos; success// let testSting = &apos;121202&apos; success// let testSting = &apos;ascc&apos; fail// let testSting = &apos;ascc12&apos; fail// let testSting = &apos;12658&apos; fail// let testSting = &apos;1265 &apos; fail// let testSting = &apos;1212-2 &apos; fail 登录密码 长度&gt;=6且&lt;=20，文本0-9，a-z，A-Z，符号不含空格 123456789101112131415const PhoneReg = /^\S&#123;6,20&#125;$/;let testSting = &apos;12aa、、 &apos;if (PhoneReg.test(testSting)) &#123; console.log(&apos;success&apos;)&#125;else&#123; console.error(&apos;fail&apos;)&#125;// 测试用例// let testSting = &apos;？？？？？？&apos; success// let testSting = &apos;12aa、、&apos; success// let testSting = &apos;999999&apos; success// let testSting = &apos;ascc..&apos; fail// let testSting = &apos;12aa、、 &apos; fail 邀请码 文本0-9，a-z，A-Z 1234567891011121314const PhoneReg = /^\w+$/;let testSting = &apos;12aaAA&apos;if (PhoneReg.test(testSting)) &#123; console.log(&apos;success&apos;)&#125;else&#123; console.error(&apos;fail&apos;)&#125;// 测试用例// let testSting = &apos;12aaAA&apos; success// let testSting = &apos;999999&apos; success// let testSting = &apos;12aa、、 &apos; fail// let testSting = &apos;12+++&apos; fail 手机号/邮箱/用户名 长度&lt;=20，文本0-9，a-z，A-Z，字符@ 12345678910111213141516const PhoneReg = /^[0-9a-zA-Z@]&#123;0,20&#125;$/;let testSting = &apos;1asdasdasdasd&apos;if (PhoneReg.test(testSting)) &#123; console.log(&apos;success&apos;)&#125;else&#123; console.error(&apos;fail&apos;)&#125;// 测试用例// let testSting = &apos;12aaAA&apos; success// let testSting = &apos;1asdasdasdasd&apos; success// let testSting = &apos;12aaAA@&apos; success// let testSting = &apos;12aaAA.&apos; fail// let testSting = &apos;12aaAA@++&apos; fail// let testSting = &apos;1asdasdasdasdasdasdadasdasd&apos; fail 身份证号 长度=15或18，文本0-9，x，X 12345678910111213141516const PhoneReg = /(^\d&#123;15&#125;$)|(^\d&#123;18&#125;$)|(^\d&#123;17&#125;(\d|X|x)$)/;let testSting = &apos;5103221988x5060715&apos;if (PhoneReg.test(testSting)) &#123; console.log(&apos;success&apos;)&#125;else&#123; console.error(&apos;fail&apos;)&#125;// 测试用例// let testSting = &apos;36082219750711058X&apos; success// let testSting = &apos;510322198805060715&apos; success// let testSting = &apos;510322198805000&apos; success// let testSting = &apos;36082219750711058a&apos; fail// let testSting = &apos;510322198xxx805000&apos; fail 银行卡号 长度&gt;=16且&lt;=20，文本0-9 1234567891011121314151617const PhoneReg = /^[0-9]&#123;16,20&#125;$/;let testSting = &apos;&apos;if (PhoneReg.test(testSting)) &#123; console.log(&apos;success&apos;)&#125;else&#123; console.error(&apos;fail&apos;)&#125;// 测试用例// let testSting = &apos;1234567891234567&apos; success// let testSting = &apos;12345678912345678787&apos; success// let testSting = &apos;123456789123456&apos; fail// let testSting = &apos;1234567891234567878c&apos; fail// let testSting = &apos;1234567891234567878=&apos; fail 充值金额 长度&lt;=5，文本0-9，首位&gt;0 1234567891011121314151617const PhoneReg = /^[1-9][0-9]&#123;0,5&#125;$/;let testSting = &apos;12&apos;if (PhoneReg.test(testSting)) &#123; console.log(&apos;success&apos;)&#125;else&#123; console.error(&apos;fail&apos;)&#125;// 测试用例// let testSting = &apos;258700&apos; success// let testSting = &apos;12&apos; success// let testSting = &apos;01232&apos; fail// let testSting = &apos;2.587&apos; fail// let testSting = &apos;25827=&apos; fail 交易密码 和手机验证码 长度=6，文本0-9 1234567891011121314151617const PhoneReg = /^[0-9]&#123;6&#125;$/;let testSting = &apos;011222&apos;if (PhoneReg.test(testSting)) &#123; console.log(&apos;success&apos;)&#125;else&#123; console.error(&apos;fail&apos;)&#125;// 测试用例// let testSting = &apos;258700&apos; success// let testSting = &apos;011222&apos; success// let testSting = &apos;12&apos; fail// let testSting = &apos;12122&apos; fail// let testSting = &apos;12 122&apos; fail 检测中文1//检测中文的正则 var chineseReg = /^[u4e00-u9fa5]{0,20}$/;chineseReg.test(); 12 `]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>reg</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[sass基本语法]]></title>
    <url>%2F2018%2F05%2F08%2Fsass%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95%2F</url>
    <content type="text"><![CDATA[前言 Sass的学名叫“CSS预处理器”，就是在CSS的基础上，引入了变量、嵌套、mixin（混合）、运算以及函数等功能，增加了代码的灵活性，可以让我们以更少的代码实现同样的效果，而且代码的整洁度、可读性更强。 环境 参考 我是放在vue脚手架中操作的，不需要装，大致的语法是一样的，编译参考上文 本文是参考Sass中文网的，我只是个精简版的 Sass中文网 使用变量 变量声明用 $作为前缀12345$text-Size = 30px;$plain-font: &quot;Myriad Pro&quot;、Myriad、&quot;Helvetica Neue&quot;、Helvetica、&quot;Liberation Sans&quot;、Arial和sans-serif; sans-serif;$hight-color:#fff; 变量使用1234567891011121314编译前: $h1-Size:36px; $plain-font: &quot;Myriad Pro&quot;,Myriad,&quot;Helvetica Neue&quot;,Helvetica,&quot;Liberation Sans&quot;,Arial和sans-serif,sans-serif; $h1-color:#f99; h1&#123; font-size: $h1-Size; font-family: $plain-font; color: $h1-color; &#125;编译后:font-size: 36px;font-family: &quot;Myriad Pro&quot;, Myriad, &quot;Helvetica Neue&quot;, Helvetica, &quot;Liberation Sans&quot;, Arial和sans-serif, sans-serif;color: #f99; 可能看起来代码量反而增多了，但是在写大型项目的时候会让我们加快速度编码 $link-color与$ink_color指向的是同一变量，使用时小心 嵌套规则 大家肯定经历过这种事情 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475.container h1&#123;&#125; .container a&#123;&#125; .container img&#123;&#125; .container span&#123;&#125; .container div&#123;&#125;//需要重复写同一个选择器sass的嵌套可以避免这种情况 $box-size:600px; // $box-background:$h1-color-125; //颜色可以进行加减乘除 但是变量一定要先声明在使用啊 $h1-Size:36px; $plain-font: &quot;Myriad Pro&quot;,Myriad,&quot;Helvetica Neue&quot;,Helvetica,&quot;Liberation Sans&quot;,Arial和sans-serif,sans-serif; $h1-color:#f99; $h1_color:#99d; $box-background:$h1-color - 100; #container&#123; background: $box-background; height: $box-size; width: $box-size; margin: 0 auto; h1&#123; font-size: $h1-Size; font-family: $plain-font; color: $h1-color; text-align: center; &#125; ul&#123; font-size: 24px; text-align: center; &amp; &gt; li&#123; //&amp;表示父级元素 最靠近他的那个 color: #fff; a&#123; text-decoration: underline;&amp;:hover&#123;color:#f999;text-decoration:none;&#125; &#125; &#125; &#125; &#125;群组选择器的嵌套#container&#123;div,span.ul&#123;color:#f88;&#125;&#125;这种嵌套不要超过三层，不然降低网站的浏览速度配合 &gt; + ~ 三种选择器article &#123;~artlice &#123;color:#f99&#125;&gt; section &#123;background:#f00;&#125;dl &gt; &#123;dt&#123;color:#f99&#125;&#125;&#125;嵌套属性 nav &#123;border: &#123;style:solid;width:1px;color:#9ff;&#125;&#125;&amp; 表示 父级元素也可以这样用编译前#main &#123; color: black; &amp;-sidebar &#123; border: 1px solid; &#125;&#125;编译后#main &#123; color: black; &#125; #main-sidebar &#123; border: 1px solid; &#125; 导入sass文件 当我们不需要把导入的文件生成一个单独的css时，我们仅需在在文件名前面加一个_ @import ‘/sass/_sigle.css’ //这就会将内容导出到这个引用的地方 被导入文件的名字以.css结尾； 被导入文件的名字是一个URL地址（例如http://www.sass.hk/css/css.css ），由此可用谷歌字体API提供的相应服务； 被导入文件的名字是CSS的url()值。 设置默认值 加 !default 当多个文件导入，有重名的变量时，保证引用的时重新定义过的，如果没有重新定义则使用预先定义好的默认值 1234$ defalut-color:red !default;.box&#123;color:$ defalut-color;&#125; ####嵌入导入 你的局部sass文件在哪里被引用，就会导出到那个地方 123aside&#123;div&#123;@import &apos;_div.css&apos;&#125; //css被导入了，很强大呀&#125; 注释12345678910/*! 我是强力注释 我会出现在css文件里面*/div&#123;color:#f09; // 我不会出现在css里面font-size:36px; /*我也不会*/&#125;插值语句用于注释$version: &quot;1.2.3&quot;;/* This CSS is generated by My Snazzy Framework version #&#123;$version&#125;. */编译后/* This CSS is generated by My Snazzy Framework version 1.2.3. */ 混合器 当一组css在多个地方使用时，可以使用这种方式 先定义一个混合器 @mixin 12345678@mixin imgradius&#123; display: inline; text-align: center; width: 120px; height: 120px; border-radius: 24px;&#125; 使用 @include123img&#123; @include imgradius; &#125; 给混合器传参数1234567891011121314定义下 @mixin li-style($type,$position)&#123; list-style-type:$type; list-style-position:$position; &#125;使用下li:first-child&#123; @include li-style(circle,inside) &#125; li:last-child&#123; @include li-style(square,inside) &#125; 可以指定默认参数12345678@mixin li-style($type:decimal,$position:inside)&#123; list-style-type:$type; list-style-position:$position; &#125; li:last-child&#123; @include li-style(); &#125; 选择器继承 @extend123456789.biaoti&#123; font-size: $h1-Size; font-family: $plain-font; color: $h1-color; &#125;h1 &#123; @extend .biaoti; &#125; 颜色函数123456789101112131415$box-color: red; ul &#123; color: $box-color; &#125;li &#123; background-color: darken($box-color,30%); &#125;//编译后：ul &#123; color: red;&#125;li &#123; background-color: #660000;&#125; 另外几种颜色函数123lighten(#cc3, 10%) // #d6d65cgrayscale(#cc3) // #808080complement(#cc3) // #33c 数据类型 (Data Types) 数字，1, 2, 13, 10px字符串，有引号字符串与无引号字符串，”foo”, ‘bar’, bazSassScript 支持 CSS 的两种字符串类型：有引号字符串 (quoted strings)，如 “Lucida Grande” ‘http://sass-lang.com&#39;；与无引号字符串 (unquoted strings)，如 sans-serif bold，在编译 CSS 文件时不会改变其类型。只有一种情况例外，使用 #{} (interpolation) 时，有引号字符串将被编译为无引号字符串，这样便于在 mixin 中引用选择器名1234567891011@mixin firefox-message($selector) &#123; body.firefox #&#123;$selector&#125;:before &#123; content: &quot;Hi, Firefox users!&quot;; &#125;&#125;@include firefox-message(&quot;.header&quot;);编译后body.firefox .header:before &#123; content: &quot;Hi, Firefox users!&quot;; &#125; 颜色，blue, #04a3f9, rgba(255,0,0,0.5)布尔型，true, false空值，null数组 (list)，用空格或逗号作分隔符，1.5em 1em 0 2em, Helvetica, Arial, sans-serifmaps, 相当于 JavaScript 的 object，(key1: value1, key2: value2) 运算 支持数字算数，支持关系运算 / 除法是特例，通常在这几种种情况下展现如果值，或值的一部分，是变量或者函数的返回值如果值被圆括号包裹如果值是算数表达式的一部分1234567891011121314151617181920212223242526272829303132333435p &#123; font: 10px/8px; // Plain CSS, no division $width: 1000px; width: $width/2; // Uses a variable, does division width: round(1.5)/2; // Uses a function, does division height: (500px/2); // Uses parentheses, does division margin-left: 5px + 8px/2px; // Uses +, does division&#125;编译后p &#123; font: 10px/8px; width: 500px; height: 250px; margin-left: 9px; &#125;保证变量不做除法运算的方法p &#123; $font-size: 12px; $line-height: 30px; font: #&#123;$font-size&#125;/#&#123;$line-height&#125;;&#125;编译后p &#123; font: 12px/30px; &#125;加号链接符的秘密如果有引号字符串（位于 + 左侧）连接无引号字符串，运算结果是有引号的，相反，无引号字符串（位于 + 左侧）连接有引号字符串，运算结果则没有引号。p:before &#123; content: &quot;Foo &quot; + Bar; font-family: sans- + &quot;serif&quot;;&#125;编译为p:before &#123; content: &quot;Foo Bar&quot;; font-family: sans-serif; &#125; 小结 https://www.sass.hk/docs/#t7-3-6 这是比较齐全的地址 仅供学习之用。]]></content>
      <tags>
        <tag>sass</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ife-笔记1]]></title>
    <url>%2F2018%2F04%2F26%2Fife-%E7%AC%94%E8%AE%B01%2F</url>
    <content type="text"><![CDATA[如何理解web语义化 语义化通俗来讲就是见名知意了，对于机器也是如此,html有很多看名字就知道内容的标签，比如标题h1~h6,段落标签 p ,表格table ，表单form等，它有助于seo，对爬虫来说，也是一件非常好的事情。对我们来说，当缺少css时，它也是一个结构完整，内容清晰的页面。顾大佬的文章提到了AI,现在人工智能飞速发展的时代,让一切内容和包括对关系的描述都成为 Web 上的资源，都可以由唯一的 URI 定义，语义明确、机器可读对于发展人工智能应该有极大的帮助。当然对于我们前端开发者来说，语义化可以让我们对页面整体结构把握更好，同时让一些视听障碍者，也能享受到浏览网页的乐趣,html5对于语语义化更是支持的非常完善,新的规章都出来了，我们怎么能不投入语义化的怀抱，使我们的网页更加健壮。 一些小题 HTML是什么，HTML5是什么 HTML 是用来描述网页的一种语言,超文本标记语言(Hyper Text Markup Language)，不是编程语言,仅仅是标记语言 html5是html的扩展，新增了许多语义化标签，增加了一些新特性 如canvas 媒体播放 radio video，离线存储，新的表单控件等 HTML元素标签、属性都是什么概念？ HTML元素标签就是由以开始标签起始，以结束标签终止。中间是元素的内容,不同的标签具有不同的特性属性是标签元素附带的，且总是以名称/值对的形式出现 文档类型是什么概念，起什么作用？ 文档类型是指浏览器用什么样的规则去解析html,由于历史原因,不使用文档类型的html采用的是混杂模式,使用了的采用的是最新的标准模式,主要是为了兼容老版本的浏览器，同时可以用新的规则进行解析 meta标签都用来做什么的？ meta是一个辅助性的标签，我们可以在里面定义作者,设定页面格式，标注内容提要和关键字；还可以设置页面使其可以根据你定义的时间间隔刷新自己,以及设置RASC内容等级等等，好的meta定义有利于seo的优化，通常不展示在页面里面，爬虫可见 Web语义化是什么，是为了解决什么问题 eb语义化是指使用语义恰当的标签,使页面有良好的结构,能够让人和搜索引擎都容易理解，利于seo优化 链接是什么概念，对应什么标签？ 链接就是一个可以跳转的地址,对应的是a标签 href属性用来定义跳转的地址 常用标签都有哪些，都适合用在什么场景 h1~h6 标题 类似word里面的标题 p 段落 写文章可以用 b i u 文字样式标签 from input 表单标签 table tr td 表格标签 img 图像 h5标签 header nav article aside main section footer figcaption figure 文档结构标签 a 跳转链接 等等 表单标签都有哪些，对应着什么功能，都有哪些属性 标签 form input button fieldset legend form 属性: action(定义在提交表单时执行的动作) method( 属性规定在提交表单时所用的 HTTP 方法（GET 或 POST) input 属性 type(定义输入框类型) name(正确地被提交,每个输入字段必须设置一个 name 属性) ol, ul, li, dl, dd, dt等这些标签都适合用在什么地方，举个例子 ol 是有序列表 适合用在列举一些东西 ul 是无序的列表，用于堆叠一些观点 li 是以上两者的条数,一个li代表一条观点啥的 dl dd dt 可以用作分类 dt 定义列表中的项目 dd 描述列表中的项目]]></content>
      <tags>
        <tag>ife</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[越努力，越幸运]]></title>
    <url>%2F2018%2F04%2F24%2F%E8%B6%8A%E5%8A%AA%E5%8A%9B%EF%BC%8C%E8%B6%8A%E5%B9%B8%E8%BF%90%2F</url>
    <content type="text"><![CDATA[前言虽然在前端这个领域已经工作一年依然觉得自己还是个菜鸟级别，刚开始学习前端很有动力，毕竟当时前端很火，高薪就业啥的，同时面临着毕业的压力，从html+css+js疯狂的学习，现在的很感谢当时打下的基础。写公司的业务代码基本能没啥问题，但是感觉自己也变迷茫了，已经工作一年了，水平也开始止步不前，没有很好的天赋，前端的东西也是铺天盖地，无从下手。现在正好趁这个机会系统的学习一下前端，摸清前端的知识体系，小伙伴们一起加油吧。 言归正传 今天是2018.04.24 工作原因只有晚上有时间花了半个小时看了下第一课的一些特效网站，看完觉得压力蛮大的，前端居然能做出这么厉害的特效，感觉我的学的animate动画基础，让它们在业务上完成简单的动效简直low爆了，对于这些东西感觉我就是小白一枚。 进一步阅读了祖大大推荐的几篇文章，尤其是这篇-Web 建站技术中，HTML、HTML5、XHTML、CSS、SQL、JavaScript、PHP、ASP.NET、Web Services 是什么？，基本涵盖了前后端的所有基本理解，其实在一年的工作中，我明白了我们不仅仅要对自己所掌握的前端方面要精通，还要不断的扩展的一些后段知识，这样整个流程我们就能很清楚明白，工作起来就很得心应手，懂一些后端的东西对于前后端联调还是很有帮助的。 对于其他三篇文章，基本是我们入坑必看的了，MDN上的东西基本包含了前端所有的东西，最新的es6语法也有详解，最有爱的是有中文，对于我来说是比较开心的，有些东西都是可以在这里查到，最后分享几个我常用的网站吧。 https://tinypng.com/ 图片压缩的网站，压缩率蛮高的 https://caniuse.com/ 查询一些css，js 语法的支持程度的网站 http://www.bootcdn.cn/ 一些免费前端开源的cdn加速的服务 http://tool.chinaz.com/Tools/unixtime.aspx 一些转换的工具 如字符编码的转换 时间戳等 https://hexo.io/zh-cn/docs/ 可以在github上搭建博客的静态资源生成器，写写blog啥的 结尾哇，零点了，明天还要上班，就这么多了，希望前端之路，大家越走越远。毕竟前端如此美妙，值得你入坑。]]></content>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[es6-函数]]></title>
    <url>%2F2018%2F04%2F06%2Fes6-%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[前言 杭州这周温度达到-5度了，温度下降的蛮快，年会排舞感觉好悬啊，不知到能拍出啥道道来,现在唯一的心愿就是，早点回家，冷也阻止不了我回家的脚步，嗯哼。 我的博客地址 ：http://www.aymfx.cn/ 引子 ES6函数的改变不算太大，都是一些其他语言早就有的功能，而Javascript一直比较欠缺的，比如函数参数默认值，任意参数的表示法，最大的变化应该是支持箭头函数(其他语言称之为LAMBDA表达式)，一种对匿名函数的一种简写方式 函数形参的默认值 es5 模拟默认参数 123456789function sendAjax(url,timeout,callback)&#123; timeout = timeout || 2000; callback = callback || $.noop(); //默认参数 $.ajax(url).done(function()&#123; setTimeout(callback,timeout) &#125;) &#125; 上面的赋值操作会存在问题，你懂的，所以引入了es6的默认参数 1234567891011function add(a=200,b=2)&#123; return a+b;&#125;console.log(add()); //202console.log(add(2)); //4console.log(add(null,2)); //2 null是合法值 被当成0console.log(add(undefined,2)); //202 默认参数对arguments对象的影响 非严格模式下 12345678910111213141516function temp(first,second)&#123; console.log(first=== arguments[0]); console.log(second=== arguments[1]); first = &apos;c&apos;; second = &apos;d&apos; console.log(first=== arguments[0]); console.log(second=== arguments[1]);&#125;temp(&apos;a&apos;,&apos;b&apos;)//true//VM264:3 true//VM264:6 true//VM264:7 true 严格模式下 1234567891011121314151617function temp(first,second)&#123; &apos;use strict&apos; console.log(first=== arguments[0]); console.log(second=== arguments[1]); first = &apos;c&apos;; second = &apos;d&apos; console.log(first=== arguments[0]); console.log(second=== arguments[1]);&#125;temp(&apos;a&apos;,&apos;b&apos;)//true//VM264:3 true//VM264:6 false//VM264:7 false 非严格模式下，参数与argument的值保持一致,严格模式下arguments与传进来的初始参数保持一致，看看es6默认值存在的话 非严格模式下 1234567891011121314151617function temp(first,second=&apos;b&apos;)&#123; console.log(arguments.length) console.log(first=== arguments[0]); console.log(second=== arguments[1]); first = &apos;c&apos;; second = &apos;b&apos; console.log(first=== arguments[0]); console.log(second=== arguments[1]);&#125;temp(&apos;a&apos;)//1//true//VM264:3 false//VM264:6 false//VM264:7 false 严格模式下 12345678910111213141516function temp(first,second=&apos;b&apos;)&#123; &apos;use strict&apos; console.log(arguments.length) console.log(first=== arguments[0]); console.log(second=== arguments[1]); first = &apos;c&apos;; second = &apos;d&apos; console.log(first=== arguments[0]); console.log(second=== arguments[1]);&#125;temp(&apos;a&apos;)// Illegal &apos;use strict&apos; directive in function with non-simple parameter list//hhhhhhhhhhhh,不能用，尴尬 默认参数表达式,可以传函数1234567891011function getValue()&#123; return 5;&#125;function add(first,second=getValue())&#123; return first+second;&#125;console.log(add(1,2)); //3console.log(add(10)); //15 可以将先前定义好的形参当默认值 123456789101112131415161718function add(first,second=first)&#123; return first+second;&#125;console.log(add(1,2)); //3console.log(add(10)); //20反之不行哈function add(first=second,second)&#123; return first+second;&#125;console.log(add(1,2)); //3console.log(add(undefined,10)); //second is not defined//这就是所谓的临时死区TDZ，未初始化之前不可被引用 不定参数 （…keys）12345678910111213141516171819//模仿Underscore.js pick()方法function pick(object,...keys)&#123; console.log(arguments.length); //3 let result = Object.create(null); for(let i=0,len=keys.length;i&lt;len;i++)&#123; result[keys[i]]= object[keys[i]] &#125; return result; &#125;let person = pick(&#123;name:&apos;ly&apos;,age:&apos;18&apos;,sex:&apos;mael&apos;&#125;,&apos;age&apos;,&apos;sex&apos;); console.log(person.name); //undefindconsole.log(person.age); //18console.log(person.sex); //mael 不定参数的要求 123456789function pick(obj,...keys,last)&#123;&#125; //报错，不定参数必须放在最后后面//不定参数不能用于对象字面量setter之中let object = &#123; set name(...values)&#123; //执行逻辑 &#125;&#125; Function 构造函数功能增强 可以使用默认参数和不定参数12345678const add = new Function(&apos;first&apos;,&apos;second = first&apos;,&apos;return first+second&apos;)console.log(add(1,2),add(1)) //3 2var pick = new Function(&quot;...args&quot;,&quot;return args[0]&quot;)console.log(pick(1,2)); //1 展开运算符12345678910111213//之前求最大值的时候let values = [25,100,75,56];console.log(Math.max.apply(this,values)); //100//有点麻烦，但是用展开运算符的话console.log(Math.max(...values)); //100//开不开心，我们可以拿其他值和数组值比较console.log(Math.max(...values,200)); //200 函数中可以获取函数名称的的属性 name123456789101112131415161718192021222324252627var func1 = function () &#123;&#125;;// ES5func1.name // &quot;&quot;// ES6func1.name // &quot;func1&quot;//上面代码中，变量func1等于一个匿名函数， ES5 和 ES6 的name属性返回的值不一样。//如果将一个具名函数赋值给一个变量，则 ES5 和 ES6 的name属性都返回这个具名函数原本的名字。const bar = function baz() &#123;&#125;;// ES5bar.name // &quot;baz&quot;// ES6bar.name // &quot;baz&quot;//Function构造函数返回的函数实例，name属性的值为 “anonymous” 。(new Function).name // &quot;anonymous&quot;//bind返回的函数，name属性值会加上 “bound ” 前缀。function foo() &#123;&#125;;foo.bind(&#123;&#125;).name // &quot;bound foo&quot;(function()&#123;&#125;).bind(&#123;&#125;).name // &quot;bound &quot;//还有几个es6的情况var dosomething = function()&#123;&#125;console.log(dosomething.bind().name); //bound dosomethingconsole.log((new Function()).name); //anonymous 明确函数的多重用途 js函数有两种内部方式 [[Call]]和[[Construct]],当通过new关键字调用函数时，执行的是[[Construct]]函数,他负责创建一个通常被称作实例的新对象，然后再执行函数体,将this绑定到实例上;如果不同过new则执行[[Call]]函数,从而直接执行代码中的函数体 es5判断函数被调用的方法1234567891011121314function Person(name)&#123; if(this instanceof Person)&#123; this.name = name; &#125; else&#123; throw new Error(&apos;必须new才行，嘿嘿&apos;) &#125;&#125;var person = new Person(&quot;ly&quot;); //var notperson =Person(&quot;ll&quot;); // 必须new才行，嘿嘿//但是可以蒙混过关var notperson =Person.call(peson,&quot;ll&quot;); // new.target 精准判断12345678910function Person(name)&#123; if(typeof new.target !== &apos;undefined&apos;)&#123; this.name = name; &#125; else&#123; throw new Error(&apos;必须new才行，嘿嘿&apos;) &#125;&#125;var person = new Person(&quot;ly&quot;); //var notperson =Person.call(person,&quot;ll&quot;); // 块级作用域 在es5的时代，当启用严格模式时，下列代码会报错,es6则不会,因为产生了块级作用域，该函数可以在这个if条件语句内部使用，外部依旧是undefined 123456789&quot;use strict&quot;if(true)&#123; console.log(typeof add); //function function add(a,b)&#123; return a+b; &#125;&#125;console.log(typeof add); //undefined 但是在非严格模式下，该函数还是会被提升到全局作用域顶部 12345678if(true)&#123; console.log(typeof add); //function function add(a,b)&#123; return a+b; &#125;&#125;console.log(typeof add); //function 重要改变 箭头函数 一些好玩的改变（兴奋状） 没有this,spuer,arguments和new.target绑定 不能通过new关键字调用 没有原型 不可以改变this的绑定 不支持arguments对象 不支持重复的命名参数 箭头函数的语法12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758let add = (a,b) =&gt; a+b;//实际类似于let add = function(a,b)&#123;return a+b&#125;//当箭头函数只有一个参数时，不需要括号let reflrct = value =&gt; value//类似于let reflrct = function(value)&#123;return value&#125;//不写参数时要加括号let name = () =&gt; &apos;ly&apos;;//类似于let name = function()&#123;return &apos;ly&apos;&#125;//如果需要写复杂的函数体，则必须这样写let getName = (fisrtName,secondName) =&gt; &#123; return firstName+&apos; &apos;+ secondName;&#125;//类似于let getName = function(fisrtName,secondName)&#123; return firstName+&apos; &apos;+ secondName;&#125;//如果想反回一个字面量对象则需要这样写let person = () =&gt; (&#123; name:&apos;ly&apos;, age:18&#125;)//类似于let person = function()&#123; return &#123; name:&apos;ly&apos;, age:18&#125;&#125;//创建一个立即表达函数let person = ((name) =&gt; (&#123;getName:() =&gt; name&#125;))(&apos;ly&apos;)//自己还原下看看，嘿嘿 箭头函数没有this绑定1234567891011let PageHandler = &#123; id:&apos;13579&apos;, init:function()&#123; document.addEventListener(&apos;click&apos;,function(event)&#123; this.doSomething(event.type) //会报错 &#125;) &#125;, doSomething:function(type)&#123; console.log(type); &#125;&#125; es5的做法，将会这么做 1234567891011let PageHandler = &#123; id:&apos;13579&apos;, init:function()&#123; document.addEventListener(&apos;click&apos;,(function(event)&#123; this.doSomething(event.type) &#125;).bind(this)) &#125;, doSomething:function(type)&#123; console.log(type); &#125;&#125; 但是有了箭头函数的话，就帅多了 12345678910let PageHandler = &#123; id:&apos;13579&apos;, init:function()&#123; document.addEventListener(&apos;click&apos;,event =&gt; this.doSomething(event.type) ) &#125;, doSomething:function(type)&#123; console.log(type); &#125;&#125; 因为箭头函数是没有this的,所以在处理的过程中，它里面的this取决函数外部非箭头函数的this值 箭头函数不存在arguments绑定所以可以这么操作1234567function outer()&#123; return () =&gt; arguments[0];&#125;let inner = outer(18) console.log(inner()); //18 就是这么骚气，直接访问箭头函数体外函数的arguments call(),bind(),apply() 都是可以用的，但是改变不了this的值的哈 尾调用的优化(Tail Call) 尾调用指的是函数做为另一个函数最后一条语句被调用,它不会在调用栈上增加新的堆栈帧，而是直接更新调用栈，调用栈所占空间始终是常量，节省了内存，避免了爆栈的可能性,但是es5存在调用栈变得过大则会造成程序问题 尾调用实例 1234567891011function add(a,b)&#123; &#125;function max(a,b,c,d)&#123; //...... return add(a,c); &#125; 优化需要满足以下条件,尾调用才不会创建新栈帧,而是清除并重用当前栈帧 尾调用不访问当前栈的变量(不形成闭包) 尾调用是函数内部的最后一句 尾调用的结果将作为函数值返回 (必须有return fn()) 使用场景 尾递归 错误方式 1234567891011console.time(&apos;testForEach&apos;);function factorial(n) &#123; if(n&lt;=1)&#123; return 1 &#125; else &#123; return n*factorial(n-1) //如果n很大，在不断递归的情况下，会栈溢出，这也不是尾递归 &#125;&#125;var a =factorial(5000);console.log(a); console.timeEnd(&apos;testForEach&apos;); // 1.55322265625ms 正确写法 1234567891011console.time(&apos;testForEach&apos;);function factorial(n,p=1) &#123; if(n&lt;=1)&#123; return 1*p; &#125; else &#123; let result = p*n; return factorial(n-1,result) &#125;&#125;factorial(5000);console.timeEnd(&apos;testForEach&apos;); //0.492919921875ms 测 了10000 居然栈溢出 搞不懂]]></content>
      <tags>
        <tag>es6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[es6-Symbol]]></title>
    <url>%2F2018%2F04%2F04%2Fes6-Symbol%2F</url>
    <content type="text"><![CDATA[前言 突然就断网了，hhhh 我的博客地址 ：http://www.aymfx.cn/ symbo 这是新的原始类型，一般是用于非字符串属性名称，利用其特性创建私有的变量 123456var firstname = Symbol(), person = &#123;&#125;; person[firstname] = &quot;ly&quot;;console.log(person[firstname]); //ly 添加描述 123456789var firstname = Symbol(&apos;liuyang&apos;), person = &#123;&#125;; person[firstname] = &quot;ly&quot;;console.log(&apos;liuyang&apos; in person); //falseconsole.log(person[firstname]); //lyconsole.log(firstname) //Symbol(liuyang) 可以通过typeof来识别 123let symbol = Symbol(&quot;test&quot;);console.log(typeof symbol) //symbol Symbol使用方式 可用于计算对象字面量属性名，Object.defineProperty()方法和Object.defineProperties()方法的调用过程中 12345678910111213141516171819202122let firstname = Symbol(&quot;first name&quot;)//可用于计算对象字面量属性名let person = &#123; [firstname]:&apos;nicholas&apos;&#125;//将属性设置为只读Object.defineProperty(person,firstname,&#123;writeable:false&#125;);let lastName = Symbol(&apos;last name&apos;);Object.defineProperties(person,&#123; [lastName]:&#123; value:&apos;zhaosi&apos;, writeable:false &#125;&#125;)console.log(person[firstname],person[lastName]); //nicholas zhaosi Symbol共享体系 当你的应用有两种不同的对象类型，但是你希望他们共享一个Symbol,你可以使用Symbol注册表，通过for方法来操作 123456789101112131415161718192021222324252627let uid = Symbol.for(&apos;i am Object property&apos;);let obj1 = &#123; [uid] :&apos;ly&apos;&#125;let uid2 = Symbol.for(&apos;i am Object property&apos;);let obj2 = &#123; [uid2] : &apos;i am Object property&apos;&#125;console.log(uid===uid2); trueconsole.log(obj1[uid],obj2[uid2]); ly i am Object propertyconsole.log(uid2) Symbol(i am Object property)//通过Symbol.keyFor(),来查找Symbol的键console.log(Symbol.keyFor(uid),Symbol.keyFor(uid2)) //i am Object property i am Object propertylet uid3 = Symbol(&apos;uid3&apos;)console.log(Symbol.keyFor(uid3)) //undefined ,因为没使用for方法进行注册 Symbol的类型强制转换 似乎Symbol不能与其他的类型发生强制转换的操作，我们只能用String惊醒字符串的输出 1234567891011121314151617181920212223242526let uid = Symbol(&apos;useful message&apos;), desc = String(uid);console.log(desc); //Symbol(useful message)//不能进行字符串的拼接let uid = Symbol(&apos;useful message&apos;);let string = uid+&apos;!&apos; //报错 Cannot convert a Symbol value to a string//不能进行运算let uid = Symbol(&apos;useful message&apos;);let string = uid/1; //Cannot convert a Symbol value to a number//逻辑操作符可以,等价为布尔值truelet uid = Symbol(&apos;useful message&apos;);let s = uid ? &apos;对的&apos;: &apos;错的&apos;;console.log(s) //对的 Symbol的检索属性 Object.keys()方法，将会返回的是可枚举的属性名,Object.getOwnPropertyNames()方法将会枚举的可举性，将会全部返回,但是他们不支持枚举Symbol属性,es6提供了Object.getOwnPropertySymbols()方法枚举包含的Symbol的自有属性数组 12345678910111213let uid = Symbol(&apos;a&apos;), uid2 = Symbol(&apos;a2&apos;), object = &#123; [uid]:&apos;12345&apos;, [uid2]:&apos;35487&apos;, &apos;hh&apos;:&quot;我应该排除在外的&quot; &#125;;let symbols = Object.getOwnPropertySymbols(object); console.log(symbols); // [Symbol(a), Symbol(a2)]console.log(symbols[0]);// Symbol(a)console.log(object[symbols[0]]); //12345 通过 well-known Symbol 暴露内部操作 除了自己创建的symbol，JavaScript还内建了一些在ECMAScript 5 之前没有暴露给开发者的symbol，它们代表了内部语言行为。它们可以使用以下属性访问： 迭代 symbols Symbol.iterator 一个返回一个对象默认迭代器的方法。使用 for…of。 Symbol.asyncIterator 一个返回对象默认的异步迭代器的方法。使用 for await of。 正则表达式 symbols Symbol.match 一个用于对字符串进行匹配的方法，也用于确定一个对象是否可以作为正则表达式使用。使用 String.prototype.match(). Symbol.replace 一个替换匹配字符串的子串的方法. 使用 String.prototype.replace(). Symbol.search 一个返回一个字符串中与正则表达式相匹配的索引的方法。使用String.prototype.search(). Symbol.split 一个在匹配正则表达式的索引处拆分一个字符串的方法.。使用 String.prototype.split(). 其他 symbols Symbol.hasInstance 一个确定一个构造器对象识别的对象是否为它的实例的方法。使用instanceof. Symbol.isConcatSpreadable 一个布尔值，表明一个对象是否应该flattened为它的数组元素。使用Array.prototype.concat(). Symbol.unscopables 拥有和继承属性名的一个对象的值被排除在与环境绑定的相关对象外。 Symbol.species 一个用于创建派生对象的构造器函数。 Symbol.toPrimitive 一个将对象转化为基本数据类型的方法。 Symbol.toStringTag 用于对象的默认描述的字符串值。使用Object.prototype.toString(). Symbol.hasInstance方法 一个确定一个构造器对象识别的对象是否为它的实例的方法 123456obj = new Array();console.log(obj instanceof Array); //trueconsole.log(Array[Symbol.hasInstance](obj)) //VM187:5 true 我可以用它定义一个无实例的函数 1234567891011121314function myObject ()&#123; &#125;Object.defineProperty(myObject,Symbol.hasInstance,&#123; value:function(v)&#123; return false &#125;&#125;)let obj = new myObject();console.log(obj instanceof myObject); //false 我们可以定制自己的实例，通过这种方式，可以修改内建对象但是尽量不要这么做，应该修改自己创建的构造函数 Symbol.isConcatSpreadable属性 Symbol.isConcatSpreadable属性是一个布尔值，如果属性为true，则表示对象有length属性和数字键,这样它就可以使用数组的concat()方法了 12345678910111213141516171819202122let obj = &#123; 0:&apos;a&apos;, 1:&apos;b&apos;, length:2, [Symbol.isConcatSpreadable]:true&#125;let obj2 = &#123; 1:&apos;a&apos;, s:&apos;b&apos;, length:2, [Symbol.isConcatSpreadable]:true&#125;let message = [&apos;hi&apos;].concat(obj);console.log(message);let message2 = [&apos;hi&apos;].concat(obj2);console.log(message2); 说明他会寻找数字下标，找不到就设置为空，并且从零开始 Symbol.match,Symbol.replace,Symbol.search,Symbol.split match() match() 方法可在字符串内检索指定的值，或找到一个或多个正则表达式的匹配。 replace() replace() 方法用于在字符串中用一些字符替换另一些字符，或替换一个与正则表达式匹配的子串。 split() 用于把一个字符串分割成字符串数组 search() 用于检索字符串中指定的子字符串，或检索与正则表达式相匹配的子字符串。 以上方法时es5d的正则表达式的字符串匹配，但是无法使用自定义的对象来替代正则表达式进行正则匹配，es6这些方法就可以这么操作，我们来看他们的定义 Symbol.match 接受一个字符串的参数，如果匹配成功则返回匹配成功的数组，否则返回null Symbol.replace 接受一个字符串类型的参数和一个替换字符串，最终返回一个字符串 Symbol.search 接受一个字符串参数，如果匹配到内容，就返回数组的位置，否则返回-1 Symbol.split 接受一个字符串参数，根据内容匹配将字符串分解，并将返回分解后的数组 看看栗子 123456789101112131415161718192021222324252627282930let hasLengthOf10 = &#123; [Symbol.match]:function(value) &#123; return value.length === 10 ? [value]:null &#125;, [Symbol.replace]:function(value, replace) &#123; return value.length === 10 ? replace:value &#125;, [Symbol.search]:function(value) &#123; return value.length === 10 ? 0:-1 &#125;, [Symbol.split]:function(value) &#123; return value.length === 10 ? [ , ]:[value] &#125;&#125;let m1 = &apos;Hello world&apos; //11let m2 = &apos;Hello john&apos; //10 console.log(m1.replace(hasLengthOf10)); //[empty]console.log(m2.replace(hasLengthOf10)); //undefinedconsole.log(m1.match(hasLengthOf10));//nullconsole.log(m2.match(hasLengthOf10));//[&quot;Hello john&quot;]console.log(m1.search(hasLengthOf10)); //-1console.log(m2.search(hasLengthOf10)); //0console.log(m1.split(hasLengthOf10));[&quot;Hello world&quot;]console.log(m2.split(hasLengthOf10)); //[empty] Symbol.toPrimitive 指将被调用的指定函数值的属性转换为相对应的原始值 在 Symbol.toPrimitive 属性(用作函数值)的帮助下，一个对象可被转换为原始值。该函数由字符串参数 hint 调用，目的是指定原始值转换结果的首选类型。 hint 参数可以是”number”、”string” 和 “default” 中的一种。 123456789101112131415161718192021222324//话不多说看栗子function Temp(degress)&#123; this.degress = degress&#125;Temp.prototype[Symbol.toPrimitive] = function(hint)&#123; switch(hint)&#123; case &quot;string&quot;: return this.degress +&quot;\u00b0&quot;; //degress symbol case &quot;number&quot;: return this.degress; case &quot;default&quot; : return this.degress+&apos;ly&apos; &#125;&#125;var t = new Temp(8);console.log(t+&apos;5555&apos;) //8ly5555console.log(t/&apos;2&apos;) //4console.log(String(t)) //8° Symbol.toStringTag Symbol.toStringTag 是一个内置 symbol，它通常作为对象的属性键使用，对应的属性值应该为字符串类型，这个字符串用来表示该对象的自定义类型标签，通常只有内置的 Object.prototype.toString() 方法会去读取这个标签并把它包含在自己的返回值里。 我们识别数组还是对象，一般习惯用 toString方法来实现，例如 123function isArray(arr)&#123; return Object.prototype.toString.call(arr) === &apos;[object Array]&apos;&#125; 现在我们可以重写一个对象的类型 123456789function Person(name)&#123; this.name =name;&#125;Person.prototype[Symbol.toStringTag] = &apos;Person&apos;;let people = new Person(&apos;ly&apos;);console.log(Object.prototype.toString.call(people)); //[object Person] Symbol.unscopables 指用于指定对象值，其对象自身和继承的从关联对象的 with 环境绑定中排除的属性名称。 可以在任何对象上定义 @@unscopables symbol (Symbol.unscopables)，用于排除属性名称并与 with 环境绑定在一起作为词法变量公开。 请注意，如果使用 Strict mode，语句将不可用，并且可能也不需要 symbol。 在 unscopables 对象上设置属性为 true，将使其 unscopable 并且因此该属性也将不会在词法环境变量中出现。 如果设置属性为 false ，则将使其可 scopable 并且该属性会出现在词法环境变量中。 1234567891011121314151617181920212223242526我们在使用with时，如果用了对象属性作为变量则会报错，例如(es6数组存在values方法)let values = [1,2],colors=[&apos;w&apos;, &apos;y&apos;, &apos;k&apos;, &apos;o&apos;, &apos;p&apos;],color=&apos;blue&apos;;console.log(colors.values()); with(colors)&#123; push(color) push(...values) console.log(values);&#125;console.log(colors); //[&quot;red&quot;, &quot;blue&quot;, 1, 2] //emmmm,没报错的原因values()方法还没加上去//报错了就用这种方式,他是将词法排除在这个with环境中Array.prototype[Symbol.unscopables] = Object.assign(Object.create(null),&#123; copyWith:true, entries:true, fill:true, find:true, findIndex:true, keys:true, values:&apos;true&apos; &#125;)]]></content>
  </entry>
  <entry>
    <title><![CDATA[es6-Set集合与Map集合]]></title>
    <url>%2F2018%2F03%2F24%2Fes6-Set%E9%9B%86%E5%90%88%E4%B8%8EMap%E9%9B%86%E5%90%88%2F</url>
    <content type="text"><![CDATA[前言 离回家的时间越来越近了，突然觉得自己很差劲，分享一首歌，道出心声啊 我的博客地址 ：http://www.aymfx.cn/ 12345678910111213141516171819202122232425262728293031大概过去的就真的已过去偶尔想起还有几分怀念气息遇上快乐遇上心酸遇上分离生活终究得让人继续衣身太长遮住大半个身体学不会平淡幸福无从说起可到最后 原谅背叛原谅任性其实该原谅眼里的自己那年的自己讨厌的自己如今的自己风一直不停乱了旅行 残喘下去我除了祝福你没有其他目的但却害怕往事再重提大概过去的就真的已过去偶尔想起还有几分怀念气息遇上快乐遇上心酸遇上分离生活终究得让人继续衣身太长遮住大半个身体学不会平淡幸福无从说起可到最后 原谅背叛原谅任性其实该原谅眼里的自己那年的自己讨厌的自己如今的自己风一直不停乱了旅行 残喘下去我除了祝福你没有其他目的但却害怕往事再重提我安慰我自己 恨自己 伤感记忆只能用意志慢慢的去抚平冬季我除了祝福你没有其他目的我也可以带着青涩 美好回忆 Set 对象允许你存储任何类型的唯一值，无论是原始值或者是对象引用 创建Set集合并添加元素,对于字符串和数字不会发生强制转换，因此时两个值 1234567let set = new Set();set.add(5)set.add(&apos;5&apos;)console.log(set.size) //2 对象如果做属性名的话，es5中会发生这种事 123456789101112131415161718var set = Object.create(null);var obj1 = &#123;&#125;;var obj2 = &#123;&#125;;set[obj1] = &apos;foo&apos;console.log(set[obj2]) //foo 因为不能识别对象他们全部转换成这个了 [object object]let set = new Set(), key1 = &#123;&#125;, key2 = &#123;&#125;;set.add(key1)set.add(key2)console.log(set.size) //2 说明不是调用tostring方法 set是会忽略重复值的 1234567let set = new Set();set.add(5)set.add(5)set.add(&apos;5&apos;)set.add(5)console.log(set.size) //2 利用has() 检查值是否存在 清除所有元素 clear() 12345678910let set = new Set();set.add(&apos;5&apos;)set.add(&apos;6&apos;)set.add(&apos;7&apos;)console.log(set.has(&apos;5&apos;)) // trueconsole.log(set.has(5)) //falseset.clear();console.log(set.has(&apos;6&apos;)) false 移除元素 123456let set = new Set();set.add(&apos;5&apos;)set.add(&apos;6&apos;)console.log(set.has(&apos;5&apos;)) // trueset.delete(&apos;5&apos;) //falseconsole.log(set.has(&apos;5&apos;)) //false 使用Foreach循环,他和数组的方式的基本一样，我们来看看栗子，他们的不同 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647var arr = new Array(1,2,3,4), set = new Set([1,2,3,4]);let pocess = &#123; output (value,index) &#123; console.log(value,index); &#125;, arrObj (arr) &#123; arr.forEach((value,index,own) =&gt; &#123; this.output(value,index); console.log(arr === own); &#125;,this) &#125;, setObj (arr) &#123; arr.forEach((value,index,own) =&gt; &#123; this.output(value,index); console.log(arr === own); &#125;,this) &#125;&#125;pocess.arrObj(arr)pocess.setObj(set)//第一种结果VM163:0 1 0VM163:12 trueVM163:6 2 1VM163:12 trueVM163:6 3 2VM163:12 trueVM163:6 4 3VM163:12 true//第二种结果VM173: 12 1 1VM173:19 trueVM173:6 2 2VM173:19 trueVM173:6 3 3VM173:19 trueVM173:6 4 4VM173:19 true 将Set集合转换成数组，下列演示去重 123456789//第一种方式let set = new Set([1,5,58,6,7,8,9,5]), arr = [...set];console.log(arr); //[1, 5, 58, 6, 7, 8, 9]//第二种console.log(Array.from(new Set([1,5,58,6,7,8,9,5]))); // [1, 5, 58, 6, 7, 8, 9] Weak Set集合 set 是一个强引用集合，不信看栗子 123456789101112131415let set = new Set(), key = &#123;&#125;; set.add(key);console.log(set.size); //1//移除原始引用key = null;console.log(set.size); //1//重新取回引用key = [...set][0]; //&#123;&#125; 这种情况会造成内存的泄露，所以我们可以用以下的方法，弱引用的Set集合 创建Weak Set集合123456789let set = new WeakSet(), key = &#123;&#125;;//向集合set添加对象set.add(key);console.log(set.has(key)); //trueset.delete(key)console.log(set.has(key)); //false 我们试试这个 1234567891011let set = new WeakSet(), key = &#123;&#125;; set.add(key);console.log(set.has(key)); //true set.size不能用在weakset//移除原始引用key = null;console.log(set.has(key)); //false 两者的不同 WeakSet 对象中只能存放对象引用, 不能存放值, 而 Set 对象都可以. WeakSet 对象中存储的对象值都是被弱引用的, 如果没有其他的变量或属性引用这个对象值, 则这个对象值会被当成垃圾回收掉. 正因为这样, WeakSet 对象是无法被枚举的, 没有办法拿到它包含的所有元素 WeakSet 不可迭代 于是 for of foreach keys() values() 方法都没有 Map集合 Map 对象保存键值对。任何值(对象或者原始值) 都可以作为一个键或一个值。 基本用法 123456789let map = new Map(), key1 = &#123;&#125;, key2 = &#123;&#125;;map.set(&apos;name&apos;,&apos;ly&apos;)map.set(key1,&quot;ly1&quot;)map.set(key2,&apos;2&apos;)console.log(map.get(&apos;name&apos;),map.get(key1),map.get(key2)); //ly ly1 2 Map集合支持的方法 12345678910111213141516171819let map = new Map(), key1 = &#123;&#125;, key2 = &#123;&#125;;map.set(&apos;name&apos;,&apos;ly&apos;)map.set(key1,&quot;ly1&quot;)map.set(key2,&apos;2&apos;)console.log(map.size); //3console.log(map.has(key2)); //trueconsole.log(map.get(key2));2map.delete(key2)console.log(map.has(key2)); //falsemap.clear()console.log(map.has(key1)); //falseconsole.log(map.size); //0 Map集合的初始化方法,可以传一个数组，数组包含一个个子数组，子数组包含两个值，键和值 12345let map = new Map([[&quot;name&quot;,&apos;ly&apos;],[&quot;age&quot;,&apos;18&apos;]]);console.log(map.has(&apos;name&apos;)); //trueconsole.log(map.get(&apos;name&apos;)); //lyconsole.log(map.size); //2 可以使用ForEach() 123456789let map = new Map([[&quot;name&quot;,&apos;ly&apos;],[&quot;age&quot;,&apos;18&apos;]]);map.forEach((value,key,own) =&gt; &#123; console.log(value,key,own);&#125;)//ly name Map(2) &#123;&quot;name&quot; =&gt; &quot;ly&quot;, &quot;age&quot; =&gt; &quot;18&quot;&#125;18 age Map(2) &#123;&quot;name&quot; =&gt; &quot;ly&quot;, &quot;age&quot; =&gt; &quot;18&quot;&#125; WeakMap 对象是一组键/值对的集合，其中的键是弱引用的。其键必须是对象，而值可以是任意的。 适用场景 保存dom元素对象，便于销毁和创建 12345678910111213let map = new WeakMap(), ele = document.querySelector(&apos;div&apos;)[0];map.set(ele,&apos;Original&apos;);let value = map.get(&apos;ele&apos;) console.log(value); //Originalele.parentNode.removeChild(ele);ele = null; WeakMap支持的方法 123456789let key1 = &#123;&#125;, key2 = &#123;&#125;, map = new WeakMap([[key1,&apos;ly&apos;],[key2,&apos;18&apos;]]); console.log(map.has(key1)); //true console.log(map.get(key1)); //ly map.delete(key1) console.log(map.has(key1)); //false console.log(map.get(key1)); //undefined 私有对象数据 es5创建接近有私有数据的对象 12345678910111213141516var Person = (function()&#123; var privateData = &#123;&#125;, privateId = 0; function Person(name)&#123; Object.defineProperty(this,&quot;_id&quot;,&#123;value:privateId++&#125;) privateData[this._id] = &#123; name:name &#125; &#125; Person.prototype.getName = function()&#123; return privateData[this._id].name &#125; return Person&#125;()) 这种方式的弊端就是对象数据永远不会消失,而WeakUp可以处理这种情况 123456789101112let Person = (function()&#123; let privateData = new WeakMap(); function Person(name)&#123; privateData.set(this,&#123;name:name&#125;) &#125; Person.prototype.getName = function()&#123; return privateData.get(this).name &#125; return Person&#125;())]]></content>
      <tags>
        <tag>es6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[es6-迭代器和生成器]]></title>
    <url>%2F2018%2F03%2F20%2Fes6-%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%92%8C%E7%94%9F%E6%88%90%E5%99%A8%2F</url>
    <content type="text"><![CDATA[前言 从家里回来了，翻了翻书，发现es6的知识点，忘了不少，还好记了点笔记，今年需要更加努力，看着以前的同学都开始娶妻生子，买车买房，我也要努力为自己的未来考虑 我的博客地址 ：http://www.aymfx.cn/ 迭代器 一个迭代器对象 ，知道如何每次访问集合中的一项， 并跟踪该序列中的当前位置。在 JavaScript 中 迭代器是一个对象，它提供了一个next() 方法，用来返回序列中的下一项。这个方法返回包含两个属性：done和 value。 123456789101112131415161718192021222324252627//这是模仿es6迭代器的方式 function createIterator (items)&#123; var i =0; return &#123; next:function()&#123; var done = (i&gt;=items.length); var value = !done ? items[i++]:undefined; return &#123; done:done, value:value &#125; &#125; &#125; &#125; var iterator= createIterator([1,2,3]); console.log(iterator.next()); console.log(iterator.next()); console.log(iterator.next()); console.log(iterator.next()); console.log(iterator.next()); //&#123;done: false, value: 1&#125;//VM42:18 &#123;done: false, value: 2&#125;//VM42:19 &#123;done: false, value: 3&#125;//VM42:20 &#123;done: true, value: undefined&#125;//VM42:21 &#123;done: true, value: undefined&#125; 这是个简单的es5的迭代器，在es6的迭代器更加复杂 什么是生成器 虽然自定义的迭代器是一个有用的工具，但由于需要显式地维护其内部状态，因此需要谨慎地创建。Generators提供了一个强大的选择：它允许你定义一个包含自有迭代算法的函数， 同时它可以自动维护自己的状态。它是这样表示的 1234567891011121314151617//生成器function *createIterator()&#123; yield 1; yield 2; yield 3; &#125;//生成器的调用方式与普通函数相同，只不过返回的是一个迭代器 var iterator= createIterator(); console.log(iterator.next()); console.log(iterator.next()); console.log(iterator.next());//&#123;value: 1, done: false&#125;//VM55:12 &#123;value: 2, done: false&#125;//VM55:13 &#123;value: 3, done: false&#125; 每个yield相当于一个调用一次next方法，而且每次执行yield都会暂停一次。函数名前面的*代表它是一个生成器 yield只能在生成器中用，不能在普通函数使用,生成器的内部函数也不能使用（语法错误），另外yield关键字可以返回任何值或者表达式 123456789101112131415161718function * createIterator(itmes)&#123; for(let i = 0; i&lt; items.length;i++)&#123; yield items[i] &#125;&#125;var iterator= createIterator([1,2,3]); console.log(iterator.next()); console.log(iterator.next()); console.log(iterator.next()); console.log(iterator.next()); console.log(iterator.next());//&#123;value: 1, done: false&#125;//VM98:8 &#123;value: 2, done: false&#125;//VM98:9 &#123;value: 3, done: false&#125;//VM98:10 &#123;value: undefined, done: true&#125;//VM98:11 &#123;value: undefined, done: true&#125; 生成函数表达式12345678910111213141516171819202122232425let createIterator = function *(items) &#123; for (let i = 0; i&lt; items.length ; i++)&#123; yield items[i]; &#125; &#125;var iterator= createIterator([1,2,3]); console.log(iterator.next()); console.log(iterator.next()); console.log(iterator.next()); console.log(iterator.next()); console.log(iterator.next());//VM108:10 &#123;value: 1, done: false&#125;//VM108:11 &#123;value: 2, done: false&#125;//VM108:12 &#123;value: 3, done: false&#125;//VM108:13 &#123;value: undefined, done: true&#125;//VM108:14 &#123;value: undefined, done: true&#125;``` &gt; 不能用箭头函数来创建生成器#### 生成器对象的方式 let o = { createIterator:function *(items) { for (let i = 0; i&lt; items.length ; i++){ yield items[i]; } }} let o.createIterator([1,2,3]) 1&gt; 也可以用es6的写法 let o = { *createIterator(items) { for (let i = 0; i&lt; items.length ; i++){ yield items[i]; } }} let o.createIterator([1,2,3]) 1234567#### 可迭代对象和for-of循环&gt; es6中所有的集合对象（数组，Set集合以及Map集合）和字符串都是可迭代对象，可迭代对象都是具有Symbol.iterator属性，通过指定的函数可以返回一个作用于附属对象的迭代器&gt; 由生成器创建的迭代器都是可迭代对象，因为它会默认为Symbol.iterator属性赋值。&gt; for -of 每次执行都会调用next()方法，并将返回的结果对象的value存储在变量中，直到遇到对象的done属性为true let values = [1,2,3]; for(let value of values){ console.log(value);} //返回结果// 1// 2// 312#### 访问可迭代对象的默认的迭代器 let values = [1,2,3];let iterator = valuesSymbol.iterator; console.log(iterator.next());console.log(iterator.next());console.log(iterator.next());console.log(iterator.next()); //运行结果 //{value: 1, done: false}//VM57:5 {value: 2, done: false}//VM57:6 {value: 3, done: false}//VM57:7 {value: undefined, done: true}12### 创建可以迭代的对象&gt; 默认情况下开发者定义的对象是不能迭代的，但是我们可以给Symbol.iterator属性加一个生成器 let arr = { items:[], *Symbol.iterator{ for(let item of this.items){ yield item; } }}let a = [1,2,3];a.forEach(value =&gt; arr.items.push(value)); for(let x of arr){ console.log(x); }// 1//2//312345678910### 内建迭代器&gt; es6自己定义了一些迭代器，我们只有在无法用这些内建迭代器实现功能时才可能自己创建#### 集合对象迭代器&gt; es6的三种对象数组，Set集合，Map集合都内置了下列三种迭代器 - entries() 返回一个迭代器，其值为多个键值对 - values() 返回一个迭代器，其值为集合的值- keys() 返回一个迭代器，其值为集合中的所有键名&gt; entries()栗子 三种表现 let colors = [‘red’,’blue’,’green’];let tracking = new Set([123,567,9012]);let data = new Map();data.set(‘title’,’es6教程’);data.set(‘format’,’ebook’);for (let entry of colors.entries()){ console.log(entry);}for (let entry of tracking .entries()){ console.log(entry);}for (let entry of data.entries()){ console.log(entry);}123![运行结果](http://upload-images.jianshu.io/upload_images/10843623-ac216eee2bd7b0b6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)&gt; values()迭代器 let colors = [‘red’,’blue’,’green’];let tracking = new Set([123,567,9012]);let data = new Map();data.set(‘title’,’es6教程’);data.set(‘format’,’ebook’);for (let entry of colors.values()){ console.log(entry);}for (let entry of tracking .values()){ console.log(entry);}for (let entry of data.values()){ console.log(entry);}12345![a.png](http://upload-images.jianshu.io/upload_images/10843623-3c3a015d2b46b429.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)&gt; 数组的values()谷歌暂不支持，所以我们需要小心使用这些方法，有的浏览器还是支持的，谷歌不支持我肯定不会用&gt; keys()迭代器 let colors = [‘red’,’blue’,’green’];let tracking = new Set([123,567,9012]);let data = new Map();data.set(‘title’,’es6教程’);data.set(‘format’,’ebook’);for (let entry of colors.keys()){ console.log(entry);}for (let entry of tracking .keys()){ console.log(entry);}for (let entry of data.keys()){ console.log(entry);}123![a.png](http://upload-images.jianshu.io/upload_images/10843623-ff3457147502690e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)&gt; 不同的集合类型在使用for-of迭代有各自默认的迭代器 let colors = [‘red’,’blue’,’green’];let tracking = new Set([123,567,9012]);let data = new Map();data.set(‘title’,’es6教程’);data.set(‘format’,’ebook’); //与colors.values()方法相同for(let value of colors){ console.log(value);} //与tracking .values()方法相同for(let value of tracking ){ console.log(value);} //与data.entries()方法相同for(let value of data){ console.log(value);} 12345![a.png](http://upload-images.jianshu.io/upload_images/10843623-5db145e4054950f1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)&gt; WeakMap和WekSet因为需要管理弱引用，因此无法切确知道集合中存在的值，所以不能被迭代#### 解构的方式来用for-of let data = new Map();data.set(‘title’,’es6教程’);data.set(‘format’,’ebook’); for(let [key,value] of data){ console.log(key+”:”+value);} //title:es6教程//format:ebook12### 字符串迭代器&gt; es5发布以后，字符串的慢慢变的像数组，于是我们有些方式可以用了，例如我们可以通过[]来获取字符串的中的字符。但是我们怎么访问双字节，就如下面这种情况 var message = ‘A 𠮷 B’;for(let i = 0;i&lt;message.length;i++){ console.log(message[i]);}12![a.png](http://upload-images.jianshu.io/upload_images/10843623-057bb5d93c53e471.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)&gt; 我们可以用 for-of来做迭代 var message = ‘A𠮷B’;for(let i of message){ console.log(i);}123![a.png](http://upload-images.jianshu.io/upload_images/10843623-227069880ae816f2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)### NodeList迭代器&gt; 虽然在es6之前Nodelist和数组在内部差异表现不一致，容易造成困扰，但是es6之后，nodelist也有了自己的默认的迭代器，并且实现方式一致，因此我们可以这样写了 var divs = document.getElementsByTagName(‘div’); for(let nodeEle of divs){ console.log(nodeEle);} 1### 展开运算符与非数组可迭代对象 //Setlet set = new Set([1,3,3,5,6]),arr = […set];console.log(arr); // [1, 3, 5, 6] //Maplet map= new Map([[‘name’,’ly’],[‘sex’,’男’]]),arr = […map];console.log(arr); //0:(2) [“name”, “ly”]//1:(2) [“sex”, “男”] //数组字面量let small = [1,2.3,4],mid = [2,3,4,6],all = [0,…small,…mid];console.log(all); //[0, 1, 2.3, 4, 2, 3, 4, 6]123### 高级迭代器功能&gt; 给迭代器传参数 function *createIterator(){ let first = yield 1; let second = yield first+2; let third= yield second +3;}let iterator = createIterator();console.log(iterator.next(1));console.log(iterator.next(2));console.log(iterator.next(3));console.log(iterator.next(1));12345![a.png](http://upload-images.jianshu.io/upload_images/10843623-2346da44ba0629fc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)&gt; 第一个next和最后一个next,传的值都会被丢弃，因为之前和之后都不存在可以用的值，所以传参毫无意义，每次传的参数都是作为上一个定义参数的值.### 在迭代器中抛出错误&gt; 有时候我们需要增强生成器内部的编程弹性，需要将一些错误抛出去，让迭代器继续运行。 function *createIterator(){ let first = yield 1; let second = yield first+2; let third= yield second +3;}let iterator = createIterator();console.log(iterator.next(1));console.log(iterator.next(4));console.log(iterator.throw(new Error(“boom”)));123![a.png](http://upload-images.jianshu.io/upload_images/10843623-37f34e63ac70e131.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)&gt; 我们如何处理这些错误呢，可以这么写 function *createIterator(){ let first = yield 1; let second; try{ second = yield first+2;}catch(x){ second = 3} yield second +3;}let iterator = createIterator();console.log(iterator.next(1));console.log(iterator.next(4));console.log(iterator.throw(new Error(“boom”)));console.log(iterator.next()); 123![a.png](http://upload-images.jianshu.io/upload_images/10843623-45c1a600797830a0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)#### 通过return 可以提前结束函数的执行，再一次调用，属性done将会被置为true function *createIterator(){ yield 1; return; yield 2; yield 3;}let iterator = createIterator();console.log(iterator .next());console.log(iterator .next());123![a.png](http://upload-images.jianshu.io/upload_images/10843623-0b7221c96e78f887.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)&gt; return 返回的值也可以作为一次执行的结果 function *createIterator(){ yield 1; return 20; yield 2; yield 3;}let iterator = createIterator();console.log(iterator .next());console.log(iterator .next());console.log(iterator .next());1234567891011121314151617181920212223![a.png](http://upload-images.jianshu.io/upload_images/10843623-af97635a515ca02a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)### 委托生成器&gt; 如果我们需要将两个迭代器分别执行，但是又想只调用一个同样的生成器，我们可以用委托生成器``` function *createIteratorOne()&#123; yield 1; yield 2;&#125;function *createIteratorTwo()&#123; yield &apos;blue&apos;; yield &apos;;white&apos;;&#125; function *createIterator()&#123; yield *createIteratorOne(); yield *createIteratorTwo();&#125;let iterator = createIterator();console.log(iterator .next());console.log(iterator .next());console.log(iterator .next()); yield 也可以用于字符串 例如 yield ‘hello’,这时会调用字符串的默认迭代器 1234567 function *createIterator()&#123; yield * &apos;hello&apos;&#125;let iterator = createIterator();console.log(iterator .next());console.log(iterator .next());console.log(iterator .next()); 异步任务执行 生成器支持在代码中暂停代码的执行，因此我们可以挖掘一些用法 简单任务生成器1234567891011121314151617181920212223242526function run(taskDef)&#123; //创建一个无使用限制的迭代器 let task = taskDef(); //开始执行任务 let result = task.next(); //循环调用next()的函数 function step()&#123; if(!result.done)&#123; result = task.next(); step(); &#125;&#125;//开始执行迭代 step();&#125;//调用run()函数run(function *()&#123; console.log(1); yield; console.log(2); yield; console.log(3);&#125;)//逐步输出 1 2 3 ####向任务执行器传递数据12345678910111213141516171819202122232425function run(taskDef)&#123; //创建一个无使用限制的迭代器 let task = taskDef(); //开始执行任务 let result = task.next(); //循环调用next()的函数 function step()&#123; if(!result.done)&#123; result = task.next(result.value); step(); &#125;&#125;//开始执行迭代 step();&#125;//调用run()函数run(function *()&#123; let value = yield 1; console.log(value ); value = yield value + 1; console.log(value );&#125;)//逐步输出 1 2 异步任务执行器123456789101112131415161718192021222324252627282930313233343536373839function run(taskDef)&#123; //创建一个无使用限制的迭代器 let task = taskDef(); //开始执行任务 let result = task.next(); //循环调用next()的函数 function step()&#123; if(!result.done)&#123; if(typeof result.value ===&apos;function&apos;)&#123; result.value(function(err,data)&#123; if(err)&#123;result = task.throw(err)&#125;; return;&#125;) &#125; else &#123; result = task.next(); step();&#125; &#125;&#125;//开始执行迭代 step();&#125;//读取文件函数let fs = require(&quot;fs&quot;);function readFile(filename)&#123; return function(callback)&#123; fs.readFile(filename.,callback)&#125;&#125;//调用run(function *()&#123; let contents = yield readFile(&quot;config.json&quot;); doSomethingWith(contents); console.log(&quot;Done&quot;)&#125;)]]></content>
      <tags>
        <tag>es6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[es6-类]]></title>
    <url>%2F2018%2F03%2F17%2Fes6-%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[前言 最近这两天有点不在状态，感觉有种无形的压力压在身上，变的异常的暴躁了，唉，前端这条路真的走对了吗？算了，敲代码吧。 类声明 要声明一个类,首先使用 class 关键字，紧接着是类的名字，然后其他内部方法和属性类似于对象的字面量写法 1234567891011121314151617 class PersonClass&#123; //定义一个类似es5写法的构造函数，通过关键字constructor constructor(name)&#123; this.name = name &#125; //定义方法 sayName()&#123; console.log(this.name);&#125;&#125;let person = new PersonClass(&quot;ly&quot;);person.sayName();console.log(person instanceof PersonClass);console.log(person instanceof Object);console.log(typeof PersonClass);console.log(typeof PersonClass.prototype.sayName); es5 对应的等价代码 12345678910111213141516171819202122let PersonType2 = (function()&#123; &quot;use strict&quot; const PersonType2 = function(name)&#123; //确保通过关键字new调用该函数 if(typeof new.target === &quot;undefined&quot;)&#123; throw new Error(&quot;必须通过new来创建&quot;) &#125; &#125; Object.defineProperty(PersonType2.prototype,&apos;sayName&apos;,&#123; value:function()&#123; //确保不通过关键字new调用该函数 if(typeof new.target !== &quot;undefined&quot;)&#123; throw new Error(&quot;不能通过new来创建&quot;) &#125; console.log(this.name) &#125;, enumerable:false, writable:true, configurable:true &#125;) return PersonType2;&#125;()) 类表达式 跟函数一样他也存在表达式写法，好像还很雷同 1234567891011121314151617 let PersonClass = class &#123; //定义一个类似es5写法的构造函数，通过关键字constructor constructor(name)&#123; this.name = name &#125; //定义方法 sayName()&#123; console.log(this.name);&#125;&#125;let person = new PersonClass(&quot;ly&quot;);person.sayName();console.log(person instanceof PersonClass);console.log(person instanceof Object);console.log(typeof PersonClass);console.log(typeof PersonClass.prototype.sayName); 上述两种类的写法，它不会出现变量提升的现象，所以我们的那种写法，对结果没啥太大区别 类也将作为一等公民 一等公民是指一个可以传入的函数，可以从函数返回，并且可以赋值给变量的值 123456789101112131415161718192021//像这样的方式function createObject(classDef)&#123; return new ClassDef();&#125;let objClass = createObject(class &#123; sayHi() &#123; console.log(&apos;hi&apos;);&#125;&#125;)//函数表达式还有一种调用方式，就是通过立即调用类构造函数可以创建单例let person = new class&#123; constructor(name)&#123; this.name = name; &#125; sayName() &#123; console.log(this.name);&#125;&#125;(&apos;ly&apos;)person.sayName() //ly 访问器属性 类支持在构造函数下创建自己的属性，但是类也支持直接在原型上定义访问器的属性,通过 get 和 set 来获得值或者设置值 1234567891011121314151617181920212223class Person &#123; constructor(name) &#123; this.name = name; &#125; set ages(age) &#123; return this.age = age; &#125; get ages() &#123; return this.age+10; &#125;&#125;let person = new Person(&apos;ly&apos;);person.ages = 18console.log(person.ages);person.agess = 18console.log(person.agess);var descriptor = Object.getOwnPropertyDescriptor(Person.prototype,&apos;ages&apos;);console.log(&quot;get&quot; in descriptor); //trueconsole.log(&quot;set&quot; in descriptor);//trueconsole.log(descriptor.enumerable); //false 生成器方法与类的结合12345678910111213class MyClass &#123; * createIterator() &#123; yield 1; yield 2; yield 1; &#125;&#125;var b = new MyClass()var a = b.createIterator();console.log(a.next());console.log(a.next());console.log(a.next());console.log(a.next()); 我们可以通过 Symbol.iterator 属性定义一个默认的类迭代器1234567891011121314151617class Collection &#123; constructor() &#123; this.items = [] &#125; *[Symbol.iterator]() &#123; yield * this.items.entries(); &#125;&#125;var collection = new Collection();collection.items.push(1)collection.items.push(12)collection.items.push(16)for (const x of collection) &#123; console.log(x);&#125; 静态成员 es5 来模拟静态成员 123456789101112131415161718function PersonType(name)&#123; this.name = name;&#125;//静态方法PersonType.create = function(name)&#123; return new PersonType(name)&#125;//实例方法PersonType.prototype.sayName = function()&#123; console.log(this.name);&#125;var person = PersonType.create(&quot;ly&quot;);person.name = &quot;li&quot;console.log(person); //ly （不是很懂静态成员是干嘛的，就是为了让构造函数也能像普通函数一样挂在函数吗？） 在 es 可以通过 static 来创建静态成员 12345678910111213141516class PersonClass &#123; constructor(name)&#123; this.name = name; &#125; sayName()&#123; console.log(&quot;hi&quot;) &#125; static create(name)&#123; return new PersonClass(name) &#125;&#125;let person = PersonClass.create(&apos;ly&apos;);console.log(person.name); //ly 继承与派生类 在 es6 之前继承需要这么长的代码，而且 haibuyi 123456789101112131415161718192021222324252627function Reactangle(length,width)&#123; this.length = length; this.width = width;&#125;Reactangle.prototype.getArea = function()&#123; return this.length*this.width;&#125;function Square(length)&#123; Reactangle.call(this,length,length)&#125;Square.prototype = Object.create(Reactangle.prototype,&#123; constructor:&#123; value:Square, enumerable:true, writeable:true, configurable:true &#125;&#125;)var square = new Square(4);console.log(square.getArea()); //16console.log(square instanceof Square);//trueconsole.log(square instanceof Reactangle);//true 这样的类继承更加 清晰 12345678910111213141516171819202122class Reactangle &#123; constructor(length, width) &#123; this.length = length; this.width = width; console.log(this.length,this.width); &#125; getArea() &#123; return this.length * this.width &#125;&#125;class Square extends Reactangle &#123; constructor(length) &#123; super(length, length) &#125;&#125;var square = new Square(3);console.log(square.getArea()); //9console.log(square instanceof Square); //true 这是 super 的默认是设置 1234567891011class Squery extends Reactangle &#123;&#125;//等价于class Square extends Reactangle &#123; constructor(...args)&#123; super(...args); &#125;&#125; 类方法遮蔽 派生类中的方法总会覆盖基类中的同名方法。这种覆盖只是屏蔽 12345678910111213141516class Reactangle &#123; constructor(length, width) &#123; this.length = length; this.width = width; console.log(this.length,this.width); &#125; getArea() &#123; return this.length * this.width &#125;&#125;class Square extends Reactangle &#123; getArea() &#123; return this.length*this.length; &#125;&#125; 我们也可以屏蔽之后在调用 1234567891011121314151617181920class Reactangle &#123; constructor(length, width) &#123; this.length = length; this.width = width; console.log(this.length,this.width); &#125; getArea() &#123; return this.length * this.width &#125;&#125;class Square extends Reactangle &#123; getArea() &#123; return super.getArea(); &#125;&#125;var square = new Square(3,3);console.log(square.getArea()); //9console.log(square instanceof Square); //true 静态成员继承 通过 static 创建的静态成员,静态变量不能被子类继承 12345678910111213141516171819202122232425class Reactangle &#123; constructor(length, width) &#123; this.length = length; this.width = width; console.log(this.length,this.width); &#125; getArea() &#123; return this.length * this.width &#125; static create(length,width)&#123; return new Reactangle(length,width) &#125;&#125;class Square extends Reactangle &#123; getArea() &#123; return super.getArea(); &#125;&#125;var square = Square.create(3,4);console.log(square.getArea()); //9console.log(square instanceof Square); //true 类相当于实例的原型， 所有在类中定义的方法， 都会被实例继承。 如果在一个方法前， 加上 static 关键字， 就表示该方法不会被实例继承， 而是直接通过类来调用， 这就称为“ 静态方法” (好像理解了点) 派生自表达式的类 只要一个函数具有[Constuctor]属性和原型 1234567891011121314151617181920function Reactangle(length,length)&#123; this.length = length; this.width = width;&#125;Reactangle.prototype.getArea = function()&#123; return this.length*this.width&#125;class Square extends Reactangle &#123; constructor (length) &#123; super(length,length) &#125;&#125;var square = new Square(3);console.log(square.getArea()); //9console.log(square instanceof Square); //true 继承的高级用法 下面的栗子可以动态确定使用那个基类，更好的辅助开发 123456789101112131415161718192021222324252627282930let SerializableMixin = &#123; serialize()&#123; return JSON.stringify(this) &#125;&#125;let AreaMixin = &#123; getArea() &#123; return this.length*this.width; &#125;&#125;function mixin(...mixins)&#123; var base = function()&#123;&#125;; Object.assign(base.prototype,...mixins); return base;&#125;class Square extends mixin (AreaMixin,SerializableMixin) &#123; constructor (length)&#123; super(); this.length = length; this.width = length; &#125;&#125;var x = new Square(3)console.log(x.getArea()) //9console.log(x.serialize()) //&#123;&quot;length&quot;:3,&quot;width&quot;:3&#125; 类的 Symbol.species 属性 Symbol.species 是指定一个构造函数创建派生对象的函数值属性,比如当我们继承一个 Array 时，我们调用其方法产生的对象将不再是原始的类而是派生出来的类，比如 1234567891011class MyArray extends Array &#123;&#125;let items = new MyArray(1,3,4,5), subitems = items.map(item =&gt; item*2);console.log(items instanceof MyArray); //trueconsole.log(subitems instanceof MyArray); //trueconsole.log(items instanceof Array); //trueconsole.log(subitems instanceof Array); //true 但是实际上也不是这么一回事，于是我加了这段代码 12345678910111213class MyArray extends Array &#123; static get [Symbol.species]()&#123; return RegExp; &#125;&#125;let items = new MyArray(1,3,4,5), subitems = items.map(item =&gt; item*2);console.log(items instanceof MyArray); //trueconsole.log(subitems instanceof MyArray); //falseconsole.log(items instanceof Array); //trueconsole.log(subitems instanceof Array); //false mdn 的解释一下代码参考下 你可能想在扩展数组类 MyArray 上返回 Array 对象。 例如，当使用例如 map() 这样的方法返回默认的构造函数时，你希望这些方法能够返回父级的 Array 对象，以取代 MyArray 对象。Symbol.species 允许你这么做 123456789class MyArray extends Array &#123; // 覆盖 species 到父级的 Array 构造函数上 static get [Symbol.species]() &#123; return Array; &#125; &#125; var a = new MyArray(1,2,3); var mapped = a.map(x =&gt; x * x); console.log(mapped instanceof MyArray); // false console.log(mapped instanceof Array); // true 但是即使不这么做我也是可以返回他的父级方法，有点鸡肋？ 再说 在累的构造函数使用 new.target 之前在构造函数如果要求必须通过 new 来创建是这样写的 123456789function Add(name)&#123; console.log(new.target=== Add) //true if(typeof new.target==&quot;undefined&quot;)&#123; throw new Error(&apos;必须通过new创建&apos;) &#125; this.name = name;&#125;var a = new Add(&apos;ly&apos;); 现在可以怎么写 12345678class Add &#123; constructor(name)&#123; this.name = name; console.log(new.target=== Add) //true &#125;&#125;var a = new Add(&apos;ly&apos;); 构造函数不通过 new 创建的实例，new.target 为 undefined 123456789function Add(name)&#123; console.log(new.target) //true if(typeof new.target==&quot;undefined&quot;)&#123; throw new Error(&apos;必须通过new创建&apos;) &#125; this.name = name;&#125;var a =Add(&apos;ly&apos;); 类则是无论如何都有值，因为必须 new 啊 不然报错 我们可以用这样的方式定义基类，基类不可被创建，只能被继承 1234567891011121314151617class Add &#123; constructor(name)&#123; if(new.target===Add)&#123; throw new Error(&apos;基类不可被继承&apos;) &#125; this.name = name; &#125;&#125;class SubAdd extends Add &#123; constructor(name)&#123; super(name) &#125;&#125;// var a = new Add(&apos;ly&apos;); //报错 基类不可被继承var b= new SubAdd(&apos;hh&apos;)]]></content>
      <tags>
        <tag>es6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[es6-数组新增功能与改进]]></title>
    <url>%2F2018%2F03%2F15%2Fes6-%E6%95%B0%E7%BB%84%E6%96%B0%E5%A2%9E%E5%8A%9F%E8%83%BD%E4%B8%8E%E6%94%B9%E8%BF%9B%2F</url>
    <content type="text"><![CDATA[数组 es6加入了一些数组的新功能，以及改进了旧功能 保证永远传的是数组的元素1234567891011121314let items = Array.of(20);console.log(items.length) //1console.log(items[0]) //20itmes = Array.of(2);console.log(itmes.length);//1console.log(itmes[0]); //2itmes = Array.of(&apos;2&apos;);console.log(itmes.length); //1console.log(itmes[0]); //&apos;2&apos; 将类对象转换成数组的方式123456function translate()&#123; return Array.from(arguments)&#125;let number = translate(1,3,4,5);console.log(number); //[ 1, 3, 4, 5 ] 映射转换(第二个参数的转换)123456function translate()&#123; return Array.from(arguments,(value) =&gt; value+1)&#125;let number = translate(1,3,4,5);console.log(number); //[ 2, 4, 5, 6 ] 第三个值是this12345678910111213let helper = &#123; diff:1, add(value)&#123; return value+this.diff; &#125;&#125;function translate()&#123; return Array.from(arguments,helper.add,helper)&#125;let number = translate(1,3,4,5);console.log(number); // [ 2, 4, 5, 6 ] Array.from可以用来转换可迭代对象123456789101112let number = &#123; *[Symbol.iterator]()&#123; yield 1; yield 2; yield 3; yield 4; &#125;&#125;let number2 = Array.from(number,(value) =&gt; value+1);console.log(number2); //[ 2, 3, 4, 5 ] 新增方法find()方法和findIndex()方法 两个方法的一个函数接受一个回调函数，以及一个this作为参数 find返回的是return为true的值1234567let numbers = [1,34,4,44,33,56];console.log(numbers.find((item,index,arr) =&gt; &#123; if(item&gt;33)&#123; console.log(item,index,arr); //34 1 [ 1, 34, 4, 44, 33, 56 ] return item &#125;&#125;)) //34 findIndex()返回的是满足true的值的位置(第一个)1234567let numbers = [1,34,4,44,33,56];console.log(numbers.findIndex((item,index,arr) =&gt; &#123; if(item&gt;33)&#123; console.log(item,index,arr); //34 1 [ 1, 34, 4, 44, 33, 56 ] return item &#125;&#125;)) //1 fill() 方法用一个固定值填充一个数组中从起始索引到终止索引内的全部元素 接受三个参数一个是要填充的值，一个是填充的起始位置，一个是结结束位置123456789let numbers = [1,34,4,44,33,56];console.log(numbers.fill(1)) //[ 1, 1, 1, 1, 1, 1 ]console.log(numbers) //[ 1, 1, 1, 1, 1, 1 ] //改变原数组let nums = [2,3,4,5,2,4,3]console.log(nums.fill(1,2)) //[ 2, 3, 1, 1, 1, 1, 1 ]console.log(nums.fill(6,2,5)); //[ 2, 3, 6, 6, 6, 1, 1 ] //作闭右开 copyWith方法浅复制数组的一部分到同一数组中的另一个位置，并返回它，而不修改其大小 该方法接受3个值，一个是开始填充的位置，一个是开始复制的位置位置,改变原数组,一个是复制结束的位置 123let numbers = [1,34,4,44,33,56];console.log(numbers.copyWithin(2,3)); //[ 1, 34, 44, 33, 56, 56 ]console.log(numbers.copyWithin(2,0,1)); //[ 1, 34, 1, 33, 56, 56 ] 定型数组 定型数组是一种用于处理数值类型(正如其名，不是所有类型)数据的专用数组，最早是在WebGL中使用的，WebGL是OpenGL ES 2.0的移植版，在Web 页面中通过 元素来呈现它。定型数组也被一同移植而来，其可为JS提供快速的按位运算 在JS中，数字是以64位浮点格式存储的，并按需转换为32位整数，所以算术运算非常慢，无法满足WebGL的需求。因此在ES6中引入定型数组来解决这个问题，并提供更高性能的算术运算。所谓定型数组，就是将任何数字转换为一个包含数字比特的数组，随后就可以通过我们熟悉的JS数组方法来进一步处理 数组缓冲区 ArrayBuffer 对象用来表示通用的、固定长度的原始二进制数据缓冲区。ArrayBuffer 不能直接操作，而是要通过类型数组对象或 DataView 对象来操作，它们会将缓冲区中的数据表示为特定的格式，并通过这些格式来读写缓冲区的内容。1234567let buffer = new ArrayBuffer(10);console.log(buffer.byteLength); //10//也可以使用数组的方法（类似）let buffer2 = buffer.slice(1,3);console.log(buffer2.byteLength) //2 不能修改缓存区的大小，只能修改数据缓冲区内的数据 通过视图操作数组缓冲区 数组缓冲区是内存中的一段地址，视图是用来操作内存的接口。视图可以操作数组缓冲区或缓冲区字节的子集，并按照其中一种数值型数据类型来读取和写入数据。DataView类型是一种通用的数组缓冲区视图，其支持所有8种数值型数据类型 有符号的8位整数(int8) 无符号的8位整数(uint8) 有符号的16位整数(int16) 无符号的16位整数(uint16) 有符号的32位整数(int32) 无符号的32位整数(uint32) 32位浮点数(float32) 64位浮点数(float64)可以通过以下几种只读属性来获取视图的信息 buffer 视图绑定的数组缓冲区 byteOffset DataView构造函数的第二个参数，默认是0，只有传入参数时才有值 byteLength DataView构造函数的第三个参数，默认是缓冲区的长度byteLength1234567891011121314let buffer = new ArrayBuffer(10),//使用DataView创建视图的实例 view1 = new DataView(buffer), view2 = new DataView(buffer,5,2); // 第一个参数是创建的缓冲区，第二个是操作缓冲区的起始位置，第三个参数是缓冲区的长度 console.log(view1.buffer === buffer); //true console.log(view2.buffer === buffer); //true console.log(view1.byteOffset); //0 console.log(view2.byteOffset); //5 console.log(view1.byteLength); //10 console.log(view2.byteLength); //2 读取和写入数据 js的8中数值型数据类型，在DataView的原型上都能找到 读方法DataView.prototype.getInt8()从DataView起始位置以byte为计数的指定偏移量(byteOffset)处获取一个8-bit数(一个字节).DataView.prototype.getUint8()从DataView起始位置以byte为计数的指定偏移量(byteOffset)处获取一个8-bit数(无符号字节).DataView.prototype.getInt16()从DataView起始位置以byte为计数的指定偏移量(byteOffset)处获取一个16-bit数(短整型).DataView.prototype.getUint16()从DataView起始位置以byte为计数的指定偏移量(byteOffset)处获取一个16-bit数(无符号短整型).DataView.prototype.getInt32()从DataView起始位置以byte为计数的指定偏移量(byteOffset)处获取一个32-bit数(长整型).DataView.prototype.getUint32()从DataView起始位置以byte为计数的指定偏移量(byteOffset)处获取一个32-bit数(无符号长整型).DataView.prototype.getFloat32()从DataView起始位置以byte为计数的指定偏移量(byteOffset)处获取一个32-bit数(浮点型).DataView.prototype.getFloat64()从DataView起始位置以byte为计数的指定偏移量(byteOffset)处获取一个64-bit数(双精度浮点型). 写方法DataView.prototype.setInt8()从DataView起始位置以byte为计数的指定偏移量(byteOffset)处储存一个8-bit数(一个字节).DataView.prototype.setUint8()从DataView起始位置以byte为计数的指定偏移量(byteOffset)处储存一个8-bit数(无符号字节).DataView.prototype.setInt16()从DataView起始位置以byte为计数的指定偏移量(byteOffset)处储存一个16-bit数(短整型).DataView.prototype.setUint16()从DataView起始位置以byte为计数的指定偏移量(byteOffset)处储存一个16-bit数(无符号短整型).DataView.prototype.setInt32()从DataView起始位置以byte为计数的指定偏移量(byteOffset)处储存一个32-bit数(长整型).DataView.prototype.setUint32()从DataView起始位置以byte为计数的指定偏移量(byteOffset)处储存一个32-bit数(无符号长整型).DataView.prototype.setFloat32()从DataView起始位置以byte为计数的指定偏移量(byteOffset)处储存一个32-bit数(浮点型).DataView.prototype.setFloat64()从DataView起始位置以byte为计数的指定偏移量(byteOffset)处储存一个64-bit数(双精度浮点型). 用法123456789101112let buffer = new ArrayBuffer(10), //使用DataView创建视图的实例 view = new DataView(buffer); view.setInt8(0,5); view.setInt8(1,-1); console.log(view.getInt8(0)); //5 console.log(view.getInt8(1)); //-1 //也可以用getInt16的字节调用，这样使用的话，两个8比特的字符就会合并成一个16bit字符,于是得到的值就是这个了 console.log(view.getInt16()) //1535 定型数组—特殊的视图类型 上面的缓冲区类型视图是可以随意更变的，但是我们只希望处理一种数据类型，这让我们很容易选择和判断1234567891011121314let buffer = new ArrayBuffer(10),//使用DataView创建视图的实例 view1 = new Int8Array(buffer), view2 = new Int8Array(buffer,5,2); // 第一个参数是创建的缓冲区，第二个是操作缓冲区的起始位置，第三个参数是缓冲区的长度 console.log(view1.buffer === buffer); //true console.log(view2.buffer === buffer); //true console.log(view1.byteOffset); //0 console.log(view2.byteOffset); //5 console.log(view1.byteLength); //10 console.log(view2.byteLength); //2 不用数组缓冲区创建数组，利用定型数组的创建12345678let ints = new Int16Array(2), floats = new Float32Array(5); console.log(ints.byteLength); //4 console.log(ints.length); //2 console.log(floats.byteLength); //20 console.log(floats.length); //5 不给定型参数传值，则不能使用缓存区，因为它的容量默认为0 第三种创建定型数组的方法是调用构造函数时，将以下任一对象作为唯一的参数传入 1、一个定型数组 &gt;该数组中的每个元素会作为新的元素被复制到新的定型数组中。例如，如果将一个int8数组传入到Int16Array构造函数中，int8的值会被复制到一个新的int16数组中，新的定型数组使用新的数组缓冲区 2、一个可迭代对象 &gt; 对象的迭代器会被调用，通过检索所有条目来选取插入到定型数组的元素，如果所有元素都是不适用于该视图类型的无效类型，构造函数将会抛出一个错误 3、一个数组 &gt; 数组中的元素会被复制到一个新的定型数组中，如果所有元素都是不适用于该视图类型的无效类型，构造函数将会抛出一个错误 4、一个类数组对象 &gt; 与传入数组的行为一致 123456789101112 let int1 = new Int16Array([15,25]), int2 = new Int32Array(int1);console.log(int1.buffer === int2.buffer); //4console.log(int1.byteLength); //15console.log(int1[0]) //25console.log(int1[1]) //8console.log(int2.byteLength) //2console.log(int2.length) //15console.log(int2[0]); //15console.log(int2[1]); //25 元素大小 每种定型数组由多个元素组成，元素大小,元素大小指的每个元素表示的字节数，该值存储在每个构造函数和每个实例的BYTES_PRE_ELEMENT属性12345console.log(UInt8Array.BYTES_PRE_ELEMENT);console.log(UInt16Array.BYTES_PRE_ELEMENT);let ints = new Int8Array(5);console.log(ints.BYTES_PER_ELEMENT); 定型数组也适用于数组的通用方法，但也有区别123456789101112131415161718//原型不同let ints = new Int16Array([20,50]);console.log(ints instanceof Array); //falseconsole.log(Array.isArray(ints)); //false//行为差异，数组的元素尺寸大小一致,且不能被扩展let ints = new Int16Array([25,50]);console.log(ints.length); //2console.log(ints[0]); //25console.log(ints[1]); //50ints[2] = 5; console.log(ints.length); //2console.log(ints[0]); //25//0被用于代替所有非法值let ints = new Int16Array([&apos;hi&apos;]);console.log(ints.length); //1console.log(ints[0]); //0 缺失的方法 concat() shift() pop() splice() push() unshift()附加方法 set():将其他数组复制到已有的定型数组 subarray():提取已有定型数组的一部分作为新的定型数组 set() 一个是数组(定型数组或普通数组),一个是可选的偏移量，表示开始插入数据的位置，1234let ints = new Int16Array(4);ints.set([25,50]);ints.set([125,50],1);console.log(ints.toString()); //25,50,75,0 subArray()一个是可选的开始位置,一个是可选的结束12345678let ints = new Int16Array([25,50,75,100]), subint1 = ints.subarray(), subint2 = ints.subarray(2), subint3 = ints.subarray(1,3); console.log(subint1.toString());//25,50,75,100 console.log(subint2.toString());//75,100 console.log(subint3.toString());//75,100]]></content>
      <tags>
        <tag>es6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6-字符串和正则表达式]]></title>
    <url>%2F2018%2F01%2F25%2FES6-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%92%8C%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[前言 入行这么久了，前端学习的成本感觉越来越高了，不会的东西一茬接一茬，在学校太忽视它，学的半吊子，现在要努力赶上才行，杭州的天气变冷了，我也想回家了，坚持，哎嘿，再上半个月班就要放假了开心。（这是从我自己博客移植过来的） 我的博客地址 ：http://www.aymfx.cn/，欢迎访问 引子 这张理解起来比较费劲，慢慢看，慢慢练,天气比较冷啊，手敲这些好费劲 utf-16码位(基本多文种平面)到辅助平面字符的扩展 在ES6之前， JS 的字符串以 16 位字符编码(UTF-16)为基础。每个 16 位序列(相当于2个字节)是一个编码单元(code unit)，可简称为码元，用于表示一个字符。字符串所有的属性与方法(如length属性与charAt() 方法等)都是基于16位序列 最常用的Unicode字符使用16位序列编码字符，属于“基本多语种平面”(Basic Multilingual Plane BMP)，也称为“零断面”(plan 0)， 是Unicode中的一个编码区段，编码介于\u0000~\uFFFF之间。超过这个范围的码位则要归属于某个辅助平面或称为扩展平面(supplementary plane)，其中的码位仅用16位就无法表示了 为此，UTF-16引入了代理对(surrogate pairs)，规定用两个16位编码来表示一个码位。这意味着，字符串里的字符有两种：一种由一个码元（共 16 位）来表示BMP字符，另一种用两个码元（共 32 位）来表示辅助平面字符 12345678let text = &apos;?&apos;console.log(text.length); //2console.log(/^.$/.test(text)); //falseconsole.log(text.charAt(0)); //�console.log(text.charAt(1)); //�console.log(text.charCodeAt(0)); //55362console.log(text.charCodeAt(1)); //57271 这个字?（jí）其实就是一个两个16位字符组成的字,基于16位字符串的属性与方法便失效了 codePointAt() 只接受编码单元的位置而非字符位置作为参数,返回给定位置对应的码位123456789let text = &apos;a?&apos;console.log(text.charCodeAt(0)); //55362console.log(text.charCodeAt(1)); //57271console.log(text.charCodeAt(2)); //57271console.log(text.codePointAt(0)); //134071console.log(text.codePointAt(1)); //57271console.log(text.codePointAt(2)); //57271 通过这个方法我们可以检测字符是不是32位的 1234567function is32Bit(char)&#123; return char.codePointAt(0) &gt; 0xffff; &#125;console.log(is32Bit(&apos;?&apos;)); //tureconsole.log(is32Bit(&apos;a&apos;)); //false String.fromCodePoint()通过码位获得对应字符1console.log(String.fromCodePoint(134071)); //? normalize() 许多欧洲语言有语调符号和重音符号。为了表示它们，Unicode提供了两种方法。一种是直接提供带重音符号的字符，比如Ǒ（\u01D1）。另一种是提供合成符号（combining character），即原字符与重音符号的合成，两个字符合成一个字符，比如O（\u004F）和ˇ（\u030C）合成Ǒ（\u004F\u030C）。这两种表示方法，在视觉和语义上都等价，但是JavaScript不能识别。 12345&apos;\u01D1&apos;===&apos;\u004F\u030C&apos; //false&apos;\u01D1&apos;.length // 1&apos;\u004F\u030C&apos;.length // 2&apos;\u01D1&apos;.normalize() === &apos;\u004F\u030C&apos;.normalize() // true NFC，默认参数，表示“标准等价合成”（Normalization Form Canonical Composition），返回多个简单字符的合成字符。所谓“标准等价”指的是视觉和语义上的等价。 NFD，表示“标准等价分解”（Normalization Form Canonical Decomposition），即在标准等价的前提下，返回合成字符分解的多个简单字符。 NFKC，表示“兼容等价合成”（Normalization Form Compatibility Composition），返回合成字符。所谓“兼容等价”指的是语义上存在等价，但视觉上不等价，比如“囍”和“喜喜”。（这只是用来举例，normalize方法不能识别中文。） NFKD，表示“兼容等价分解”（Normalization Form Compatibility Decomposition），即在兼容等价的前提下，返回合成字符分解的多个简单字符 正则表达式u修饰符123let text = &apos;?&apos;console.log(/^.$/.test(text)); //falseconsole.log(/^.$/u.test(text)); //true 计算码位的数量12345678910function codePointLength(text)&#123; let result = text.match(/[\s\S]/gu); return result ? result.length : 0;&#125;console.log(codePointLength(&quot;123a&quot;)); //4console.log(codePointLength(&quot;?a&quot;)); //2console.log(codePointLength(&quot;?哦&quot;)); //2//emmmmm。运行效率蛮低，听说有更简单的，后面演示 字符串中子串的识别includes(x,y)检测指定字符串返回boolean值，第二参数是开始位置(0开始数)12345let text = &quot;adsdasdasgsgwefsfs&quot;;let subtext = &apos;asd&apos;;console.log(text.includes(subtext,4)) //trueconsole.log(text.includes(subtext)) //trueconsole.log(text.includes(&apos;sdadasda&apos;)) //false startsWith(x,y) 和 endsWith(x,y) 检测字符串开头和结尾的是否与子串相匹配,第二参数是开始位置(0开始数)123456789101112let text = &quot;adsdasdasgsgwefsfs&quot;;let subtext1 = &apos;ads&apos;;let subtext2 = &apos;sfs&apos;;console.log(text.startsWith(&apos;asd&apos;,4)) //trueconsole.log(text.startsWith(subtext1)) //trueconsole.log(text.startsWith(&apos;sdadasda&apos;)) //falseconsole.log(text.endsWith(&apos;gsgwefsfs&apos;,18)) //true 以最后一个字母的位置为准console.log(text.endsWith(subtext2)) //trueconsole.log(text.endsWith(&apos;sdadasda&apos;)) //false repeat() 接受一个number,即将字符重复的次数123console.log(&apos;x&apos;.repeat(6)); // xxxxxxconsole.log(&apos;ly&apos;.repeat(3)); //lylylyconsole.log(&apos;爱&apos;.repeat(2)); //爱爱 正则的语法变更 （蛮头疼的,正则还是晕乎乎的）正则表达式y修饰符 除了u 修饰符，ES6还为正则表达式添加了 y 修饰符，叫做“粘连”修饰符。y 修饰符的作用与 g 修饰符类似，也是全局匹配，后一次匹配都从上一次匹配成功的下一个位置开始。不同之处在于，g 修饰符只要剩余位置中存在匹配就可，而 y 修饰符确保匹配必须从剩余的第一个位置开始，这也就是“粘连”的含义，当为匹配到时，将会返回空，lastIndex将会置为0 12345678910111213141516171819var s = &apos;aaa_aa_a&apos;; var r1 = /a+/g; var r2 = /a+/y; console.log(r1.exec(s)) //[&quot;aaa&quot;, index: 0, input: &quot;aaa_aa_a&quot;] console.log(r2.exec(s)) //[&quot;aaa&quot;, index: 0, input: &quot;aaa_aa_a&quot;]console.log(r1.lastIndex) //3console.log(r2.lastIndex) //3console.log(r1.exec(s)) //[&quot;aa&quot;, index: 4, input: &quot;aaa_aa_a&quot;]console.log(r2.exec(s)) //null console.log(r1.lastIndex) //6console.log(r2.lastIndex) //0console.log(r1.exec(s)) //[&quot;a&quot;, index: 7, input: &quot;aaa_aa_a&quot;]console.log(r2.exec(s)) //[&quot;aaa&quot;, index: 0, input: &quot;aaa_aa_a&quot;] console.log(r1.lastIndex) //8console.log(r2.lastIndex) //3 检测y修饰符是否存在 123let pattern = /hello\d/y;console.log(pattern.sticky) //true 谷歌浏览器下 正则表达式的复制 es5 如下复制 123var re1 = /ab/i re2 = new RegExp(re1); console.log(re1.construct === re2.construct) //true es6新增了可以添加传修饰符 1234var re1 = /ab/i re2 = new RegExp(re1,&apos;g&apos;); console.log(re1.toString()) ///ab/i console.log(re2.toString()) ///ab/g flags属性 source获取正则表达式文本 flags获取其修饰符 12345let re = /ab/gi;console.log(re.source); //abconsole.log(re.flags); //gi 模板字面量 JS 的字符串相对其他语言来说功能总是有限的，事实上，ES5中一直缺乏许多特性，如多行字符串、字符串格式化、HTML转义等。ES6通过模板字面量的方式进行了填补，模板字面量试着跳出JS已有的字符串体系，通过一些全新的方法来解决类似的问题 反引号（）12345678910111213141516171819const name = &apos;ly&apos;;let message = `$&#123;name&#125;,is a man` //ly,is a manconsole.log(message);//$&#123;&#125; 可以写变量 名叫字符串占位符console.log(`\`hh\``); //`hh`//es5 实现多行文本var message = &quot; ly \n \ love you&quot;console.log(message);//es6var message = ` ly love you`console.log(message); // ly // love you 字符串占位符 ${javascript表达式}1234let count = 15, price = .5, message = `$&#123;count&#125; items cost $$&#123;(count*price).toFixed(1)&#125;`; console.log(message); //15 items cost $7.5 标签模板 标签模板其实不是模板，而是函数调用的一种特殊形式。“标签”指的是函数，紧跟在后面的模板字符串就是它的参数 1234var a = 5;var b = 10;tag `Hello $&#123;a+b&#125; world $&#123;a*b&#125;`;//这个标识名tag,它是一个函数。整个表达式的返回值，就是tag函数处理模板字符串之后的返回值。函数tag会依次接收到多个参数。 tag函数的第一个参数是一个数组，该数组的成员时模板字符串中那些没有变量替换的部分，也就是说，变量替换只发生在数组的第一个成员和第二个成员之间，以此类推。tag函数的其他参数都是模板字符串各个变量被替换后的值，由于本例中，模板字符串含有两个变量，因此tag会接收到value1和value2两个参数。tag函数所有参数的实际值如下：——第一个参数：[‘Hello ‘,’ world ‘,’’]——第二个参数：15——第三个参数：50也就是说tag函数实际上是以下面的形式调用的tag([‘Hello ‘,’ world ‘,’’],15,50);我们可以按照需要编写tag 函数的代码。 1234567891011121314151617181920var count = 5;var price = 10;function tag(s,v1,v2,v3)&#123; console.log(s[0]); console.log(s[1]); console.log(s[2]); console.log(s); console.log(v1); console.log(v2); return &apos;ok&apos;&#125;tag`q$&#123;count&#125; items cost $$&#123;(count*price).toFixed(1)&#125;.`;//VM173:5 //VM173:6 items cost $//VM173:7 .//VM173:8 5//VM173:9 50.0//ok 标签函数的常用形式 1234function tag(literals,...substitutions)&#123; //literals 值得是被$&#123;&#125;隔开的字符 //substitutions，有几个$&#123;&#125;就有几个这个&#125; 利用 literals.length-1 === substitutions.length,拼接字符串 12345678910111213function passthru(literals,...values)&#123; var output =&quot;&quot;; for(var index = 0;index&lt;values.length;index++)&#123; output = literals[index]+values[index]; &#125; output+=literals[index]; return output;&#125;let count = 15, price = .5, message = passthru`$&#123;count&#125; items cost $$&#123;(count*price).toFixed(1)&#125;`; console.log(message); //15 items cost $7.5 what?这样做的意义是啥？ emmm,过滤html字符串,还有一些转义字符的过滤 123456789101112131415161718function SaferHTML(templateData)&#123; var s = templateData[0]; var i; for(i = 1;i&lt;arguments.length;i++)&#123; var arg = String(arguments[i]); //sender里面可能有特殊字符，进行转义 s += arg.replace(/&amp;/g,&quot;&amp;amp;&quot;) .replace(/&lt;/g,&quot;&amp;lt;&quot;) .replace(/&gt;/g,&quot;&amp;gt;&quot;); s += templateData[i]; &#125; console.log(i);//2，表示这个循环只执行了一次，因为templateData[0]=&quot;&lt;p&gt;&quot;,arguments这个数组只有$&#123;sender&#125;这个元素，后面一长串字符都是templateData[2]; return s;&#125;var sender = &apos;&lt;script&gt;alert(&quot;abc&quot;)&lt;/script&gt;&apos;;var message = SaferHTML`&lt;p&gt;$&#123;sender&#125; has sent you a message.&lt;/p&gt;`;console.log(message); 在模板字面量中使用原始值 使用内建对象String.raw访问 12345678let ms1 = `ly\n love you`let ms2 = String.raw`ly\n love you`console.log(ms1); //ly //love youconsole.log(ms2); // ly\n love you]]></content>
      <tags>
        <tag>es6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[es6-块级作用域绑定]]></title>
    <url>%2F2018%2F01%2F24%2Fes6-%E5%9D%97%E7%BA%A7%E4%BD%9C%E7%94%A8%E5%9F%9F%E7%BB%91%E5%AE%9A%2F</url>
    <content type="text"><![CDATA[前言 花点时间重新复习一遍es6的语法 我的博客地址 ：http://www.aymfx.cn/ var，let, const 三者的区别 var 声明的变量会有变量提升的过程，将被提升到作用域的顶部，或者函数的顶部 let 声明的变量，只能在声明的块作用域中访问和使用，存在于函数内部以及花括号之间的区域 12345&#123; let a = 3;&#125;console.log(a); //a is not defined 1234function()&#123; let a = 3;&#125;console.log(a); //a is not defined const 是用来声明静态变量的，一但设置了值之后就不可改变123const a = 20;a= 60;//Assignment to constant variable. const在对象中是绑定了这个对象，但是对象的内容是可以改变的123const a = &#123;length:2&#125;a.length = 6; var 可以重复声明变量 let和const声明的变量不能重新声明123var count = 30;let count = 40;VM49:2 Uncaught SyntaxError: Identifier &apos;count&apos; has already been declared 临时死区let和const不会出现变量提升的情况，未定义的值将直接报错,也就产生所谓的临时死区 1234if(true)&#123; console.log(typeof value); //alue is not defined let value = &quot;blue&quot;&#125; 注意这种情况 12345console.log(typeof value); //alue is not definedif(true)&#123; let value = &quot;blue&quot;&#125; 循环中的块级作用域绑定123456var fun = [];for(var i = 0;i&lt;10;i++)&#123; fun.push(function()&#123;console.log(i)&#125;)&#125;fun.forEach(function(f)&#123;f()&#125;) //0VM118:3 10 上面代码输出了10个10,不对的，我们期待是0-9，改成这样的话 123456let fun = [];for(let i = 0;i&lt;10;i++)&#123; fun.push(function()&#123;console.log(i)&#125;)&#125;fun.forEach(function(f)&#123;f()&#125;) //0VM118:3 10 以上写法对于 for-in 以及for-of 同样适用 循环中使用const声明 这样会报错 123456var f = [];for(const i =0;i&lt;10;i++)&#123; f.push(function()&#123; console.log(i); &#125;)&#125; //Assignment to constant variable 但是 for-in 和for-of，由于是绑定元素不会报错，上面在第二次循环修改了变量的值导致报错 12345678910111213141516var f = [];obj = &#123; a:1, b:2, c:3&#125;for(const key in obj)&#123; f.push(function()&#123; console.log(key); &#125;)&#125;f.forEach(function(f)&#123;f()&#125;) //a//VM184:10 b//VM184:10 c 12345678910f= [&apos;1&apos;,2,4,5]for(const key of f)&#123; console.log(key);&#125;//VM204:4 1//VM204:4 2//VM204:4 4//VM204:4 5 全局作用域的绑定 var 在全局中相当于添加了window对象的属性，但是有可能误操作覆盖了已有的全局属性 123console.log(window.RegExp); //ƒ RegExp() &#123; [native code] &#125;var RegExp = &quot;正则表达式&quot;console.log(window.RegExp); //正则表达式 相对于var来说let和const不会创建一个新的绑定,他会屏蔽window的属性，而不是添加或者覆盖window的属性 1234console.log(window.RegExp); //ƒ RegExp() &#123; [native code] &#125;let RegExp = &quot;正则表达式&quot;console.log(window.RegExp); //ƒ RegExp() &#123; [native code] &#125;console.log(RegExp) //正则表达式]]></content>
      <tags>
        <tag>es6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[给自己的网站设置https认证(nginx服务器)]]></title>
    <url>%2F2018%2F01%2F17%2F%E7%BB%99%E8%87%AA%E5%B7%B1%E7%9A%84%E7%BD%91%E7%AB%99%E8%AE%BE%E7%BD%AEhttps%E8%AE%A4%E8%AF%81-nginx%E6%9C%8D%E5%8A%A1%E5%99%A8%2F</url>
    <content type="text"><![CDATA[网站进行认证操作1 进入腾讯云选择ssl安装服务 下载证书 包含如下东西 Nginx文件夹内获得SSL证书文件 1_www.domain.com_bundle.crt 和私钥文2_www.domain.com.key 1_www.domain.com_bundle.crt 文件包括两段证书代码 “—–BEGIN CERTIFICATE—–”和“—–END CERTIFICATE—–”, 2_www.domain.com.key 文件包括一段私钥代码“—–BEGIN RSA PRIVATE KEY—–”和“—–END RSA PRIVATE KEY—–”。 证书安装 文件配置 vim /usr/local/nginx/conf/nginx.conf 这是官方示例123456789101112131415server &#123; listen 443; server_name www.domain.com; #填写绑定证书的域名 ssl on; ssl_certificate 1_www.domain.com_bundle.crt; ssl_certificate_key 2_www.domain.com.key; ssl_session_timeout 5m; ssl_protocols TLSv1 TLSv1.1 TLSv1.2; #按照这个协议配置 ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:HIGH:!aNULL:!MD5:!RC4:!DHE;#按照这个套件配置 ssl_prefer_server_ciphers on; location / &#123; root html; #站点目录 index index.html index.htm; &#125; &#125; 配置参数配置文件参数 说明listen 443 SSL访问端口号为443ssl on 启用SSL功能ssl_certificate 证书文件ssl_certificate_key 私钥文件ssl_protocols 使用的协议ssl_ciphers 配置加密套件，写法遵循openssl标准 重启 /usr/local/nginx/sbin/nginx -s reload ###如图]]></content>
      <tags>
        <tag>node</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux下安装mysql]]></title>
    <url>%2F2018%2F01%2F16%2Flinux%E4%B8%8B%E5%AE%89%E8%A3%85mysql%2F</url>
    <content type="text"><![CDATA[前言 node有对mysql操作的插件，可以先装起来用，下节我会装好mongose，这是非关系型数据库，很适合node 下载最新版 wget https://cdn.mysql.com//Downloads/MySQL-5.7/mysql-5.7.21-linux-glibc2.12-x86_64.tar.gz 解压进入文件夹 tar -zxvf mysql-5.7.21-linux-glibc2.12-x86_64.tar.gz cd mysql-5.7.21-linux-glibc2.12-x86_64 添加用户组和用户 添加用户组 groupadd mysql 添加用户mysql 到用户组mysql useradd -g mysql mysql 创建放数据的文件库 mkdir -p ./data/mysql 5.初始化mysql ./bin/mysqld –user=root –basedir=./data –datadir=./data/mysql –initialize (检查好路劲对不对，基本常识哈) 报错了,出现如下情况 Centos系统执行:yum -y install numactl ubuntu: sudo apt-get install numactl 6.初始化成功并且初始密码出来了 7.建立配置文件 cd support-files vim mysql.server 修改成如下 8.拷贝到系统目录 cp mysql.server /etc/init.d/mysqld chkconfig –add mysqld 启动 service mysqld start/stop(这是停止哈，别傻乎乎写上去) 呀，报错了 解决方式 百度了下似乎是权限不够无法读取文件于是采用了百度推荐的方式 mkdir -p /var/log/mariadb/ cd /var/log/mariadb/ touch mariadb.log chmod -R 775 mariadb.log chown -R mysql:mysql mariadb.log 再一次运行命令service mysqld start 又报错了 又是权限问题 mkdir /var/lib/mysql chmod 777 /var/lib/mysql agian 妈呀，又报错了 没办法删除了etc/my.cnf rm -rf /etc/my.cnf 成功 开心 设置全局的mysql vim ./etc/profile source ./etc/profile 修改初始化密码 mysql -uroot -p 如图键入命令修改 后记 mysql是我比较恐惧的一块，在window安装我都老是出问题，第一次只花了3个小时装完了感觉很开心，嘿嘿，睡觉了，明天还要上班。]]></content>
      <tags>
        <tag>node</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux环境下安装nginx]]></title>
    <url>%2F2018%2F01%2F15%2Flinux%E7%8E%AF%E5%A2%83%E4%B8%8B%E5%AE%89%E8%A3%85nginx%2F</url>
    <content type="text"><![CDATA[前言 由于需要我自己有几个二级域名需要配置，还有多起几个node服务用nginx做方向代理，使得二级域名可以访问自己所在的目录 安装 安装gcc（centos 7之后一般已自带，可以在第6步失败后再安装） yum install gcc gcc-c++ 安装pcre yum install -y pcre pcre-devel 安装zlib yum install -y zlib zlib-devel 安装openssl yum install -y openssl openssl-devel 下载并解压Nginx（之后进入Nginx目录 wget http://nginx.org/download/nginx-1.9.8.tar.gz //(可以装最新版本) tar zxvf nginx-1.9.8.tar.gz cd zxvf nginx-1.9.8 编译Nginx（加载常用模块如ssl） ./configure –prefix=/usr/local/nginx &gt;–with-http_stub_status_module –with-http_gzip_static_module &gt;–with-http_ssl_module 安装Nginx make &amp;&amp; make install 启动 /usr/local/nginx/sbin/nginx 停止 /usr/local/nginx/sbin/nginx -s stop（reload表示重启） 浏览器访问Nginx所在机器IP，验证Nginx启动成功 http://yourhost/ 注：Nginx配置文件位置 /usr/local/nginx/conf/nginx.conf ##修改配置文件实现反向代理 1.进入配置文件 vim /usr/local/nginx/conf/nginx.conf 找到下面的地方 标红的地方进行修改，其余注释 浏览器显示]]></content>
      <tags>
        <tag>node</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用linux服务器搭建node环境（安装node）]]></title>
    <url>%2F2018%2F01%2F13%2F%E7%94%A8linux%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BAnode%E7%8E%AF%E5%A2%83%EF%BC%88%E5%AE%89%E8%A3%85node%EF%BC%89%2F</url>
    <content type="text"><![CDATA[前言 双十一买了台服务，装的是linux系统，配置比较低，但是自己个人学习还是够用了。 准备 安装的服务 node nginx mysql mongose 安装node 下载最新版本的node ==wget https://npm.taobao.org/mirrors/node/v9.4.0/node-v9.4.0-linux-x64.tar.gz== 解压 ==tar -xvf node-v9.4.0-linux-x64.tar.gz== 进入页面查看是否安装好了 ==cd node-v9.4.0-linux-x64/bin== ==./node -v== //查看版本 添加全局变量 ==vim /etc/profile== 添加下面两条 (大家按实际的路径来走) 我的路径如下 ==export NODE_HOME=/usr/local/ly/node/node-v9.4.0-linux-x64== ==export PATH=$NODE_HOME/bin:$PATH== 编译 ==source /etc/profile== 验证是否成功 ==node -v== pm2的安装 pm2 是一个带有负载均衡功能的Node应用的进程管理器.当你要把你的独立代码利用全部的服务器上的所有CPU，并保证进程永远都活着，0秒的重载， PM2是完美的。它非常适合IaaS结构，但不要把它用于PaaS方案（随后将开发Paas的解决方案） pm2常用命令 $ npm install pm2 -g # 命令行安装 pm2 $ pm2 start app.js -i 4 后台运行pm2，启动4个app.js 也可以把’max’ 参数传递给 start 正确的进程数目依赖于Cpu的核心数目 $ pm2 start app.js –name my-api # 命名进程 $ pm2 list # 显示所有进程状态 $ pm2 monit # 监视所有进程 $ pm2 logs # 显示所有进程日志 $ pm2 stop all # 停止所有进程 $ pm2 restart all # 重启所有进程 $ pm2 reload all # 0秒停机重载进程 (用于 NETWORKED 进程) $ pm2 stop 0 # 停止指定的进程 $ pm2 restart 0 # 重启指定的进程 $ pm2 startup # 产生 init 脚本 保持进程活着 $ pm2 web # 运行健壮的 computer API endpoint $ pm2 delete 0 # 杀死指定的进程 $ pm2 delete all # 杀死全部进程 安装pm2并且调试下 安装淘宝镜像 ==npm install -g cnpm –registry=https://registry.npm.taobao.org== 全局安装pm2 ==cnpm i -g pm2== 是否安装成功 pm2 -v 跑一个小型服务器 在linux下创建一个demo文件夹 cd demo 创建一个app.js 文件 内容如下 pm2 start app.js 浏览器访问如下 下一接我们继续]]></content>
      <tags>
        <tag>node</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webpack笔记2]]></title>
    <url>%2F2018%2F01%2F11%2Fwebpack%E7%AC%94%E8%AE%B02%2F</url>
    <content type="text"><![CDATA[]]></content>
  </entry>
  <entry>
    <title><![CDATA[webpack笔记1]]></title>
    <url>%2F2018%2F01%2F10%2Fwebpack%E7%AC%94%E8%AE%B01%2F</url>
    <content type="text"><![CDATA[前言==划一划重点== 新的一年了，不知不觉已经踏入前端这么久了，但是技术还是没什么&gt;长进，每天虽然忙碌着，但是基本就是停留在会用这些东西的基础上，擅&gt;长复制粘贴，擅长解决bug,自己只会拿别人的框架组装东西，没有考虑这&gt;东西比较深层次的东西，前端的东西变化的很快，公司业务虽然不复杂，&gt;但是未来需要面对很多新的挑战，我需要学习更多的东西。毕业的几年应&gt;该是学习最快的时间段，我应该更加努力了，嘿嘿。 开始学习啦起步 初始化安装一个环境,创建一个文件夹，在文件夹里面运行cmd 12npm init -y //建立一个package.json文件npm i -D webpack //本地安装webpack,还可以全局安装，本地安装适合移植 项目目录 buid : 编译后的目录 src : 源目录 需要编译的目录 123456789101112131415目录结构:src/index.js需要的依赖:cnpm i lodash -S代码:import _ from "lodash"; //要引入的依赖function component() &#123; var element = document.createElement('div'); // Lodash（目前通过一个 script 脚本引入）对于执行这一行是必需的 element.innerHTML = _.join(['Hello', 'webpack'], ' '); return element; &#125; document.body.appendChild(component()); 123456789101112131415161718192021目录结构:html代码:&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; 测试 &lt;script src="./build/index.js"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 编译命令 npx webpack src/index.js build/index.js 或者 webpack src/index.js build/index.js 最后在build生成了打包好的文件index.js,这就是js打包，可以将有依赖关系的js文件打包在一个包里 配置文件编译1234567891011 //webpack.config.js const path = require("path"); module.exports = &#123; entry:'./src/index.js', // 入口文件路径 output:&#123; //出口 filename:'index.js',//出口文件名 path:path.resolve(__dirname,'build')//输出路径 &#125;&#125;//命令行运行 webapck,就可以编译命令了 或者用命令行指定某个配置文件 webpack --config webpack.config.js 将命令写在根目录的package.json 上12345678910111213141516171819&#123; "name": "wepack-study", "version": "1.0.0", "description": "", "main": "index.js", "scripts": &#123; "test": "echo \"Error: no test specified\" &amp;&amp; exit 1", "start":"wepack --config webpack.config.js" //json不能写注释，复制后请删除， 这里写命令行 &#125;, "keywords": [], "author": "", "license": "ISC", "devDependencies": &#123; "webpack": "^3.10.0" &#125;, "dependencies": &#123; "lodash": "^4.17.4" &#125;&#125; npm start //直接可以编译]]></content>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA['苹果不兼容js的Date解决方式']]></title>
    <url>%2F2017%2F11%2F06%2F%E8%8B%B9%E6%9E%9C%E4%B8%8D%E5%85%BC%E5%AE%B9js%E7%9A%84Date%E8%A7%A3%E5%86%B3%E6%96%B9%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[活动出的问题| 写活动的时候遇到了个坑，就是在苹果上将2017-11-06转成时间戳，返回的是NaN，安卓没啥问题。 百度一下问题 iPhone中的safari无法解释 YYYY-MM-DD HH:mm:ss 或者YYYY/MM/DD HH:mm:ss这样的时间格式，而谷歌火狐等浏览器对这样的格式做了扩展， iPhone中的safari所支持的格式为 YYYY,MM,DD,HH,mm,ss， 解决方式，自己转呗12345678910111213141516171819202122232425262728/** * @method startActivity 计算活动开始时间 * * @param &#123;String&#125; endTime 传入的是一个纯字符串，比如"2017/10/17 00:00:00:00" 或者 "2017-10-17" * * @return &#123;Boolean&#125; true表示活动开始，false表示活动还未开始 * */ var getStartActivity = function (endTime) &#123; var nowTimestamp = Date.now(); console.log(endTime); var endTimestamp = (function (endTime) &#123; if (!(/:/.test(endTime))) &#123; // debugger; // console.log(endTime); endTime += " 00:00:00:00"; console.log(endTime); var arr = endTime.split(/[- : \/]/), endTime = new Date(arr[0], arr[1]-1, arr[2], arr[3], arr[4], arr[5]); &#125; return endTime.getTime(); &#125;)(endTime); if (nowTimestamp &lt; endTimestamp) &#123; return false; &#125; return true; &#125;]]></content>
      <tags>
        <tag>js兼容</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[node_Demo]]></title>
    <url>%2F2017%2F10%2F17%2Fnode-Demo%2F</url>
    <content type="text"><![CDATA[file-explorer12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970var fs = require("fs"), stdin = process.stdin, stdout = process.stdout, stats = [];fs.readdir(process.cwd(), function(err, files) &#123; console.log(' '); if (!files.length) &#123; return console.log("没有文件"); &#125; console.log("请选择文件或者目录"); function file(i) &#123; var filename = files[i]; fs.stat(__dirname + '/' + filename, function(err, stat) &#123; //fs.stat()检测一个文件是否存在 if (stat.isDirectory()) &#123; console.log(' ' + i + ' \033[90m' + filename + '/\033[39m'); stats[i] = stat; &#125; else &#123; console.log(' ' + i + ' \033[90m' + filename + '\033[39m'); &#125; i++; if (i == files.length) &#123; read(); &#125; else &#123; file(i) &#125; &#125;) &#125; file(0); // 当用户输入时，读取用户输入的值 function read() &#123; console.log(''); stdout.write(' \033[33mEnter your choice: \033[39m'); stdin.resume(); //标准输入流默认是暂停 (pause) 的，所以必须要调用 process.stdin.resume() 来恢复 (resume) 接收,这里用来等待用户输入 stdin.setEncoding('utf-8'); stdin.on('data', option); &#125; function option(data) &#123; var filename = files[Number(data)]; if (!filename) &#123; stdout.write(" \033[31mEnter your choice: \033[39m"); &#125; else &#123; stdin.pause(); if(stats[Number(data)].isDirectory)&#123; fs.readdir(__dirname + '/' + filename,'utf-8',function(err,files)&#123; console.log(''); console.log(' ('+files.length+'files)'); files.forEach(function(file)&#123; console.log(' - '+file); &#125;) &#125;) &#125;else&#123; fs.readFile(__dirname + '/' + filename,'utf-8',function(err,data)&#123; console.log(''); console.log("\033[90m"+data.replace(/(.*)/g,' 56+3$1')+"\033[39m"); &#125;) &#125; &#125; &#125;&#125;) tcp-chat123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081/** * 模块依赖 */var net = require('net');var count = 0, users = &#123;&#125;;/** * 创建服务器 */var server = net.createServer(function(conn) &#123; //handle connection console.log("\033[96m new Server Connection.... \033[39m"); count++; // console.log(conn); conn.setEncoding("utf-8"); conn.write("welcome to " + count + " panter" + "\n \033[96mplease write your name enter: \033[39m"); // 代表当前链接的昵称 var nickname; //接受客户端传来的消息 conn.on("data", function(data) &#123; data = data.replace(/\r\n/g, ''); console.log(data,66); if (!nickname) &#123; if (users[data]) &#123; conn.write("nickname is already in use , try again "); return; &#125; else &#123; nickname = data; users[nickname] = conn; broadcast('\033[96m' + nickname +"said:\033[39m"+data+'\n',false) &#125; &#125;else &#123; broadcast('\033[96m' + nickname +"said:\033[39m"+data+'\n',true) &#125; &#125;) // //关闭时触发 conn.on('close', function() &#123; count--; delete users[nickname] broadcast('\033[96m' + nickname +"left room now \033[39m"+'\n') &#125;) function broadcast (msg,expectMyself) &#123; for(var i in users) &#123; if(!expectMyself || i!=nickname) &#123; users[i].write(msg) &#125; &#125; &#125;&#125;)/** * @Author ly * @method [listen] * @description [description] * @DateTime 2017-10-18 * @copyright [copyright] * @license [license] * @param &#123;[type]&#125; * @return &#123;[type]&#125; */server.listen(4000, function() &#123; console.log("\033[96m server Listen on 4000 \033[39m");&#125;) tcp-server123456789101112131415161718192021222324252627282930313233343536var qs = require('querystring');require("http").createServer(function(req,res)&#123; res.writeHead(200,&#123;"Content-Type":"text/html;charset=utf-8"&#125;); console.log(req.url); if('/'== req.url)&#123; res.end([ '&lt;form method="POST" action="/action"&gt;', '&lt;h1&gt;my form&lt;/h1&gt;', '&lt;fieldset&gt;', '&lt;legend&gt;personal information&lt;/legend&gt;', '&lt;p&gt;What is your name?&lt;/p&gt;', '&lt;input type="text" name="name"/&gt;', '&lt;p&gt;&lt;input type="submit" name="submit" value="提交"/&gt;&lt;/p&gt;', '&lt;/fieldset&gt;', '&lt;/form&gt;' ].join('')) &#125; else if('/action' == req.url &amp;&amp; 'POST' == req.method)&#123; var body = ''; req.on('data',function(chunk)&#123; body+=chunk; &#125;); req.on('end',function()&#123; res.write('&lt;p&gt; Your name is &lt;b&gt;'+qs.parse(body).name+'&lt;b&gt;&lt;/p&gt;'); res.end('&lt;p&gt;Content-Type:'+req.headers['content-type']+'&lt;/p&gt;' +'&lt;p&gt;Data:&lt;/p&gt;&lt;pre&gt;'+body+'&lt;/pre&gt;'); &#125;) &#125; else &#123; res.writeHead(404); res.end('&lt;h1&gt;Not Found&lt;/h1&gt;'); &#125; &#125;).listen(4000);]]></content>
      <tags>
        <tag>node</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[echart的柱状图和饼图的demo]]></title>
    <url>%2F2017%2F10%2F13%2Fechart%E7%9A%84%E6%9F%B1%E7%8A%B6%E5%9B%BE%E5%92%8C%E9%A5%BC%E5%9B%BE%E7%9A%84demo%2F</url>
    <content type="text"><![CDATA[柱状图123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src="./js/adaptive.js"&gt;&lt;/script&gt; &lt;!-- 引入 ECharts 文件 --&gt; &lt;script src="./js/echarts.js"&gt;&lt;/script&gt; &lt;link rel="stylesheet" href="./css/index.css"&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 为 ECharts 准备一个具备大小（宽高）的 DOM --&gt; &lt;div id="main"&gt; &lt;/div&gt; &lt;script type="text/javascript"&gt; // 基于准备好的dom，初始化echarts实例 var myChart = echarts.init(document.getElementById('main')); // 指定图表的配置项和数据 option = &#123; xAxis: [&#123; type: 'category', show: true, data: (function()&#123; var a = ['2017年7月', '2017年8月', '2017年9月'], s = []; for (var i = 0; i &lt; a.length; i++) &#123; s.push(&#123; value: a[i], // 突出周一 textStyle: &#123; fontSize: 24, color: '#ddd' &#125; &#125;) &#125; return s; &#125;)(), boundaryGap: true, axisTick: &#123; alignWithLabel: false &#125;, &#125;], yAxis: [&#123; show: false &#125;], series: [&#123; name: 'ECharts例子个数统计', type: 'bar', itemStyle: &#123; normal: &#123; color: function(params) &#123; // build a color map as your need. var colorList = [ '#fc9434', '#ff4950', '#00b0ec', ]; return colorList[params.dataIndex] &#125;, label: &#123; show: true, position: 'top', distance:'20', formatter: '&#123;c&#125;', textStyle: &#123; fontSize: 24, fontWeight: 'bold', &#125;, &#125;, &#125; &#125;, data: [80208929.00, 106432366, 89371857.00], barWidth: '40%', barGap: '1%', &#125;] &#125;; // 使用刚指定的配置项和数据显示图表。 myChart.setOption(option); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 柱状图123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src="./js/adaptive.js"&gt;&lt;/script&gt; &lt;!-- 引入 ECharts 文件 --&gt; &lt;script src="./js/echarts.js"&gt;&lt;/script&gt; &lt;link rel="stylesheet" href="./css/index.css"&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 为 ECharts 准备一个具备大小（宽高）的 DOM --&gt; &lt;div id="main"&gt; &lt;/div&gt; &lt;script type="text/javascript"&gt; // 基于准备好的dom，初始化echarts实例 var myChart = echarts.init(document.getElementById('main')); // 指定图表的配置项和数据 option = &#123; tooltip : &#123; trigger: 'item', formatter: "&#123;a&#125; &lt;br/&gt;&#123;b&#125; : (&#123;c&#125;%)", textStyle:&#123; fontSize:24, &#125; &#125;, color:['#7057d3', '#8f79eb','#b09ffa'], series : [ &#123; name:'投资比例', type:'pie', radius : [150, 280], center : ['50%', 400], roseType : 'area', x: '50%', // for funnel max: 80, // for funnel sort : 'ascending', // for funnel data:[ &#123;value:16.20, name:'90天'&#125;, &#123;value:23.06, name:'60天'&#125;, &#123;value:41.95, name:'30天'&#125;, ] &#125; ], textStyle:&#123; fontSize:30, fontWeight:700, color:'#000' &#125;&#125;; // 使用刚指定的配置项和数据显示图表。 myChart.setOption(option); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <tags>
        <tag>echarts</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[node.js深入浅出笔记17]]></title>
    <url>%2F2017%2F09%2F29%2Fnode-js%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E7%AC%94%E8%AE%B017%2F</url>
    <content type="text"><![CDATA[页面渲染##内容响应 MIME用于判断文件类型 12345678910//这个插件可以自动转换var mine = require('mime')mime.lookup("/xx/xx/file.txt") =======&gt; 'text/plain'mime.lookup("file.txt") =======&gt; 'text/plain'mime.lookup(".txt") =======&gt; 'text/plain'mime.lookup(".html") =======&gt; 'text/html' ...... 响应附件的下载，通过Content-Disposition字段 Content-Disposition:attachment;filename=’filename.ext’ 123456789101112131415161718192021222324252627res.sendfile = function (filepath) &#123; fs.stat(filepath,function(err,stat)&#123; var stream = fs.createReadStream(filepath); //设置内容 res.setHeader('Content-Type',mime.lookup(filepath)); //设置长度 res.setHeader("Content-Length",stat.size); //设置为附件 res.setHeader('Content-Disposition','attachement;filename="'+path.basename(filepath)+'"'); res.writeHead(200); stream.pipe(res); &#125;)&#125;``` &gt; 响应JSON``` javascript res.json = function (json) &#123; res.setHeader('Content-Type','application/json'); res.writeHead(200); res.end(JSON.stringify(json)) &#125; 响应跳转 123456res.json = function (url) &#123; res.setHeader('Location',url); res.writeHead(302); res.end('Redirect to ' + url)&#125; 视图渲染 模板是带有特殊标签的html片段，通过数据的渲染，将数据填充到这些特殊的标签中，最后生成普通的带有数据的html片段，我们将其设计为render,参数就是模板的路径和数据 12345678res.render = function (view,data) &#123; res.setHeader('Content-Type','text/html'); res.writeHead(200); //实际渲染 var html = render(view,data); res.end(html);&#125; 模板引擎渲染的方式 模板引擎渲染简单演示 12345678910111213141516var render = function (str,data) &#123; //模板技术就是替换特殊标签的技术 var tpl = str.replace(/&lt;%=([\s\S]+?)%&gt;/g,function(match,code)&#123; return "'+obj."+code+"+'"; &#125;); tpl = "var tpl= '"+tpl + "'\n return tpl;"; var complied = new Function('obj',tpl); return complied(data);&#125;//undefinedvar tpl = 'Hell &lt;%=username%&gt;'//undefinedconsole.log(render(tpl,&#123;username:'ly'&#125;))//VM326:1 Hell ly 模板安全,所有字符必须转义 123456789var escape = function (html) &#123; return String(html) .replace(/&amp;(?!\w+;)/g,'&amp;amp') .replace(/&lt;/g,'&amp;lt;') .replace(/&gt;/g,'&amp;gt;') .replace(/"/g,'&amp;quot;') .replace(/'/g,'&amp;#039;')&#125; Bigpipe 暂时不解释]]></content>
      <tags>
        <tag>node</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[node.js深入浅出笔记16]]></title>
    <url>%2F2017%2F09%2F26%2Fnode-js%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E7%AC%94%E8%AE%B016%2F</url>
    <content type="text"><![CDATA[路由解析文件路径型 静态文件 最简单的方式，直接就是url路径与网站目录的路径一致 动态文件 动态解析后缀不同的文件 MVC 路由解析，根据url寻找对应的控制器和行为 行为调用相关的模型，进行数据操作 数据操作结束后，调用视图和相关数据进行页面渲染，输出到客户端 RESTful 全称:Representational State Transfer 表现层状态转化 它的规范就是通过请求方式来判断用户需要做什么事 123456789101112var routes = &#123;'all':[]&#125;;var app = &#123;&#125;;app.use=function (path,action) &#123; routes.all.push([pathRegexp(path),action]);&#125;['get','put','delete','post'].forEach(function(method)&#123; routes[method] = &#123;&#125;; app[method] = function (path,action) &#123; routes[method].push([pathRegexp(path),action]) &#125; &#125;) 中间件 中间件的功能类似于细节的封装，我们只关注具体的业务逻辑 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138//基础的写法app.use('/user/:username',querystring,cookie,session,function(req,res)&#123; //TODO &#125;)//这里的中间件指的是--&gt;querystring,cookie,session//例子 querystringvar querystring = function (req,res,next) &#123; req.query = url.parse(req.url,true).query; next();&#125;//cookievar cookie = function (req,res,next) &#123; var cookie = req.headers.cookie; var cookie = &#123;&#125;; if(cookie) &#123; var list = cookie.split(";"); for(var i=0;i&lt;list.length;i++) &#123; var pair = list[i].split('='); cookies[pair[0].trim()] = pair[1]; &#125; &#125; req.cookies = cookies; next();&#125;//改进use()方法app.use = function (path) &#123; var handle = &#123; //第一个参数作为路径 path:pathRegexp(path), stack:Array.prototype.slice.call(arguments,1) &#125;; routes.all.push(handle);&#125;;//把所有中间件放进stack数组中保存，更改匹配方法var match = function (pathname,routes) &#123; for(var i=0;i&lt;routes.length;i++) &#123; var route = routes[i] //进行正则匹配 var reg = route.path.regexp; var matched = reg.exec(pathname); if(matched) &#123; //抽取具体，省略代码，将中间件数组交给handle()方法处理 handle(req,res,route.stack); return true; &#125; &#125; return false;&#125;//当匹配成功时会交给handle方法处理，该方法封装后，递归的执行数组中的中间件，每个中间件执行完成后，按照约定传入next()方法触发下一个中间件执行var handle = function (req,res,stack)&#123; var next = function()&#123; var middleware = stack.shift(); if(middleware) &#123; middleware(req,res,next) &#125; &#125; next();&#125;//不过这样写太复杂，有比较简单的写法app.use(xxx) xxx 为某中间件//我们为了适应参数的变化，设计如下app.use = function (path) &#123; var handle; if(typeof path === "string") &#123; handle = &#123; //第一个参数作为路径 path:pathRegexp(path), //其他的都是处理单元 stack:Array.prototype.slice.call(arguments,1) &#125; &#125; else &#123; handle = &#123; //第一个参数作为路径 path:pathRegexp('/'), //其他的都是处理单元 stack:Array.prototype.slice.call(arguments,0) &#125; &#125; routes.all.push(handle);&#125;//为保证后续匹配继续处理逻辑，我们需要改变匹配过程var math = function (pathname,routes) &#123; var stacks = []; for(var i=0;i&lt;routes.length;i++) &#123; var route = routes[i]; var reg = route.path.regexp; var matched = reg.exec(pathname); if(matched) &#123; //抽取具体值 //代码省略 //将中间件保存起来 stacks = stacks.concat(route.stack); &#125; &#125; return stacks;&#125;//改进分发过程function (req,res) &#123; var pathname = url.aprse(req.url).pathname; //将请求方法变为小写 var method = req.method.toLowerCase(); //获取all()方法里的中间件 var stacks = match(pathname,routes.all) if(routes.hasOwnPerperty(method)) &#123; //根据请求方法分发，获取相关的中间件 stacks.concat(match(pathname,routes[method])) &#125; if(stacks.length) &#123; handle(req,res,stacks); &#125; else &#123; handle404(req,res) &#125;&#125; 中间件异常处理12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152var handle = function (req,res,stack) &#123; var next = function (err) &#123; if(err) &#123; return handle500(err,req,res,stack); &#125; //stack数组中取出中间件并执行 var middleware = stack.shift(); if(middleware) &#123; //传入next()函数自身，使中间件能家属后进行递归 try&#123; middleware(req,res,next); &#125; catch (ex) &#123; next(err) &#125; &#125; &#125; next();&#125;//由于异步不能直接捕获，需要中间件自己传递出来var session = function (req,res,next) &#123; var id =req.cookies.sessionid; store.get(id,function(err,session)&#123; if(err) &#123; return next(err) &#125; req.session = session; next(); &#125;)&#125;//处理异常的中间件设计var handle500 = function(err,req,res,stack) &#123; //选取异常处理中间件 stack = stack.filter(function(middleware) &#123; return middleware.length === 4; &#125;) var next = function () &#123; //从stack数组中取出中间件并执行 var middleware = stack.shift(); if(middleware) &#123; //传递异常对象 middleware(err,req,res,next); &#125; &#125; next();&#125;]]></content>
      <tags>
        <tag>node</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[node.js深入浅出笔记15]]></title>
    <url>%2F2017%2F09%2F22%2Fnode-js%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E7%AC%94%E8%AE%B015%2F</url>
    <content type="text"><![CDATA[缓存 通过缓存可以节省不必要的传输，对用户和服务提供者都有好处，雅虎军规有几条缓存规则 添加Expires或者Cache-Control到报文头中 配置ETags 让Ajax可缓存 通常意义来说，大多数请求只存在于Get请求中 我们可以通过 if-Modified-Since来判断是否需要更新版本,last-Modified表示最后一次更新时间，代码如下 1234567891011121314151617var handle = function(req,res)&#123; fs.stat(filename,function(err,stat)&#123; fs.lastModified = stat.mtime.toUTCString(); if(lastModified === req.headers['if-Modified-Since']) &#123; res.writeHead(304,'Not Modified'); res.end(); &#125; else &#123; fs.readFile(filename,function(err,file)&#123; var lastModified = stat.mtime.toUTCString(); res.setHeader('Last-Modified',lastModified); res.writeHead(200,"OK"); res.end(file); &#125;) &#125; &#125;)&#125; 采用时间戳有一点缺陷 时间戳改动内容不一定改动 时间戳只能精确到秒，对于频繁的改动无法生效 用 ETag解决 ，服务决定他的生成规则，根据文件生成散列值 方法如下 12345678910111213141516171819202122var getHash = function (str) &#123; var shasum = crypto.createHash('sha1'); return shasum.update(str).digest('base64');&#125;//ETag的请求和响应是 If-None-Match/ETagvar handle = function (req,res) &#123; fs.readFile(filename,function(err,file) &#123; var hash = getHash(file); var noneMatch = req['if-none-match']; if(hash === noneMatch) &#123; res.writeHead(304,'Not Modified'); res.end(); &#125;else&#123; res.setHeader("Etag",hash); res.writeHead(200,"Ok"); res.end(file); &#125; &#125;)&#125; expires缺陷，服务器与本地会存在时间不一致的情况,可以用Cache-Conctrl解决 12345678var handle = function(req,res) &#123; fs.readFile(filename,function(err,file)&#123; res.setHeader("Cache-Control","max-age="+10*365*24*60*60*1000); res.writeHead(200,"OK"); res.end(file); &#125;)&#125; 清除缓存 家版本号 http://url.com/?v=20170926 内容分的哈希值 http://url.com/?hash = adasdasda Basic认证 如果一个页面需要basic认证，他会检查报文头的Authorization字段的内容，该字段由认证方式和加密值构成 123456789101112131415161718192021222324var encode = function (username,password) &#123; return new Buffer(username+":"+password).toString('base64');&#125;//如果用户首次访问该网址，url地址中也没携带认证内容，那么浏览器会响应一个401未授权的状态码 function (req,res) &#123; var auth = req.headers['authorization'] || ''; var parts = auth.split(''); var method = parts[0] || '';//Basic var encoded = parts[1] || '';sxdsdvdsfertgsa var decoded = new Buffer(encoded,'base64').toString('utf-8').split(":"); var user = decoded[0];//user var pass = decoded[1];//password if(!checkUser(user,pass))&#123; res.setHeader('WWW-Authenticate','Basic realm="Secure Area"'); res.writeHead(401); res.end(); &#125; else&#123; handle(req,res); &#125; &#125; 数据上传 通过解析报头的Transfer-Encoding或Content-Length可以判断是否带有内容，如下 12345678910111213141516171819var hasBody = function(req)&#123; return 'transfer-encoding' in req.headers || 'content-length' in req.headers;&#125;//如果存在function (req,res) &#123; if(hasBody(req))&#123; var buffers = []; req.on('data',function(chunk)&#123; buffers.push(chunk); &#125;); req.on('end',function()&#123; req.rawBody = Buffer.concat(buffers).toString(); handle(req,res); &#125;) &#125;else &#123; handle(req,res); &#125;&#125; 表单数据 默认的表单提交，请求头中的Content-Type字段值为application/x-www-form-urlencoded，可以通过如下进行解析判断 1234567var handle = function (req,res) &#123; if (req.headers['content-type'] === 'application/x-www-form-urlencoded') &#123; req.body = querystring.aprse(req.rawBody); &#125; todo(req,res);&#125; 其他格式 默认的表单提交，请求头中的Content-Type字段值为application/xx， xx可以是json 或者xml,我们还得携带编码信息: Content-Type:application/json;charset=utf-8 于是做如下判断 1234var mime = function (req) &#123; var str = req.headers['content-type'] || ''; return str.split(";")[0]&#125;; 解析json文件 12345678910111213var handle = function (req,res) &#123; if(mime(req) === 'application/json')&#123; try &#123; req.body = JSON.parse(req.rawBody); &#125; catch (e) &#123; res.writeHead(400); res.end("Invalid JSON"); return; &#125; &#125; todo(req,res);&#125; 解析xml 需要引入第三方的库 12345678910111213var xml2js = require('xml2js');if(mime(req) === 'application/xml')&#123; xml2js.parseString(req.rawBody,function(err,xml)&#123; if(err) &#123; res.writeHead(400); res.end('Invalid XML'); return; &#125; req.body = xml; todo(req,res); &#125;)&#125; 附件上传 对于含file控件的特殊表单，我们需要这样构造请求 Content-Type:multipart/form-data; boundary=AaBO3x Content-Length:19958 boundary=AaBO3x是每一部分的边界符，它是随机生成的一段字符串，报体内容将在它前面添加–进行分割，报文结束都加上–表示结束，Content-Length的值必须保障是报文体的长度 由于我们需要接受的文件大小不确定，所以我们需要谨慎处理 1234567891011121314151617function (req,res) &#123; if(hasBody(req))&#123; var done = function () &#123; handle(req,res); &#125; if(mime(req) === 'application/json')&#123; parseJSON(req,done); &#125; else if(mime(req) ==='application/xml')&#123; parseXML(req,done) &#125; else if(mime(req) === 'multipart/form-data') &#123; parseMultipart(req,done); &#125; &#125;else &#123; handle(req,res) &#125;&#125; 最好的啊办法是用formidable模块 12345678910111213141516var formidable = require('formidable');function (req,res) &#123; if(hasBody(req)) &#123; if(mime(req) === 'multipart/form-data') &#123; var form = new formidable.IncomingForm(); form.parse(req,function(err,fields,files)&#123; req.body = fields; req.files = files; handle(req,res); &#125;) &#125; &#125; else &#123; handle(req,res); &#125;&#125;]]></content>
      <tags>
        <tag>node</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[node.js深入浅出笔记14]]></title>
    <url>%2F2017%2F09%2F13%2Fnode-js%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E7%AC%94%E8%AE%B014%2F</url>
    <content type="text"><![CDATA[基础功能 由于node只提供了基础的功能，还远远达不到业务的需求 请求方式的判断12345678910111213 //改造请求方式 function (req,res) &#123; switch (req.method)&#123; case "POST" : update(req,res); break; case "DELETE" : remove(req,res); break; case "PUT" : create(req,res); break; case "GET" : default : get(req,res); &#125;&#125; 路劲解析 常用处理路劲进行业务处理的是静态文件服务器，处理方式如下 12345678910111213 function(req,res) &#123; var pathname = url.parse(req.url).pathname; fs.readFile(path.join(ROOT,pathname),function(err,file)&#123; if(err)&#123; res.writeHead(404); res.end('找不到文件') return; &#125; res.writeHead(200); res.end(file); &#125;)&#125; 还有一种常见分发场景是根据路径来选择控制器，他预设路径为控制器和行为的组合，无需额外配置路由信息 /controller/action/a/b/c 这里的controller会对应一个控制器,action对应控制的行为，剩余的值会作为参数，处理方式如下 12345678910111213141516171819202122 function (req,res) &#123; var pathname = url.parse(req.url).pathname; var paths = pathname.split('/'); var controller = paths[1] || 'index'; var action = paths[2] || 'index'; var args = paths.slice(3); if(handles[controller] &amp;&amp; handles[controller][action]) &#123; handles[controller][action].apply(null,[req,res].concat(args)); &#125;else&#123; res.writeHead(500); res.end('找不到响应控制器') &#125;&#125;//这样我们只要只关心具体的业务的实现handles.index = &#123;&#125;;handles.index.index = function(req,res,foo,bar)&#123; res.writeHead(200) res.end(foo);&#125; 查询字符串 通过querystring模块处理部分数据 1234567var url = require("url");var querystring = require('querystring');var query = queststring.parse(url.parse(req.url).query);//更简单的方式var query = url.parse(req.url,true).query; Cookie cookie的处理方式 服务器向客户端发送cookie 浏览器将cookie保存 之后每次浏览器都会将cookie发向服务器端 cookie的解析方式 123456789101112131415161718192021var parseCookie = function (cookie) &#123; var cookies = &#123;&#125;; if(!cookie)&#123; return cookies; &#125; var list = cookie.split(';'); for(var i = 0 ;i&lt;list.length;i++)&#123; var pair = list[i].split("="); cookies[pair[0].trim()] = pair[i]; &#125; return cookies;&#125;//直接访问如下function(req,res) &#123; req.cookies = parseCookie(req.headers.cookie); hande(req,res);&#125; 服务器告诉客户端的方式是通过设置Set-Cookie字段 Set-Cookie:name=value;Path=/;Expires=Sun,23-Apr-23 09:01:35 GMT;Domian=.domain.com; 上述的字符串的意思 path:表示cookie影响的路径 Expires和Max-Age用来告诉cookie过期时间 HttpOnly:表示脚本是否可以通过document.cookie访问 Secure:当值为true时，表示必须通过https访问 将cookie转换成规范格式 123456789101112var serialize = function (name,val,opt) &#123; var pairs = [name+'='+encode(val)]; opt = opt || &#123;&#125;; if(opt.maxAge)&#123;pairs.push('Max-Age='+opt.maxAge)&#125;; if(opt.domain)&#123;pairs.push('Domain='+opt.domain)&#125;; if(opt.path)&#123;pairs.push('Path='+opt.path)&#125;; if(opt.expires)&#123;pairs.push('Expires='+opt.expires.toUTCString())&#125;; if(opt.httpOnly)&#123;pairs.push('httpOnly')&#125;; if(opt.secure)&#123;pairs.push('secure')&#125;; return pairs.join(';')&#125; cookies的性能影响 减小Cookie的大小 为静态组件使用不同的域名 减少dns查询 Session 由于cookie安全性问题，就诞生了session,它能保证数据有一定的安全性，常见有两种方式实现 基于Cookie来实现用户和数据的映射,将口令保存在cookie上，上代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465var sessions = &#123;&#125;；var key = 'session_id';var EXPIRES = 20*60*1000;var generate = function () &#123; var session = &#123;&#125;; session.id = (new Date()).getTime()+Math.random(); session.cookie = &#123; expire:(new Date).getTiem()+EXPIRES &#125; session[session.id] = session; return session;&#125;//每个请求到来时，检查cookie中的口令与服务端的数据，如果过期重新生成function(req,res) &#123; var id = req.cookie[key]; if(!id)&#123; req.session = generate(); &#125;else&#123; var session = sessions[id]; if(session) &#123; if(session.cookie.expire &gt; (new Date().getTime()) &#123; //更新超时时间 session.cookie.expire = (new Date()).getTime() + EXPIRES; req.session = session; &#125; else &#123; //超时了，删除旧数据，并重新生成 delete session[id]; req.session = generate(); &#125; &#125; else &#123; //如果session过期或者口令不对，重新生成session req.session = generate(); &#125; &#125; handle(req,res)&#125;//当然仅仅重新生成Session还不足以完成整个流程，还要在响应给客户端时设置新的值，以便下次请求时能够对应服务器数据，这里我们hack响应的对象writeHead()方式，在它的内部注入设置Cookie的逻辑、var writeHead = res.writeHead;res.writeHead = function() &#123; var cookies = res.getHeader('Set-Cookie'); var session = serialize('Set-Cookie',req.session.id); cookie = Array.isArray(cookies) ? cookie.concat(session) : [cookies,session]; res.setHeader('Set-Cookie',cookies); return writeHead.apply(this,arguments)&#125;//我们现在只需写如下所示var hadle = function (req,res) &#123; if(!req.session.isVisit) &#123; res.session.isVisit = true; res.writeHead(200); res.end('欢迎第一次光临小屋') &#125; else &#123; res.writeHead(200); res.end("欢迎再次光临"); &#125;&#125; 通过查询字符串来实现浏览器端与服务端数据的对应 1234567891011121314151617181920212223242526272829303132333435363738394041//原理是通过检查请求的查询字符串，如果没有值，会先生成新的带值得url，如下var getURL = function (_url,key,value) &#123; var obj = url.parse(_url,true); obj.query[key] = value; return url.format(obj);&#125;;//然后跳转，让客户端重新发起请求function (req,res) &#123; var redirect = function (url) &#123; res.setHeader('Location',url); res.writeHead(302); res.end(); &#125;; var id = req.query[key]; if(!id) &#123; var session = generate(); redirect(getURL(req.url,key,session.id)); &#125; else&#123; var session = session[id]; if(session) &#123; if(session.cookie.expire &gt; (new date()).getTime()) &#123; //更新超时时间 session.cookie.expire = (new Date()).getTime()+EXPIRES; req.session = session; handle(req,res) &#125;else &#123; //超时了，删除旧数据，并且重新生成 delete session[id]; var session = generate(); redirect(getURL(req.url,key,session.is)); &#125; &#125;else &#123; //如果session过期或者口令不对，重新生成session var session = generate(); redirect(getURL(req.url,key,session.id)) &#125; &#125;&#125; session与内存，由于node的内存限制，我们一般采用第三方进行缓存，于是需要重新改写代码 1234567891011121314151617181920212223242526272829303132333435363738function(req,res) &#123; var id = req.cookie[key]; if(!id)&#123; req.session = generate(); &#125;else&#123; store.get(id,function(err,session)&#123; if(session) &#123; if(session.cookie.expire &gt; (new Date().getTime()) &#123; //更新超时时间 session.cookie.expire = (new Date()).getTime() + EXPIRES; req.session = session; &#125; else &#123; //超时了，删除旧数据，并重新生成 delete session[id]; req.session = generate(); &#125; &#125; else &#123; //如果session过期或者口令不对，重新生成session req.session = generate(); &#125; handle(req,res) &#125;) &#125; &#125;//在响应时，将新的session保存会缓存中，如下所示var writeHead = res,writeHead;res.writeHead = function () &#123; var cookies = res.getHeader('Set-Cookie'); var session = serialize('Set-Cookie',req.session.id); cookies = Array.isArray(cookies) ? cookies.concat(session) : [cookies,session]; res.setHeader('Set-Cookie',cookies); //保存回缓存 store.save(req.session) return writeHead.apply(this,arguments)&#125; Session 与 安全 xss 攻击]]></content>
      <tags>
        <tag>node</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[node.js深入浅出笔记13]]></title>
    <url>%2F2017%2F09%2F12%2Fnode-js%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E7%AC%94%E8%AE%B013%2F</url>
    <content type="text"><![CDATA[构建WebSocket服务 websocket基于事件编程的编程模型与node自定义事件相差无几,node的事件驱动十分商场与大量客户端保持高并发得连接 websocket与传统的http优势 客户端与服务端只建立一个tcp连接，可以使用更少的连接 websocket服务器可以推送数据到客户端，这远比http请求响应模式更加灵活，更加高效 有更轻量级的协议头，减少数据传输量 websocket客户端实例 12345678910111213var socket = new WebSocket('ws://127.0.0.1:1366/updates');socket.onopen = function () &#123; setInterval(function()&#123; if(socket.bufferedAmount == 0) socket.send(getUpdateData()); &#125;,50);&#125;socket.onmessage = function(event)&#123; //做些啥&#125; WebSocket协议主要两个部分：握手和传输数据 WebSocket握手 客户端在建立连接的时候，通过http发送请求报文，它比普通的http请求协议多了以下两个东西,表示服务端协议升级为WebSocket Upgrade:websocket Connection:Upgrade 还有三个特别参数 Sec-WebSocket-Key:用于安全校验 它的属性值用base64编码，服务器收到后与他自己的字符串进行相连，然后通过sha1安全散列算法计算出结果后，在进行base64编码，最后返回客户端，算法如下var crypto = require(“crypto”);var val = crypto.createHash(‘sha1’).update(key).digest(‘base64’); Sec-WebSocket-Protocol:指定自协议 Sec-WebSocket-Version：版本号 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273//示例代码，跑不起来//client.jsvar WebSocket = function (url) &#123; //伪代码，解析ws://127.0.0.1:12010/updates,用于请求 this.options = parseUrl(url); this.connect();&#125;WebSocket.prototype.onopen = function () &#123; console.log("干嘛的");&#125;WebSocket.prototype.setSocket = function () &#123; var this = that; var key = new BUffer(this.options.protocolVersion+'-'+Date.now()).toString('base64'); var shasum = crypto.createHash('sha1'); var expected = shasum.update(key+'258EAFA5-E914-47DA-95CA-C5ABoDC85B11').digest('base64'); var options = &#123; port:this.options.port, host:this.options.hostname, headers: &#123; 'Connection':'Upgrade', 'Upgrade':'websocket', 'Sec-WebSocket-Version':this.options.protocolVersion, 'Sec-WebSocket-Key':key &#125; &#125;; var req = http.request(options); req.end(); req.on('upgrade',function(res,socket,upgradeHead)&#123; //连接成功 that.setSocket(socket); //触发open事件 that.onopen(); &#125;)&#125;//server.jsvar http = require('http');var crypto = require('crypto');var server=http.createServer(function(req, res) &#123; res.writeHead(200, &#123; 'Content-Type': 'text/html;charset=utf-8' &#125;); res.write('在学习'); res.write('mess'); res.end("node");&#125;).listen(12010);//在收到upgrade请求后，告之客户端允许切换协议server.on('upgrade',function(req,socket,upgradeHead)&#123; var head = new Buffer(upgradeHead.length); upgradeHead.copy(head); var key = req.headers['sec-websocket-key']; var shasum = crypto.createHash('sha1'); key = shasum.update(key+'258EAFA5-E914-47DA-95CA-C5ABoDC85B11').digest('base64'); var headers = [ 'HTTP/1.1 101 SWitching Protocols', 'Upgrade:websocket', 'Connection:Upgrade', 'Sec-WebSocket-Accept:'+key, 'Sec-WebSocket-Protocol:'+protocol ]; //让数据立即发送 socket.setNoDelay(true); socket.write(headers.concat('','').join('\r\n')); // 建立服务器端的WebSocket连接 var websocket = new WebSocket(); websocket.setSocket(socket);&#125;) WebSocket数据传输 完成握手后，就不在进行http交互，而是开始WebSocket的数据帧协议，实现客户端与服务端的数据交互 示意图如下 握手完成后将会触发onopen() 123socket.onopen = function()&#123; //TODO:opened()&#125; 由于服务端没有onopen()方法可言,为了完成TCP套接字到websocket事件的封装，需要在接收数据时处理，websocket的数据帧协议即是在底层data事件上封装完成的 1234567891011//接收WebSocket.prototype.setSocket = function (socket) &#123; this.socket = socket; this.socket.on('data',this.receiver);&#125;;//发送WebSocket.prototype.send = function (data) &#123; this._send(data)&#125; 网络服务与安全 node 提供了3个模块，分别是crypto,tls,https,其中crypto主要用于加密解密，SHA！,md5等加密算法在其中都有体现，真正用于网络层的是另外两个,tls提供了与net类似的功能，区别在于建立tls/ssl加密的tcp连接上，对于https而言，他与http接口一致，只是多了安全连接。 TLS/SSL 秘钥之间的加密解密。是非对称结构，如图所示 利用node底层opensll生成私钥和公钥 12345678//服务器 私钥openssl genrsa -out server.key 1024//服务器 公钥openssl rsa -in server.key -pubout -out server.pem//客户端 私钥openssl genrsa -out client.key 1024//客户端 公钥openssl rsa -in client.key -pubout -out client.pem 依然存在中间人伪造站点的情况 数字证书解决这一波问题，详情自己百度，我就简单的写写 为了得到签名证书，服务器端需要通过自己的的私钥生成csr文件。ca机构将通过这个文件颁发属于该服务器端的签名证书，只要通过ca机构的就能验证证书是否合法]]></content>
      <tags>
        <tag>node</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[node.js深入浅出笔记12]]></title>
    <url>%2F2017%2F09%2F11%2Fnode-js%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E7%AC%94%E8%AE%B012%2F</url>
    <content type="text"><![CDATA[HTTP HTTP（HyperText Transport Protocol）是超文本传输协议的缩写，它用于传送WWW方式的数据，关于HTTP协议的详细内容请参考RFC2616。HTTP协议采用了请求/响应模型。客户端向服务器发送一个请求，请求头包含请求的方法、URL、协议版本、以及包含请求修饰符、客户信息和内容的类似于MIME的消息结构。服务器以一个状态行作为响应，响应的内容包括消息协议的版本，成功或者错误编码加上包含服务器信息、实体元信息以及可能的实体内容。 http模块 这是继承于TCP的net模块，但是tcp以connection为单位进行服务，http以request为单位进行服务 如图： http模块将连接所用的套接字的读写抽象为ServerRequest和ServerResponse对象，他们分别对应请求和相应操作 在请求产生的过程中，http模块拿到连接中传来的数据，调用二进制模块http_parser进行解析，在解析完请求报文的报头后，触发request事件，调用用户的业务逻辑，如图： http请求 对于tcp连接的读操作，http将其封装成ServerRequest对象,报文头会用http_parser进行解析，报文头如下 12345&gt;GET / HTTP /1.1&gt;User-Agent:curl/7.24.0 (x86_64-apple-darwin12.0) libcurl/7.24.0 OPenSSL/0.9.8r zlib/1.2.5&gt;Host:127.0.0.1.8995&gt;Accept: *//* 被解析成如下属性 req.method属性: GET req.url:值为/ req.httpVersion属性值:1.1 其余的都被放置在req.headers上传递给业务逻辑以供调用 报文体部分是一个只读流对象，如果业务逻辑需要读取报文体的数据，则需要等数据流结束后操作 12345678910 function(req,res)&#123; var buffers = []; req.on('data',function(trunk)&#123; buffers.push(trunk); &#125;).on('end',function()&#123; var buffer = Buffer.concat(buffers); res.end('Hello world') &#125;)&#125; HTTP响应 用于设置响应头的有res.setHeader()和writeHead()，setHeader()可以多次设置,但是只有调用writeHead,报头才会写入连接中 响应体则是由res.write()和res.end()实现,后者会先调用write()发送数据，然后发送信号告诉服务器这次响应结束，它一定要写，否则客户端一直处在等待状态 HTTP事件 connection事件:在开始http请求和响应之前，客户端要与服务器端建立底层的TCP连接，这个连接可能因为开启了keep-alive,可以在多次请求响应之间使用，当这个连接建立时，服务器触发一次connection事件 request事件:建立TCP连接后，http模块的底层将在数据流中抽离出http请求和http响应，当请求数据发送到服务器端，在解析出http请求头后，将会触发该事件，res.end()后，tcp连接可能用于下一次响应 close事件:与TCP服务器行为一直，调用server.close()停止接收新的连接，当已有的连接都断开时，触发该事件，可以给server.close()传递一个回调函数来快速注册该事件 checkContinue事件:比较有用的事件，对某些大型的数据传输有用 connect：当客户端发起connect请求时触发，而发起connect请求通常在http代理时出现，如果不监听该事件，发送请求的连接将会关闭 upgrade事件:当客户端要求升级连接的协议时，需要喝服务器端协商，客户端会在请求头中带上upgrade字段，服务器端会在接收到请求时触发该事件 clientError：连接的客户端触发error事件时，该错误会传递到服务器，触发该事件 Http客户端 通过http.request(options,connect)可以构造一个http客户端 1234567891011121314151617181920212223242526272829303132333435363738//服务器端var http = require('http');http.createServer(function(req, res) &#123; res.writeHead(200, &#123; 'Content-Type': 'text/html;charset=utf-8' &#125;); res.write('在学习'); res.write('mess'); res.end("node");&#125;).listen(3000);//客户端var http = require('http');var options = &#123; host:'127.0.0.1' //服务器IP地址 hostname:'127.0.0.1',//服务器名字 port:3000,//端口号 path:'/',//请求路劲 method:'GET'// //socketPath:Domain套接字路劲 //localAddress：建立网络连接的本地网卡 //headers:请求头对象 //auth:BAsic认证&#125;var req = http.request(options,function(res)&#123; console.log('STATUS'+res.statusCode); console.log('HEADERS'+JSON.stringify(res.headers)) res.setEncoding('utf-8'); res.on('data',function(chunk)&#123; console.log(chunk); &#125;)&#125;);req.end(); HTTP代理 http模块包含一个默认的客户端代理对象http.globalAgent，它对每一个服务器端创建的连接进行了管理，默认情况下,通过clientRequest对象对用一个服务器发起的http请求最多可以创建5个连接，他的实质是一个连接池 通过这个我们可以自行构造代理对象，从而扩充连接数 12345678910111213 var agent = new http.Agent(&#123; maxSockets:10&#125;) var options = &#123; host:'127.0.0.1' //服务器IP地址 hostname:'127.0.0.1',//服务器名字 port:3000,//端口号 path:'/',//请求路劲 method:'GET' agent:agent &#125; HTTP客户端事件 response:当得到服务器响应时触发该事件 socket:当底层连接池中建立的连接分配给当前请求对象时，触发该事件 connect:当客户端向服务器端发起connect请求时，如果客户端响应200状态码，客户端会触发该事件 upgrade:客户端向服务器发起upgrade请求时，如果服务端响应101 Switching Protocols状态，客户端会触发该事件 continue:客户端向服务器发起Expect：100-continue头信息，以试图发送较大的数据量，如果服务器端响应100 continue状态，客户端将触发该事件]]></content>
      <tags>
        <tag>node</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[node.js深入浅出笔记11]]></title>
    <url>%2F2017%2F09%2F08%2Fnode-js%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E7%AC%94%E8%AE%B011%2F</url>
    <content type="text"><![CDATA[构建UDP服务 UDP又称用户数据包协议，与TCP一样属于网络传输层,udp不是面向连接的，tcp中一旦建立连接，所有会话基本完成，客户端如果要与另外一个tcp服务通信，需要另创建一个套接字来完成连接，但在udp中，一个套接字可以和多个udp服务通讯，它虽然提供面向失误的简单不可靠信息传输服务，在网络差的情况会存在丢包的情况，但它无需连接，资源消耗，处理快速且灵活，很适合音频和视频传输 创建udp套接字 udp套接字一旦创建，既可以作为客户端发送数据，也可以作为服务端接收数据 123va dgram = require('dgram');var socket = dgram.createSocket('udp4'); 创建udp服务器端 如果需要udp套接字接收网络信息，我们只需调用dgram.bind(port,[address])对网卡和端口进行绑定即可 12345678910111213141516//server.jsvar dgram = require('dgram');var server = dgram.createSocket('udp4');server.on('message',function(msg,rinfo) &#123; console.log('server got:'+msg+'from'+rinfo.address+':'+rinfo.port);&#125;)server.on('listening',function()&#123; var address = server.address(); console.log('server listening'+address.address+":"+address.port);&#125;)server.bind(12345); 创建一个UDP客户端 12345678910var dgram = require('dgram');var message = new Buffer("我的名字叫 ly");var client = dgram.createSocket('udp4');client.send(message,0,message.length,12345,'localhost',function()&#123; client.close();&#125;) 套接字对象用在客户端时，可以调用send()方法发送消息到网络中 1socket.send(buf,offset,length,port,address,[callback]) 这些参数的分别是发送的Buffer对象，buffer的偏移，Buffer的长度,目标端口，目标地址，发送后完成的回调，与TCP套接字的write()相比，send()方法的参数列表相对复杂，但是他可以随意发送数据到网络中的服务器端，而Tcp需要发送给另一端则需要重新通过套接字构造新的链接 udp套接字事件 udp套接字只是EventEmitter的实例，而非Stream的实例 message:当udp套接字侦听网卡端口后，接收到消息时触发该事件，触发携带的数据为消息Buffer对象和一个远程的地址信息 listening:当udp套接字开始侦听时触发该事件 close：调用close()方法时触发该事件，并不在触发message事件，如需在此触发message事件，重新绑定即可 error:发生异常时抛出]]></content>
      <tags>
        <tag>node</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[node.js深入浅出笔记10]]></title>
    <url>%2F2017%2F09%2F07%2Fnode-js%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E7%AC%94%E8%AE%B010%2F</url>
    <content type="text"><![CDATA[网络编程 node是一个面向网络而生的平台，它具有事件驱动，无阻塞，单线程等特性，具有良好的伸缩性，很适合网络编程 构建Tcp服务 TCP协议的组成 TCP是面向链接的协议，其显著特征是传输之前要进行三次握手 构建Tcp服务端12345678910111213141516171819//server.js var net = require('net'); var server = net.createServer(function(socket)&#123; // 新的链接 socket.on('data',function(data)&#123; socket.write('hello'); &#125;) socket.on('end',function()&#123; console.log('cut connect'); &#125;) socket.write("我叫ly，欢迎来到我的小屋") &#125;).listen(8995,function()&#123; console.log("服务链接"); &#125;) 还有一种写法 123var server = net.createServer();server.on('connection',function(socket)&#123;&#125;)server.listen(8555); 客户端，可以用net模块进行构造，来测试构建的TCP服务 123456789101112131415//client.jsvar net = require('net');var client = net.connect(&#123;port:8995&#125;,function()&#123; console.log('client connected'); client.write("ly's home\n");&#125;)client.on('data',function(data)&#123; console.log(data.toString()); client.end();&#125;)client.on('end',function() &#123; console.log("is over");&#125;) ps 如果是linux，在填写时直接填path var client = net.connect({path:’/tmp/echo.sock’}) TCP服务事件 服务事件 listening: 对应方法:server.listen(port,listenEvent) connection:对应方法:net.createServer close:调用server.close()后，服务器停止接收套接字，等所有连接都断开后，出发该事件 error:当服务器异常时，该事件触发 连接事件 data:当调用write()发送数据时，另一端会触发data事件，事件传递就是write()发送的数据 end:当连接的任意一端发送了FIN数据时，该事件触发 connect:该事件用于客户端，当套接字与服务器连接成功时触发 drain：当任意一端调用write()发送数据时，当前这端会触发该事件 error:发生异常触发事件 close:套接字完全关闭，触发该事件 tiemout:当一定时间连接不再活跃，该事件会被触发，通知当前该链接已经闲置了 TCP套接字是可读可写的Stream对象,利用pipe()方法巧妙的实现管道操作 简单实现echo服务器 123456var net = require('net');var server = net.createServer(function(socket)&#123; socket.write('Echo server\r\n'); socket.pipe(socket);&#125;).sisten(8995,'127.0.0.1')]]></content>
      <tags>
        <tag>node</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[node.js深入浅出笔记9]]></title>
    <url>%2F2017%2F09%2F06%2Fnode-js%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E7%AC%94%E8%AE%B09%2F</url>
    <content type="text"><![CDATA[理解Buffer 这不是英雄联盟的buff,它是用于操作字节的，是个混血儿，是JavaScript与c++结合的模块，他是被放在全局对象上的 Buffer对象 它类似于数组，但它的元素是16进制的两位数。即0-255的数值 12345678910111213141516171819//命令行敲的&gt; var str = "越努力，越幸运，ly"undefined&gt; var buf = new Buffer(str,'utf-8')undefined&gt; buf&lt;Buffer e8 b6 8a e5 8a aa e5 8a 9b ef bc 8c e8 b6 8a e5 b9 b8 e8 bf 90 ef bc 8c 6c 79&gt;&gt; buf[10]188&gt; buf[10]=1010&gt; buf[10]10&gt; buf[11]=-100-100&gt; buf[11]156&gt; Buffer内存的分配 在C++层面申请内存，在javascript中分配内存，node采用slab分配机制 slab相当于申请好的固定大小的内存区块，它具有三种状态 full:完全分配状态 partial:部分分配状态 empty:没有分配状态 1Buffer.poolSize = 8*1024; 8kb的值技术每个slab的大小的值，在js层面，以它作为单位单元进行内存分配,node以8kb作为接线区分buffer是大对象还是小对象 对于小于8kb的buffer来说，他可以被分配多个buffer对象。 对于大于8kb的buffer来说，将会直接分配一个SlowBuffer对象作为slab对象，这个slab单元将会被这个大buffer对象独占 Buffer 的转换 Buffer对象可以与字符串之间相互转换 字符串转Buffer1new Buffer(str,[encoding]); 通过调用write()可以实现存储不同编码类型的字符串转码的值1buf.write(string,[offset],[length],[encoding]) Buffer 转字符串1buf.toString([encoding],[start],[end]) Buffer的拼接 在Buffer传输场景中，它是一段一段的传输的 1234567891011121314var fs = require('fs');var rs = fs.createReadStream('a.txt');var data = '';rs.on('data',function(trunk)&#123; data +=trunk;&#125;);rs.on('end',function()&#123; console.log(data);&#125;) 这是有问题的，当我们在处理宽字符的问题,依然会出现乱码 123456789101112131415161718var fs = require('fs');var rs = fs.createReadStream('a.txt',&#123;highWaterMark:11&#125;);//&#123;highWaterMark:11&#125; 这个代表一次读取11字符，由于中文占三个，可能存在乱码rs.setEncoding('utf-8');//这是是解决方法var data = '';rs.on('data',function(trunk)&#123; data +=trunk;&#125;);rs.on('end',function()&#123; console.log(data);&#125;) 对于以上的原因，是因为可读流内部设置了一个decoder对象，在每次data都通过该对象进行Bufffer到字符串的解码 12345678910111213var StringDecoder = require('string_decoder').StringDecoder;var decoder = new StringDecoder('utf8');var buf1 = new Buffer(['0xe5','0xba','0x8a','0xe5','0x89','0x8d','0xe6','0x98','0x8e','0xe6','0x9c','0x88','0xe5','0x85']);console.log(decoder.write(buf1));//床前明月var buf2 = new Buffer(['0x89','0xef','0xbc','0x8c','0xe7','0x96','0x91','0xe4','0xbc','0xbc','0xe5','0x9c','0xb0','0xe4','0xb8','0x8a','0xe9','0x9c','0x9c']);console.log(decoder.write(buf2));//光，疑似地上霜 stringDecoder会保留未被处理的字符，于是就看不见乱码了，但还是会有些问题呀，处理的编码比较少 正确拼接Buffer12345678910111213var chunks=[];var size = 0;res.on('data',function(chunk)&#123; chunks.push(chunks); size +=chunk.length;&#125;);res.on('end',function()&#123; var buf = Buffer.concat(chunks,size); var str = iconv.decode(buf,'utf8'); console.log(str);&#125;) 可以看下如何把小buffer拼接成大的buffer 123456789101112131415161718192021222324252627Buffer.concat = function(list,length) &#123; if(!Array.isArray(list)) &#123; throw new Error('Usage:Buffer.concat(list,[length])') &#125; if(list.length === 0)&#123; return new Buffer(0); &#125;else if(listen.length ===1) &#123; return list[0]; &#125; if(typeof length !='number')&#123; length = 0; for(var i=0 ; i&lt;list.length;i++)&#123; var buf = list[i]; length +=buf.length; &#125; &#125; var buffer = new Buffer(length); var pos = 0; for(var i=0;i&lt;list.length;i++)&#123; var buf = list[i]; buf.copy(buffer,pos); pos +=buf.length; &#125; return buffer;&#125; Buffer与性能]]></content>
      <tags>
        <tag>node</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[node.js深入浅出笔记8]]></title>
    <url>%2F2017%2F09%2F05%2Fnode-js%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E7%AC%94%E8%AE%B08%2F</url>
    <content type="text"><![CDATA[高效使用内存作用域 和JavaScript一样，按照作用域链查找元素标识符，对于内存来讲，当最外层的函数或者变量，一旦失去作用，局部的变量和函数就要被回收 变量的主动释放 对于定义在全局上面的对象或者变量，我们需要手动清除 12345678910var a = 'i am global';var b = &#123; user:'ly'&#125;//通过deletedelete a;//也可以设置为null或者undefindb=null; 闭包 先看下典型的闭包函数吧 123456789var s = function()&#123; var name = "ly"; return function()&#123; console.log(name+' like eat meat'); &#125;&#125;s()(); 本来 name 是s下面的局部变量，我们在外部访问不到，但是由于s返回的是一个匿名对象，于是我们的s函数在执行完毕，不会消失，name也不会消失，于是通过返回的函数，我们间接的访问了局部变量，于是呢，内存占用着。 内存指标查看内存使用情况 os模块的totalmem() 和freemem()可以查看 123456789101112var a = require('os');undefined//totalmem()a.totalmem()8540053504//freemem()a.freemem()4428193792 process.memoryUsage() 123456 process.memoryUsage() &#123; rss: 21786624, heapTotal: 8425472, heapUsed: 4790112, external: 9187 &#125; rss是resident set size 的缩写，即常驻内存的部分，进程的内存总共有几部分，一部分是rss，其余部分在交换区（swap）或者文件系统(filesystem)中 1234567891011121314151617181920212223242526272829 //展示我们内存的使用量 var showMem = function()&#123; var mem = process.memoryUsage(); var format = bytes =&gt; ((bytes/1024/1024).toFixed(2)+'MB'); console.log("内存总量："+format(mem.heapTotal)+" 内存使用量："+format(mem.heapUsed)+" rss:"+format(mem.rss)); console.log('-----------------------------------------------------------------------------'); &#125; var useMem = function()&#123; var size = 1024*20*1024; var arr = new Array(size); for(var i=0; i&lt;size;i++)&#123; arr[i] = 0; &#125; return arr; &#125;; var total = []; for(var j=0;j&lt;15;j++)&#123; showMem(); total.push(useMem()); &#125;//当我们把 var arr = new Array(size); 变成 var arr = new Buffer(size);,我们可以看到rss变的很大，并且没有中断程序。因为Buffer不属于v8管，因为i/o的v8管不住啊 内存泄露 主要的三个原因 缓存 队列消费不及时 作用域未释放 慎将内存当做缓存 两个问题 当一个对象被命中作为缓存来使用的话，他将会常驻老生代，缓存中储存的键越多，存活的对象就越多，这将导致垃圾回收，对这些对象做无用功 当使用对象的键值对缓存东西，因为普通的对象不想缓存一样有过期策略，所以也会造成内存泄露 缓存的限制策略 就是设置一个缓存的上限，使得内存不会溢出 详细方法参见书吧 node解决缓存的方案是采用外部的缓存软件，它具有良好的缓存过期淘汰策略以及自有的内存管理主要解决了一下两个问题 将缓存转移到外部，减少常驻内存的对象数量，让垃圾回收更高效 进程间可以共享缓存 关注队列状态 队列产生的原因，当事件处理的速度低于产生事件的速度，这就会形成堆积 解决方案 异步超时机制 还有就是拒绝模式。当队列拥塞时 内存泄露排查 通过node-heapdump以及node-memwatch两种方式进行排查 注意：用上面两款工具需要安装pyhton程序 大内存的应用 stream模块用于处理大文件]]></content>
      <tags>
        <tag>node</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[I Really Like You]]></title>
    <url>%2F2017%2F09%2F04%2FI-Really-Like-You%2F</url>
    <content type="text"><![CDATA[I really wanna stop明明很想让一切停下But I just gotta taste for it却又舍不得不甘心就这样浅尝辄止啊I feel like I could fly with the ball on the moon这感觉让我如同漂浮在月球上空 自由飞舞So honey hold my hand you like making me wait for it亲爱的 就握紧我手 这一刻我已期待很久I feel I could die walking up to the room, oh yeah当走向你房门的时候 我的心跳快得让我难以承受Late night watching television我们可以深夜一起窝在沙发看剧依偎But how we get in this position?但这么快就到这一步是否合适It’s way too soon, I know this isn’t love也许真的进展太快 还不能把这一切叫作爱But I need to tell you something但我真的很想对你说I really really really really really really like you我真的 真的 真的 真的好喜欢你And I want you, do you want me, do you want me, too?真的好想就这样拥着你占有你 你是否有和我一样的心情I really really really really really really like you我是真的 真的 真的 真的好喜欢你And I want you, do you want me, do you want me, too?也真的好像就这样将你占据 你是否也会有和我一样的心情Oh, did I say too much?噢 我是不是有点多话了I’m so in my head但我心里确实是这样想的When we’re out of touch尤其当我们没在联络的时候I really really really really really really like you我才真的明白 我是真的真的很喜欢你And I want you, do you want me, do you want me, too?也真的好想得到你拥有你占有你 告诉我你和我也是一样的心情It’s like everything you say is a sweet revelation你说的每一字句在我听来都像是甜言蜜语的表白All I wanna do is get into your head我多想了解你的一切和你此刻内心真实的想法Yeah we could stay alone, you and me, and this temptation或许我们可以独处一下 就你和我 在这暧昧的氛围之下Sipping on your lips, hanging on by thread, baby试探性地轻吻下你的唇 然后缠绵在舌尖 辗转厮磨 越陷越深Late night watching television我们也可以深夜一起窝在沙发看剧依偎But how we get in this position?但这么快就到这一步是否合适It’s way too soon, I know this isn’t love也许真的进展太快 还不能把这一切叫作爱But I need to tell you something但我真的很想对你说I really really really really really really like you我真的 真的 真的 真的好喜欢你And I want you, do you want me, do you want me, too?真的好想就这样拥着你占有你 你是否有和我一样的心情I really really really really really really like you我是真的 真的 真的 真的好喜欢你And I want you, do you want me, do you want me, too?也真的好像就这样将你占据 你是否也会有和我一样的心情Oh, did I say too much?噢 我是不是有点多话了I’m so in my head但我心里确实是这样想的When we’re out of touch尤其当我们没在联络的时候I really really really really really really like you我才真的明白 我是真的真的很喜欢你And I want you, do you want me, do you want me, too?也真的好想得到你拥有你占有你 告诉我你和我也是一样的心情Who gave you eyes like that?是谁赋予你如此美丽动人的双眸Said you could keep them让你用它将我心魂都勾走I don’t know how to act我不知该如何故作镇定The way I should be leaving也许我不该看着你的眼睛I’m running out of time但再不说点什么就再没机会了吧Going out of my mind就抛开所有理智和顾虑I need to tell you something对你说出我的真心话吧Yeah, I need to tell you something对 我真的想对你说Yeah I really really really really really really like you我真的 真的 真的 真的好喜欢你And I want you, do you want me, do you want me, too?真的好想就这样拥着你占有你 你是否有和我一样的心情I really really really really really really like you我是真的 真的 真的 真的好喜欢你And I want you, do you want me, do you want me, too?也真的好像就这样将你占据 你是否也会有和我一样的心情Oh, did I say too much?噢 我是不是有点多话了I’m so in my head但我心里确实是这样想的When we’re out of touch尤其当我们没在联络的时候I really really really really really really like you我才真的明白 我是真的真的很喜欢你And I want you, do you want me, do you want me, too?也真的好想得到你拥有你占有你 告诉我你和我也是一样的心情I really really really really really really like you我真的 真的 真的 真的好喜欢你And I want you, do you want me, do you want me, too?真的好想就这样拥着你占有你 你是否也会有和我一样的心情I really really really really really really like you我是真的 真的好喜欢你 不想失去你And I want you, do you want me, do you want me, too?也真的好想得到你拥有你占有你 告诉我你和我也有一样的心情收起]]></content>
      <tags>
        <tag>心情</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[node.js深入浅出笔记7]]></title>
    <url>%2F2017%2F09%2F04%2Fnode-js%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E7%AC%94%E8%AE%B07-1%2F</url>
    <content type="text"><![CDATA[内存的控制 node毕竟是在v8上跑的服务，v8的内存管理机制，在浏览器使用起来绰绰有余，但是对于node确有限制，对内存的需求还是很大的，但是浏览器能分配的内存不是很大，所以还是有些局限性 查看node内存的信息12345678910&gt; process.memoryUsage();&#123; rss: 21295104, heapTotal: 8425472, heapUsed: 3987064, external: 8942 &#125; //heapTotal申请的总堆内存 //heapUsed 当前使用量 v8提供了调整内存大小的命令1234//两者选其一node --max-old-space-size=1700 test.jsnode --max-new-space-size=1024 test.js v8的垃圾回收机制 v8的内存分代图 node –max-old-space-size 用于设置老生带最大值 node –max-new-space-size用于设置新生代最大值 在不设置内存的情况默认 老生代默认64位约1400mb 32位约700mb 如图所示 源代码 对于新生代,它由两个 reserved_semispace_size所组成,一个reserved_semispace_size 的64位约16m，32位约8m。 下图就可以解释 v8堆内存在64位上有1464mb,在32位上有732mb Scavenge算法 当一个对象经过多次复制依然存活时，它将会被认为是生命周期较长的对象，这种较长生命周期的对象随后会被移动到老生代中，这种过程叫做晋升 老生代处理的算法 懵逼了 Mark-Sweep &amp; Mark-Compact 看看书，先带过 用命令行查看垃圾回收日志 12node --trace_gc -e 'var a=[];for(var i=0;i&lt;1000000;i++) a.push(new Array(100));' &gt; gc.log 通过分析垃圾回收日志，可以了解垃圾回收的运行状况，找出那些阶段比较耗时 使用–prof参数，可以分析v8执行的性能以及垃圾回收所占用的时间 12345//app.jsfor(var i =0 ;i&lt;1000000 ;i++)&#123; var a=&#123;&#125;;&#125; 12node --prof app.js //运行]]></content>
      <tags>
        <tag>node</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[小岁月太着急]]></title>
    <url>%2F2017%2F09%2F01%2F%E5%B0%8F%E5%B2%81%E6%9C%88%E5%A4%AA%E7%9D%80%E6%80%A5%2F</url>
    <content type="text"><![CDATA[作曲 : 单色凌作词 : 单色凌合：我后悔自己没有去很多地方旅行也后悔当时没有鼓起勇气去吻你小岁月太着急 总让人措手不及是什么让现在变得没有意义女:小时候我们都有最想拥有的玩具长大后得到了却又有什么意义合:现在的每一刻 请学会好好珍惜别等到我们慢慢老去 只剩下叹息男：平时总觉得时间还有很多年把最想做的事情搁浅经常在想 以后总会实现以为小情绪永远不变女:可是 一年又一年 会时过境迁所追求的都没有终点愿望实现 却又总是怀念失去了曾经的感觉合：我后悔自己没有去很多地方旅行也后悔当时没有鼓起勇气去吻你小岁月太着急 总让人措手不及是什么让现在变得没有意义女：小时候我们都有最想拥有的玩具长大后得到了却又有什么意义合:现在的每一刻 请学会好好珍惜别等到我们慢慢老去 只剩下叹息男:可是 一年又一年 会时过境迁所追求的都没有终点愿望实现 却又总是怀念失去了曾经的感觉合：我后悔自己没有去很多地方旅行也后悔当时没有鼓起勇气去吻你小岁月太着急 总让人措手不及是什么让现在变得没有意义女：小时候我们都有最想拥有的玩具长大后得到了却又有什么意义合:现在的每一刻 请学会好好珍惜别等到我们慢慢老去 只剩下叹息合：我后悔自己没有去很多地方旅行也后悔当时没有鼓起勇气去吻你小岁月太着急 总让人措手不及是什么让现在变得没有意义女：小时候我们都有最想拥有的玩具长大后得到了却又有什么意义合:现在的每一刻 请学会好好珍惜别等到我们慢慢老去 只剩下叹息别等到我们慢慢老去 只剩下叹息]]></content>
      <tags>
        <tag>音乐</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[node.js深入浅出笔记6]]></title>
    <url>%2F2017%2F08%2F31%2Fnode-js%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E7%AC%94%E8%AE%B06%2F</url>
    <content type="text"><![CDATA[异步并发控制 当我们同时发起很多请求时，产生的并发量过大，会导致下层服务器吃不消，我们需要做一点过载保护措施 bagpipe的解决方案 通过一个队列来控制并发量 如果当前调用发起的但为执行的异步调用量小于限定值，从队列中取出执行 如果活跃调用达到限定值，调用暂时存放在队列中 每个异步调用结束时，从队列中取出新的异步调用执行 眼见为实 –&gt; 12345678910111213141516var Bagpipe = require('bagpipe');// 设置并发数为10var bagpipe = new Bagpipe(10);for(var i=0;i&lt;100;i++) &#123; bagpipe.push(async,function()&#123; //异步回调 &#125;)&#125;bagpipe.on('full',function(length)&#123; consoel.warn("底层系统不能及时处理，待处理长度为:"+length);&#125;) 上文push()方法核心实现，假设第一个参数是方法最后一个是回调函数，其余为其他参数,虽然看不懂，但是大神的代码也可以敲一敲，没准就通了 12345678910111213141516171819202122232425262728293031Bagpipe.prototype.push = function(method) &#123; var args = [].slice.call(arguments,1); var callback = args[args.length - 1]; if(typeof callback !=='function')&#123; args.push(function()&#123;&#125;) &#125; if(this.options.disabled || this.limt &lt;1 ) &#123; method.apply(null,args); return this; &#125; // 队列长度也超过限制长度时 if(this.queue.length &lt; this.queueLength || !this.options.refuse) &#123; this.queue.push(&#123; method:method, args:args &#125;) &#125; else&#123; var err = new Error('Too much async call in queue'); err.name = 'TooMuchAsyncCallError'; callback(err); &#125; if(this.queue.length &gt;1)&#123; this.emit('full',this.queue.length); &#125; this.next(); return this;&#125; 将调用推入队列后，调用一次next()方式触发，next()定义如下 123456789// 继续执行队列中的后续动作Bagpipe.prototype.next = function()&#123; var that =this; if(that.active &lt; that.limit &amp;&amp; that.queue.length) &#123; var req = that.queue.shift(); that.run(req.method,req.args); &#125;&#125; next()主要判断活跃调用的数量,如果正常调用内部的run()正真调用。这是为了判断回调函数是否执行 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647Bagpipe.prototype.run = function(method, args) &#123; var that = this; that.active++; var callback = args[args.length - 1]; var timer = null; var called = false; //注入逻辑 args[args.length - 1] = function(err) &#123; //清除定时器 if (timer) &#123; clearTimeout(timer); timer = null; &#125; &#125; //如果超时就不执行 if (!called) &#123; that._next(); callback.apply(null, arguments); &#125; else &#123; if (err) &#123; that.emit('outdated', err); &#125; &#125; var timeout = that.options.timeout; if (timeout) &#123; timer = setTimeout(function() &#123; //set called as true called = true; that._next(); var err = new Error(timeout + 'ms timeout'); err.name = 'BagpipeTimeoutError'; err.data = &#123; name: method.name, method: method.toString(), args: args.slice(0, -1) &#125; callback(err) &#125;, timeout) &#125; method.apply(null,args)&#125;; 毕竟太多请求也是不行的，等待时间过长，所以我们可以加入拒绝模式 123var bagpipe = new Bagpipe(10,&#123; refuse:true &#125;) 超时控制，保证一些代码不会异步调用耗时太久出问题 123var bagpipe = new Bagpipe(10,&#123; timeout:3000 &#125;) async的解决方案 async 处理异步调用的限制 parallelLimit() 1234567891011async.parallelLimit([ function(callback) &#123; fs.readFile('file1.txt','utf-8',callback); &#125;, function(callback) &#123; fs.readFile('file2.txt','utf-8',callback); &#125; ],1,function(err,results)&#123; //做点啥 &#125;) 通过queue()可以实现动态添加并行任务 123456789101112var q = async.queue(function(file,callback)&#123; fs.readFile(file,'utf-8',callback);&#125;,2)q.drain = function ()&#123; //完成了队列的所有任务&#125;fs.readdirSync('.').forEach(function(file)&#123; q.push(file,function(err,data)&#123; //做点啥啊 &#125;)&#125;)]]></content>
      <tags>
        <tag>node</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我不喜欢这个世界，我只喜欢你]]></title>
    <url>%2F2017%2F08%2F30%2F%E6%88%91%E4%B8%8D%E5%96%9C%E6%AC%A2%E8%BF%99%E4%B8%AA%E4%B8%96%E7%95%8C%EF%BC%8C%E6%88%91%E5%8F%AA%E5%96%9C%E6%AC%A2%E4%BD%A0%2F</url>
    <content type="text"><![CDATA[1、我不喜欢这世界，我只喜欢你2、一想到能和你共度余生,我就对余生充满期待。3、别人夸你懂事温和脾气好，只有在乎你的人才会关心你是不是受了委屈4、在这个什么都善变的世间我想和你看一看永远。5、我这个人运气一向不好,我这辈子最幸运的事大概就是遇见你,所以我特别特别珍惜,长这么大唯一坚持下来的事情就是爱你。6、有些人充满戾气和恶意，是因为他们从未被人温柔相待过。我相信自己能始终温柔，是因为在年少时遇到了善良的人。7、成长最遗憾的部分在于，我们总在最无知的年华里遇到最好的人，却不自知。8、16岁时我们共用一个课桌,胳膊与胳膊相距不过10厘米,我的余光里全是他。26岁我从清晨醒来,侧头看到阳光落在他脸上,想与他这样慢慢变老。也许这就是爱情吧。9、只是春光如此，却不得见你。10、车堵在路上久久没动,北京永远在堵车,这里空气不好,城市太大,人潮拥挤,我有一万个不喜欢这里的理由,可我爱的人在这里,我就在这里安了家。爱让我们褪去身上青涩的棱角,穿越汹涌的人潮,用最温暖最炽热的爱拥抱彼此,我知道这个世界什么都善变,可是说真的,眼前这个人,他让我相信永远。11、一辈子很长，要跟有趣的人在一起。12、喜欢一个人 就像喜欢富士山 你可以看到它 但是不能搬走它——你唯一能做的 就是自己走过去 去争取自己的爱人13、爱让人突然有了盔甲，也突然有了软肋。14、在我面前,你可以不用坚强。15、我想爱情可能不是谁带领谁,而是双方共同成长才能达到安心与自在,如果说,喜欢是渴望将好的一起分享,那么,爱是愿意把坏的共同承担。我知道这条路很长,好在一辈子很长,我想陪他慢慢走。16、海上月是天上月，眼前人是心上人。17、为什么我们总爱上那些不在乎我们的人：?因为我们总觉得自己不配得到更好的爱。18、遇见你那天起,就没想过要分开。19、从校服到婚纱，爱让我们成为更好的人，在这个善变的人世间，我想和你看一看永远。20、一个人爱着另一个人是藏不住的。21、“喂，你等一下。”“干啥？”“我喜欢你。”“可我不喜欢你啊，你谁啊？”“我只是通知你一下，没问你意见。”22、爱情不是人生的全部，它是锦上添花不是救命稻草，女人除了年轻美貌被人爱，难道不应该努力学习，不断成长，多一些智慧和温柔去建立自我的价值吗。眼界放宽些，这个世界比你想象的要广阔，你应该和你爱的人一起去看天大地大，而不是抱在一起相互取暖。23、我从来不想要什么更好的人,我只要眼前的人,你究竟什么时候才会懂：?24、在这善变的人世间，我想和你看一看永远。25、亲爱的，你做什么我都站在你这边，就算你要逃婚我也给你买跑鞋。26、那你现在可以记住,有一件事你可以确定——我永远是你的。27、“她在家也这么要强？”“不，在家很爱撒娇，经常看电影哭得眼泪鼻涕的要我哄，跟个小孩儿一样。“同事很困惑“为什么？”“因为只有在我面前，她可以不用坚强。”28、后来才明白，别人只会夸你懂事温和脾气好，而只有真正在乎你的人才会关心你是不是受了委屈。29、爱让我们褪去身上的青涩的棱角，穿越汹涌的人潮，用最温柔最炙热的爱拥抱彼此，我知道这个世界什么都善变，可是说真的，眼前这个人，他让我相信永远。30、反正得听你啰嗦一辈子,习惯就好。31、天气好的想骂娘，不想学习想去浪。32、我发现自己有那么多话想对他讲，想告诉他，我现在很快乐，我没有特别自卑了，我的生活轻松愉悦，每天都努力让自己变得更好，我去参加社团学生会各种选修课，一点一点变优秀，我对未来充满期许。现在的我是最好的我，如果你在我身边就好了。33、他说那时他站在医院的楼道里,很认真地想,要是我没有挺过去,他就把名字改成我的,替我在这个世界上继续活。34、有没有某件事情,你很确信你可以做到从来没有怀疑过自己。35、你知道吗？那些嘲笑别人是花瓶的人，她们唯一的强项是当不上花瓶。36、十几岁时，我幼稚地以为不会爱上任何人，我不确定自己有爱的能力。37、在这什么都善变的世界里，我想和你看一看什么是永远。38、一个人爱着另外一个人是藏不住的，不信你去看看《大话西游》里紫霞仙子看至尊宝的眼神，满满的全是爱。39、我刚跟f君说，其实我特别好哄，我又不刷你卡也不买包包，你只要使劲夸我就行，娶我是不是很划算。他斩钉截铁地打断我，“不，我娶你只是因为你漂亮，你不这么漂亮我早就写休书了！”我立马眉开眼笑高兴得忘了自己姓啥。40、如果说，喜欢是渴望将好的一起分享，那么，爱是愿意把坏的共同承担。41、我知道这条路很长，好在一辈子很长，我想陪他慢慢走。42、爱是人类与生俱来的天赋，根植于每个人的生命之中，无论周围的土壤怎么贫瘠，它都不会消失，只要有人呼唤它，它就一定在。43、f君是个高冷逼，外人面前特别人模狗样。以前我爱逗他，在外面点餐的时候突然停下来对他说：“姐夫，我们这样做对得起我姐吗？”起初他还会和服务员一起露出被雷劈的表情，久了就习惯了，昨天还特别淡定地回了一句：“你姐在九泉之下会祝福我们的。”44、是啊,妹妹太要强,哥哥什么都帮不了,只能帮她哭。45、从校服到婚纱，爱让我们成为最好的人。46、出差回来累成狗，撞上朋友失恋，拖着箱子陪她喝酒。回到家特别伤感，跟f君说这我辈子最幸运的事就是遇见他，所以特别珍惜，长这么大唯一坚持下来的事情就是爱他。他说：“恩，你这么说我很感动，”顿了顿又说：“但你不要以为我会原谅你凌晨三点才回家。”然后去帮我泡蜂蜜水解酒。47、你应该跟你爱的人一起去看天大地大，而不是抱在一起相互取暖48、我以前在书里看过一句话，印象很深，说在人的一生中，遇到爱，遇到性，都不稀罕，稀罕的是遇到了解。我想这就是了解吧49、你知不知道,跳楼除非正好脑袋冲下,脑浆迸出来才会立刻死,好多人都是摔断骨头摔破内脏,在地上挣扎很久眼睁睁看着自己的血流光才能死掉的。50、总说上帝给你关上一扇门，就会帮你打开一扇窗，我当时觉得上帝要么忘了我，要么给我安的是扇防盗窗。51、喜欢上一个人总需要一点时间，而我又总是在这段时间里发现对方是个傻逼。”52、我原谅你了，给我打个电话好不好。53、“你知道我有多难受吗？”他叹气：“我未必比你好过。”54、我让你别这么早结婚,你要结,结婚之前分手了你还是可爱的失恋少女,现在分手你就只能是离婚妇女了。55、一个人爱一只鸽子，鸽子要飞，他心里难过，但还是祝福鸽子越飞越高。56、“胸大才配叫女人，你呢？顶多只能算是个雌性。”57、以前我俩吵架，冷战，暑假班长让我联系他，说他手机关机。我打他家电话，是他妈妈接的，说他去旅游了。开学他问我找他什么事，我想起上次他妈妈没问我的名字，就问他怎么知道是我。他说我妈说是个女生，只有你一个女生知道我家电话……我突然就不生气了，第二天主动给他带早餐，丫受宠若惊都不知道为啥!58、生病在家躺了一天，下午快递把新买的书架送来了，闲着没事照着说明书自己安装，特有成就感，刚他一回来我就拉着他邀功。我：看！我一个人装的哟~他眼神宠爱抚摸我狗头赞叹：我家老婆啊……摇着尾巴等他夸我贤惠，谁知他放下手，话锋一转：真是条汉子。我：！@#￥%……&amp;*59、“真想不明白为什么有男人会去找外遇呢？明明一个已经够麻烦了。”60、“因为只有在我面前，她可以不用坚强。”61、“你是天上的天使，上帝觉得妈妈是这个世界上最美的女人，所以派你来保护她。”“那么你呢？”小f问。“等你长大了就会离开她，爸爸负责陪妈妈一直到老。62、去年冬天长湿疹被我抓破了腿上全是疤，朋友看到问怎么回事，我看f君一眼，可怜巴巴地说，因为我不乖，被家暴了。他愣了一下，马上板起脸说，不是警告过你不准说出去吗，回去再打一顿！哈哈哈哈我没忍住笑场了。63、虽然我整天腻腻歪歪秀恩爱，但是说真的，爱情不是人生的全部，它是锦上添花不是救命稻草，女人除了年轻美貌被男人爱，难道不应该努力学习，不断成长，多一点智慧和温柔去建立自我的价值吗。眼界放宽些，这个世界比你想象的要广阔，你应该跟你爱的人一起去看天大地大，而不是抱在一起相互取暖。64、我当机立断立刻装可怜：“亲爱的，我刚刚做了个噩梦，梦到我坐的轮船翻了，我掉进海里，特别特别冷。”他说：“恩，我也特别冷。”我：“那我们真是心有灵犀呢哈哈哈哈。”他：“我冷是因为没被子盖，你冷是因为心虚吧。”65、十六岁，你穿着校服坐在我身旁二十六岁，你穿着婚纱睡在我身旁66、那是他走了之后，我第一次因为这件事流泪。我很能克制自己的感情，也很擅长忍耐，可是那一刻真的觉得自己无法再克制下去了。我发现自己有那么那么多话想对他讲，想告诉他，我现在很快乐，我没有特别自卑了，我的生活轻松愉悦，每天都努力让自己变得更好，我去参加社团学生会各种选修课，一点一点变优秀，我对未来充满期许。现在的我是最好的我，如果你在我身边就好了。67、以前我问过他什么事情是很有把握一定能做到的。后来他跟我说，他确信的事情之一，是我们一定会在一起。68、“别逛了，早点回家。”“知道知道，别担心我。”“我不是担心你，我是担心方圆十里的流氓。”69、最后一条是：我好想你。时间是他生日。70、活着还有什么意义，人生在世，不就是为了口吃吗。71、结婚前闺蜜们给我搞了一个单身party。f经常骂我人来疯，真的一点没错。一大堆好朋友聚在一起我就特别高兴，一高兴]]></content>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[node.js深入浅出笔记5]]></title>
    <url>%2F2017%2F08%2F30%2Fnode-js%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E7%AC%94%E8%AE%B05%2F</url>
    <content type="text"><![CDATA[Step 轻量级的流程控制库 只提供一个接口 1Step(task1,task2,task3); 示例代码 1234567891011Step(function readFile()&#123; fs.readFile('file1.txt','utf-8',this); &#125;, function readFile2(err,content)&#123; fs.readFile('file2.txt','utf-8',this); &#125;, function done(err,content) &#123; console.log(content); &#125; ) this 是Step内部的一个next()方法,将异步调用的结果传递给下一个任务作为参数，并调用执行 并行任务执行 this有一个parallel()方法，可以告诉Step,需要等待所有任务结束才执行下一个任务 1234567891011var Step = require('step');var fs = require('fs');Step(function readFile()&#123; fs.readFile('file1.txt','utf-8',this.parallel()); fs.readFile('file2.txt','utf-8',this.parallel()); fs.readFile('file3.txt','utf-8',this.parallel());&#125;,function done(err,content1,content2,content3)&#123; console.log(arguments);&#125;) 书上说异步方法的结果传回的是多个参数，step将只会取前两个参数（不懂） 12345678var asyncCall = function(callback)&#123; process.nextTick(function()&#123; callback(null,'result1','result2') &#125;)&#125;//调用paraller()时，result2将会被丢弃 Step的parallel()方法原理:每次执行时将内部的计数器加1,然后返回一个回调函数，这个回调函数在异步调用结束时才执行。当回调函数执行时，将计数器减1,当计数器为0时，告知所有的异步调用结束，Step执行下一个方法 结果分组 group 看下示例代码基本能明白 1234567891011121314151617181920Step( function readDir()&#123; fs.readdir(_dirname,this); &#125;, function readFiles(err,results)&#123; if(err) throw err; var group = this.group(); results.forEach(function(filename)&#123; if(/\.js$/.test(filename))&#123; fs.readFile(_dirname+'/'+filename,'utf-8',group()) &#125; &#125;); &#125;, function showAll(err,files)&#123; if(err) throw err; console.log(files); &#125; ) wind 也是一个y异步的流程库，咱们中国人写的，做异步动画挺好的样子，我们来实现下异步动画排序的过程，先看看过程，再讲方法 1234567891011121314151617181920212223var compare = function(x,y)&#123; return x-y;&#125;var swapAsync = eval(Wind.compile('async',function(a,i,j)&#123; $await(Wind.Async.sleep(20));//休息20毫秒 var t =a[i]; a[i] = a[j]; a[j] = t; paint(a);&#125;))var bubbleSort = eval(Wind.compile('async',function(array)&#123; for(var i=0;i&lt;array.length;i++)&#123; for(var j=0;j&lt;array.length-i-1;j++)&#123; if(compare(array[j],array[i])&gt;0)&#123; $await(swapAsync(array,j,j+1)) &#125; &#125; &#125;&#125;)) eval(Wind.compile(‘async’,function(){})) Wind.compile()将普通的函数进行编译 eval()执行代码 Wind.Async.sleep() 内置了对setTimeout()的封装 $await() 它不是一个方法，只是一个等待的占位符，告诉编译器需要等待 他接受一个任务对象，表示任务结束才能继续执行，每个异步任务都可以转化为一个任务，wind正是基于任务模型实现的，这是一个将fs.readFile()调用转换成一个任务模型 123456789101112131415var Wind = require('wind');var Task = Wind.Async.Task;var readFileAsync = function(file,encoding)&#123; return Task.create(function(t)&#123; fs.readFile(file,encoding,function(err.file)&#123; if(err) &#123; t.complete('failure',err); &#125; else &#123; t.complete('success',file); &#125; &#125;) &#125;)&#125; Wind串行展示 12345678910111213141516var serial = eval(Wind.compile('async',function()&#123; var file1 = $await(readFileAsync('file1.txt','utf-8')); console.log(file1); var file2 = $await(readFileAsync('file2.txt','utf-8')); console.log(file2); try&#123; var file3 = $await(readFileAsync('file3.txt','utf-8')) &#125; catch(err)&#123; console.log(err) &#125;&#125;))serial().start();//file1 file2 error 并行效果展示 12345678910var parallel = eval(Wind.compile('async',function()&#123; var results = $await(Task.whenAll(&#123; file1:readFileAsync('file1.txt','utf-8'); file2:readFileAsync('file2.txt','utf-8'); &#125;)) console.log(results.file1,results.file2);&#125;))parallel().start(); Wind好似同步编程的感觉，但是我们需要做一些麻烦的操作。]]></content>
      <tags>
        <tag>node</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[node.js深入浅出笔记4]]></title>
    <url>%2F2017%2F08%2F29%2Fnode-js%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E7%AC%94%E8%AE%B04%2F</url>
    <content type="text"><![CDATA[异步编程 async异步的串行执行，通过series ()实现123456789101112var fs = require('fs');var async = require('async');async.series([function (callback) &#123; fs.readFile('file1.txt','utf-8',callback)&#125;,function (callback) &#123; fs.readFile('file2.txt','utf-8',callback)&#125;,],function(err,results)&#123; console.log(results,'哈哈');&#125;) 等价于 123456789101112fs.readFile('file1.txt','utf-8',function(err,content)&#123; if(err)&#123; return callback(err) &#125; fs.readFile('file2.txt','utf-8',function(err,data)&#123; if(err)&#123; return callback(err); &#125; callback(null,[content,data]) &#125;)&#125;) 每个callback()执行的结果都将保存起来，然后执行下一个调用，直到结束所有调用，最终执行的回调函数将把前几次异步调用的结果以数组的形式传入，异常处理规则是，一旦出现异常，结束所有调用，并将异常传递给最终回调的第一个参数(啥意思？？)，好像是那个啥，回到调用成功的阶段。 异步的并行执行parallel1234567891011121314var fs = require('fs');var async = require('async');async.parallel([ function(callback) &#123; fs.readFile('file1.txt','utf-8',callback); &#125;, function(callback) &#123; fs.readFile('file2.txt','utf-8',callback); &#125; ],function(err,results)&#123; console.log(results); &#125;) 等价于 123456789101112131415161718192021222324252627282930313233343536var counter = 2;var results =[];var done = function(index,value) &#123; results[index] = value; counter--; if(counter ===0) &#123; callback(null,results); &#125;&#125;//只传递一个异常var hasErr = false;var fail = function(err) &#123; if(!hasErr)&#123; hasErr = true; callback(err); &#125;&#125;fs.readFile('file1.txt','utf-8',function(err,content)&#123; if(err)&#123; retunr fail(err) &#125; done(0,content)&#125;)fs.readFile('file2.txt','utf-8',function(err,content)&#123; if(err)&#123; retunr fail(err) &#125; done(1,content)&#125;) 也类似于 1234567891011var EventProxy = require('eventproxy');var proxy = new EventProxy();proxy.all('content','data',function(content,data)&#123; callback(null,[content,data]);&#125;)proxy.fail(callback);fs.readFile('file1.txt','utf-8',proxy.done('content'));fs.readFile('file2.txt','utf-8',proxy.done('data')); 异步调用的依赖处理waterfall 当前一个结果是后一个结果的输入时，可以用waterfall 1234567891011121314151617181920212223242526var fs = require('fs');var async = require('async');async.waterfall([function(callback)&#123; fs.readFile('file1.txt','utf-8',function(err,content)&#123; callback(err,content) &#125;)&#125;,function(arg1,callback)&#123; //arg1 =&gt; file2.txt fs.readFile(arg1,'utf-8',function(err,content)&#123; callback(err,content) &#125;)&#125;,function(arg1,callback)&#123; //arg1 =&gt; file3.txt fs.readFile(arg1,'utf-8',function(err,content)&#123; callback(err,content); &#125;)&#125;],function(err,results)&#123; console.log(results);&#125;) 也等价于 1234567891011121314151617 fs.readFile('file1.txt','utf-8',function(err,data1)&#123; if(err)&#123; return callback(err) &#125; fs.readFile('file2.txt','utf-8',function(err,data2)&#123; if(err)&#123; return callback(err) &#125; fs.readFile('file3.txt','utf-8',function(err,data3)&#123; if(err)&#123; return callback(err); &#125; callback(null,data3) &#125; &#125;)&#125;)]]></content>
      <tags>
        <tag>node</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[你是人间的四月天]]></title>
    <url>%2F2017%2F08%2F28%2F%E4%BD%A0%E6%98%AF%E4%BA%BA%E9%97%B4%E7%9A%84%E5%9B%9B%E6%9C%88%E5%A4%A9%2F</url>
    <content type="text"><![CDATA[我说你是人间的四月天；笑响点亮了四面风；轻灵在春的光艳中交舞着变。你是四月早天里的云烟，黄昏吹着风的软，星子在无意中闪，细雨点洒在花前。那轻，那娉婷，你是，鲜妍。百花的冠冕你戴着，你是天真，庄严，你是夜夜的月圆。雪化后那片鹅黄，你像；新鲜初放芽的绿，你是；柔嫩喜悦水光浮动着你梦期待中白莲。你是一树一树的花开，是燕在梁间呢喃，——你是爱，是暖，是希望，你是人间的四月天！]]></content>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[node.js深入浅出笔记3]]></title>
    <url>%2F2017%2F08%2F27%2Fnode-js%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E7%AC%94%E8%AE%B03%2F</url>
    <content type="text"><![CDATA[异步编程高阶函数 高阶函数可以把函数当成参数，或是将函数作为返回值的函数 1234567 var points = [90,25,89,45,36,95,56,87]; points.sort(function(a,b)&#123; return a-b; &#125;)//通过改变不同的参数，可以决定排序方式 偏函数的用法 意思指的是:创建一个调用另外一个部分–参数或者变量已经预置的函数 1234567891011121314151617181920212223//解释一下var toString = Object.prototype.toString;var isString = function(obj)&#123; return toString.call(obj) == '[object String]'&#125;var isFunction = function(obj)&#123; return toString.call(obj) == '[object Function]'&#125;//以上这样写会产生很多累赘的代码,按照一下方式就是偏函数的用法var isType = function(type)&#123;return function (obj)&#123; return toString.call(obj) == '[object'+type+']'; &#125;&#125;var isString = isType('String');var isFunction = isType('Function'); node 的事件驱动的非阻塞i/ o模型 如图所示 异步编程的难点 异常处理的难点 异步方法通常有两个阶段，一个是提交请求，异常并不一定发生在此处，try/catch的功效不会发挥功效，第二个是处理结果 node在处理异常有一种约定俗成的规定，即异常将作为回调函数第一个参数返回，如果为空值则没有异常 我们在编写异步时遵循的原则 必须执行调用者传入的回调函数 正确传递回异常供调用者判断 123456789101112 //示例代码 var async = function(callback) &#123; process.nextTick(function()&#123; var results = something; if(error)&#123; return callback(error); &#125; callback(null,results) &#125;);&#125; 函数嵌套过深 node多个异步调用 阻塞代码 不能用sleep()使线程睡眠 多线程编程 前端使用 web Workers 异步转同步 异步编程的解决方案事件发布/订阅模式1234567//例子//订阅emmiter.on('event1',function(message)&#123; console.log(message); &#125;) //发布 emmiter.emit('event1','i am ok') 多异步之间的协作方案 通过哨兵变量以及偏函数来解决 1234567891011var after = function(times,callback)&#123; var count = 0 , results = &#123;&#125;; retrun function(key,value) &#123; results[key] = value; count++; if(count===times) &#123; callback(results); &#125; &#125;&#125; 利用EventProxy模块实现自由订阅组合事件 123456789101112131415161718var proxy = new EventProxy();proxy.all('template','data','resource',function(template,data,resource)&#123; //TODO&#125;)fs.readFile('template_path','utf-8',function(err,template)&#123; proxy.emit('template',template);&#125;)db.query(sql,function(err,data)&#123; proxy.emit('data',data);&#125;)http.get(function(err,resource)&#123; proxy.emit('resource',resource)&#125;) all() 事件，只有当参数列表的数据都获取到才执行回调函数 tail() 事件，只要满足一个参数条件，就可以执行 after(‘data’,10,callback) 事件 ,只有调用10次后才执行监听事件 EventProxy代码1234567891011121314151617181920212223trigger : function(eventName) &#123; var list,calls.ev.callback,args; var both = 2; if(!(calls = this._callbacks)) return this; while(both--)&#123; ev = both ? eventName : 'all'; if(list = calls[ev]) &#123; for(var i = 0,l = list.length;i&lt;l;i++)&#123; if(!(callback = list[i]))&#123; list.splice(i,1);i--;l--; &#125;else&#123; args = both ? Array.prototype.slice.call(arguments,1) : arguments; callback[0].apply(callback[1] || this,args); &#125; &#125; &#125; &#125; return this;&#125; EventProxy异常处理代码 12345678910111213141516171819202122232425262728293031323334353637383940 exports.getContent = function(callback)&#123; var ep = new EventProxy(); ep.all('tpl','data',function(tpl,data)&#123; callback(null,&#123; template:tpl, data:data &#125;) &#125;) //侦听异常 ep.bind('error',function(err)&#123; ep.unbind(); callback(err) &#125;) fs.readFile('template_tpl','utf-8',function(err,content)&#123; if(err)&#123; return ep.emit('error',err) &#125; ep.emit('tpl',content) &#125;) db.get('some sql',function(err,result)&#123; if(err)&#123; return ep.emit('error',err); &#125; ep.emit('data',result); &#125;)&#125;//优化后 ep.fail(callback); fs.readFile('template_path','utf-8',ep.done('tpl')); db.get('sql',ep.done('data')) Promise/Deferred模式 Promise/A 三种状态：未完成状态 完成状态 失败状态 状态一旦变化不能被更改 状态不能逆反，切完成态和失败状态不能相互转换 可选择的将progress事件回调作为第三个方式 then()只接受function对象，其余对象被忽略 then()继续返回promise对象,以实现链式调用 then(fulfillhandle,errorHandler,progressHandler)参数: 简单的实现 123456789101112131415161718192021222324//将回调函数存放起来 var Promise = function()&#123; EventEmitter.call(this); &#125; util.inherits(Promise,EventEmitter); Promise.prototype.then= function(fulfilledHandle,errorHandler,progressHandler)&#123; if(typeof fulfilledHandle ==='function') &#123; this.once('success',fulfilledHandle); &#125; if(typeof errorHandler === 'function') &#123; this.once('error',errorHandler) &#125; if(typeof progressHandler === 'function')&#123; this.on('proress',progressHandler); &#125; return this; &#125; 1234567891011121314151617181920//deferredvar Deferred = function()&#123; this.state = 'unfulfilled'; this.promise = new Promise();&#125; Deferred.prototype.resolve = function(obj) &#123; this.state = 'fulfilled'; this.promise.emit('success',obj); &#125; Deferred.prototype.reject = function (err) &#123; this.state = 'failed'; this.promise.emit('error',err); &#125; Deferred.prototype.progress = function(data) &#123; this.promise.emit('progress',err); &#125; 没看懂，暂时跳过 研究下Q 和 when 库流程控制库 非规范的流程控制库 https://github.com/senchalabs/connect 尾触发与next 需要手动调用才能持续执行后续调用的，我们将此称为尾触发 关键词 next 123456789101112131415//connect 暴露apivar connect = require('connect');var app = connect();//中间件app.use(connect.staticCache())app.use(connect.static(_dirname+'/public'));app.use(connect.cookieParser())app.use(connect.session());app.use(connect.query());app.use(connect.bodyParser());app.listen(30001) 中间件利用了尾触发的机制,以下是最简单的中间件 123function(req,res,next) &#123; //中间件&#125; 每个中间件传递请求对象，响应对象和尾触发函数，通过队列形成处理流 ，如图 connect核心实现1234567891011121314function createServer() &#123; //创建了http服务器的request事件处理函数 function app(req,res) &#123;app.handle(req,res);&#125; utils.merge(app,proto); utils.merge(app,EventEmitter.prototype); app.route = '/'; //stack属性是这个服务器内部维护的中间件队列，代码在use()方法中提现 app.stack = []; for(var i=0;i&lt;arguments.length;++i)&#123; app.use(arguments[i]) &#125; return app;&#125; use()重要部分1234567app.use = function(route,fn)&#123;//some coede this.stack.push(&#123;route:route,handle:fn&#125;)return this;&#125; 实现监听12345app.listen = function () &#123; var server = http.createServer(this); return server.listen.apply(server,arguments);&#125; app.handle(),每一个监听到的网络请求都将从这里开始处理123app.handle = function(req,res,out) &#123; next();&#125;]]></content>
      <tags>
        <tag>node</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[node.js深入浅出笔记2]]></title>
    <url>%2F2017%2F08%2F26%2Fnode-js%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E7%AC%94%E8%AE%B02%2F</url>
    <content type="text"><![CDATA[node异步 I/O事件循环 进程启动时，node会创建一个类似于while(true)的循环，每次执行一次循环我们称为tick，每个tick过程就是查看是否有事件待处理，有就取出相关的回调函数，存在回调就执行，否则让进入下个循环 如图所示 观察者 监听每个事件处理，需要一个或者多个观察者，有观察者确定事件是否要被处理。事件循环是一个典型的生产者/消费者模型,异步i/o，网络请求等则是事件的生产者，源源不断的提供node不同类型的事件，这些事件被传递到观察者哪里，事件循环则是从观察者哪里取出事件并且处理 win 基于IOCP linux基于多线程 请求对象 node中的异步i/o调用而言，回调函数不是由开发者调用，实际上是javascript发起调用到内核执行完i/o操作的过度产物中，存在一种中间产物，他叫做请求对象，所有状态都保存在这个对象中，包括送入线程池等待执行以及i/o操作完毕后的回调函数 执行回调 如图所示 事件循环 观察者 请求对象 I/O线程池共同构成了node异步i/o模型的基本要素 小结:JavaScript是单线程，但是node本身是多线程。除了用户自身的代码无法并行执行外，其他的i/o都是可以并行的 非I/O的异步API 他们是 setTimeout() setInterval() setImmediate() process.nextTick() setTimeout 与setInterval() 与浏览器api一致，他们不需要i/o线程池的参加,下面是图示 process.nextTick(callback) 类似setTimeout 但是执行效率比较高 12345678910111213process.nextTick = function(callback)&#123; if(process._exiting) return; if(tickDepth &gt;=process.maxTickDepth) maxTickWarn(); var tock = &#123;callback : callback&#125; if(process.domain) tock.domain = process.domain; nextTickQueue.push(tock); if(nextTickQueue.length)&#123; process._needTickCallback(); &#125;&#125; setImmediate() 类似于process.nextTick() 都是将函数延迟执行 12345678910111213141516171819202122232425262728process.nextTick(function()&#123; console.log("延迟执行");&#125;)console.log("正常执行");//正常执行//延迟执行//两者的优先级setImmediate(function()&#123; console.log("延迟执行setImmediate");&#125;)process.nextTick(function()&#123; console.log("延迟执行nextTick");&#125;)console.log("正常执行");// 正常执行// 延迟执行nextTick// 延迟执行setImmediate 事件循环是有先后顺序的 process.nextTick()属于idle观察者,setImmediate()属于check观察者 idle优于观察者i/o优于观察者check process.nextTick()回调函数保存在数组中，每轮循环回到函数全部执行完，而setImmediate()保存在链表中，每轮循环中执行链表中的一个回调函数 一下就是例子,好像不对，运行结果有问题啊 123456789101112131415161718192021222324252627282930313233process.nextTick(function()&#123; console.log("延迟执行nextTick1"); &#125;)process.nextTick(function()&#123; console.log("延迟执行nextTick2");&#125;)setImmediate(function()&#123; console.log("延迟执行setImmediate1"); process.nextTick(function()&#123; console.log("我也执行l ");&#125;)&#125;) setImmediate(function()&#123; console.log("延迟执行setImmediate2");&#125;)console.log("正常执行");// 正常执行// 延迟执行nextTick1// 延迟执行nextTick2// 延迟执行setImmediate1// 延迟执行setImmediate2// 我也执行l 事件驱动与高性能服务器 利用node构建的服务器，基于以下实现]]></content>
      <tags>
        <tag>node</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[node.js深入浅出笔记1]]></title>
    <url>%2F2017%2F08%2F25%2Fnode-js%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E7%AC%94%E8%AE%B07%2F</url>
    <content type="text"><![CDATA[commonjs的模块定义 模块引用 ，模块定义 模块标识 模块引用12var math = require('math'); //require用于引用一个api模块，括号里面的称为模块标识 模块的定义 在node中，一个文件就是一个模块，将方法挂在到exports对象上作为属性可以导出 12345exports.add = function(a,b)&#123; return a+b&#125;//export 是唯一导出方法的方式 模块标识 指的就是require()中的参数 核心模块 http fs path等 .或者..开始的相对路劲的文件模块 以/开始的绝对路劲的模块 非路径形式的模块文件，自定模块 node 的模块实现 引入模块需要经历三个步奏 路劲定位 文件定位 编译执行 核心模块与用户模块的区别以及加载速度 核心模块，在node启动时已经被编译好了，核心部分都写在内存，只需做路劲分析就好，加载速度最快 文件模块，则是运行时动态加载，以上路径分析，文件定位，编译都要走，所以最慢呀 优先加载缓存 核心模块，和用户模块都会被缓存，优先去取缓存的东西，顺序–&gt; 缓存核心模块&lt;-&lt;-缓存用户模块&lt;-核心模块&lt;-用户模块 文件定位 扩展名分析 : 查找顺序 .js &gt; .node &gt; .json 目录分析和包 : 首先会检查包下面的package.json ,通过json.parse() 取出main属性指定文件名进行定位，如果main错误或不存在，则默认index文件名查找，还没找到就抛出异常 模块的编译 module对象 12345678910111213function Module(id,parent)&#123; this.id = id ; this.exports =&#123;&#125;; this.parent = parent; if(parent &amp;&amp; parent.children) &#123; parent.children.push(this); &#125; this.filename = null; this.loaded = false; this.children = [];&#125; 载入以及编译 .js 用fs模块同步读取文件后进行编译 .node 这是c/c++编写的扩展文件，通过dlopen()方式进行加载最后编译生成的文件 .json 用fs模块同步读取文件后，用JSON.parse()解析返回结果 其余扩展名，都被当做.js文件载入 每个编译成功的模块，路劲作为索引都会缓存在Module.cache对象上 举个.json的加载的例子1234567891011Module._extensoins[.json] = function(module,filename)&#123; va content = NativeModule.require('fs').readFileSync(filename,'utf-8');\ try&#123; module.exports = JSON,parse(stripBOM(content)); &#125; catch (err) &#123; err.message = filename + ":" +err.message; throw err; &#125;&#125;//Module._extensions 会被赋值给require()的extensions属性 Javascript模块的编译 由于模块文件实际在编译过程会被node包装，所以我们才可以调用几个常用的方法，包装后通过vm原生模块runInThisContext()方法执行（类似eval,有明确上下文，不污染全局），返回function对象 1234567//包装后(function(exports,require,module,_filename,_dirname)&#123; //模块内容 &#125;) 编译核心模块 源文件通过process.binding(‘natives’)取出，编译成功的模块缓存到NativeModule._cache对象上，文件模块则缓存Module.cache对象上 123456789function NativeModule(id) &#123; this.filename = id + '.js'; this.id = id; this.exports = &#123;&#125; this.loaded = false;&#125;NativeModule._source = process.binding('natives');NativeModule._cache = &#123;&#125;; c/c++核心模块的编译 由纯c/c++编写的部分统一称为内建模块，通常不被用户直接调用 内建模块的导出 (依赖关系) 1文件模块 &lt;--- 核心模块(javascript) &lt;---内建模块(c/c++) 加载内建模块时，先创建exports空对象，然后调用get_builtin_module()方法取出内建模块对象，通过执行register_func()填充exports对象，最后将exports对象按模块名缓存，并返回给调用方完成导出 包与npm commonjs规范:前者用于组织包中的各种的文件，后者则用于描述包的相关信息，以供外部读取分析 包结构（符合commonjs规范） package.json:包描述文件 bin:存放二进制文件的目录 lib:用于存放JavaScript代码的目录 doc:用于存放文档的目录 test:用于存放单元测试的代码 包描述文件（package.josn）与npm 参考之前的文章 npm常用功能 查看帮助 npm -v 安装依赖包 npm i package]]></content>
      <tags>
        <tag>node</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[小幸运]]></title>
    <url>%2F2017%2F08%2F24%2F%E5%B0%8F%E5%B9%B8%E8%BF%90%2F</url>
    <content type="text"><![CDATA[我听见雨滴落在青青草地我听见远方下课钟声响起可是我没有听见你的声音认真 呼唤我姓名 爱上你的时候还不懂感情离别了才觉得刻骨 铭心为什么没有发现遇见了你是生命最好的事情 也许当时忙着微笑和哭泣忙着追逐天空中的流星人理所当然的忘记是谁风里雨里一直默默守护在原地 原来你是我最想留住的幸运原来我们和爱情曾经靠得那么近那为我对抗世界的决定那陪我淋的雨一幕幕都是你 一尘不染的真心 与你相遇 好幸运可我已失去为你泪流满面的权利但愿在我看不到的天际你张开了双翼遇见你的注定 (oh–) 她会有多幸运 青春是段跌跌撞撞的旅行拥有着后知后觉的美丽来不及感谢是你给我勇气让我能做回我自己]]></content>
      <tags>
        <tag>音乐</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[心情日记]]></title>
    <url>%2F2017%2F08%2F24%2F%E5%BF%83%E6%83%85%E6%97%A5%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[致橡树我如果爱你——绝不像攀援的凌霄花，借你的高枝炫耀自己；我如果爱你——绝不学痴情的鸟儿，为绿荫重复单调的歌曲；也不止像泉源，常年送来清凉的慰藉；也不止像险峰，增加你的高度，衬托你的威仪。甚至日光，甚至春雨。不，这些都还不够！我必须是你近旁的一株木棉，作为树的形象和你站在一起。根，紧握在地下；叶，相触在云里。每一阵风过，我们都互相致意，但没有人，听懂我们的言语。你有你的铜枝铁干，像刀，像剑，也像戟；我有我红硕的花朵，像沉重的叹息，又像英勇的火炬。我们分担寒潮、风雷、霹雳；我们共享雾霭、流岚、虹霓。仿佛永远分离，却又终身相依。这才是伟大的爱情，坚贞就在这里：爱——不仅爱你伟岸的身躯，也爱你坚持的位置，足下的土地。]]></content>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[babel]]></title>
    <url>%2F2017%2F08%2F23%2Fbabel%2F</url>
    <content type="text"><![CDATA[什么是es5 Babel是一个转码器，可以将es6的代码转换成es5，以下参照阮一峰大神的博客 举个例子 箭头函数 123456789//es6var sum = (a,b) =&gt; (a+b)//转成es5var sum = function(a,b)&#123; return a+b&#125; 配置文件 .babelrc Babel 的配置文件是.babelrc，存放在项目的根目录下。使用 Babel 的第一步，就是配置这个文件用，用来设置转码规则和插件。 基本格式如下 12345&#123; "presets": [], "plugins": []&#125; presets字段用于设置转码规则 123456789101112//cnpm 我装了淘宝镜像，npm 也行的# 最新转码规则 cnpm install --save-dev babel-preset-latest# react 转码规则 cnpm install --save-dev babel-preset-react# 不同阶段语法提案的转码规则（共有4个阶段），选装一个 cnpm install --save-dev babel-preset-stage-0 cnpm install --save-dev babel-preset-stage-1 cnpm install --save-dev babel-preset-stage-2 cnpm install --save-dev babel-preset-stage-3 12345678910 //.babelrc 配置 &#123; "presets": [ "latest", "react", "stage-2" ], "plugins": []&#125; 命令行转码babel-cli 全局安装1npm install --global babel-cli 基本用法 123456789101112131415161718# 转码结果输出到标准输出$ babel example.js# 转码结果写入一个文件# --out-file 或 -o 参数指定输出文件$ babel example.js --out-file compiled.js# 或者$ babel example.js -o compiled.js# 整个目录转码# --out-dir 或 -d 参数指定输出目录$ babel src --out-dir lib# 或者$ babel src -d lib# -s 参数生成source map文件$ babel src -d lib -s 上面代码是在全局环境下，进行 Babel 转码。这意味着，如果项目要运行，全局环境必须有 Babel，也就是说项目产生了对环境的依赖。另一方面，这样做也无法支持不同项目使用不同版本的 Babel 安装在项目中12# 安装$ npm install --save-dev babel-cli 改写package.json 123456789101112 &#123; // ... "devDependencies": &#123; "babel-cli": "^6.0.0" &#125;, "scripts": &#123; "build": "babel src -d lib" &#125;, &#125;` 运行1$ npm run build]]></content>
      <tags>
        <tag>babel</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[node.js开发指南笔记6]]></title>
    <url>%2F2017%2F08%2F16%2Fnode-js%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97%E7%AC%94%E8%AE%B06%2F</url>
    <content type="text"><![CDATA[模块加载机制 学习模块间是如何先后加载 模块的类型 Node.js 的模块可以分为两大类，一类是核心模块，另一类是文件模块。核心模块就是Node.js 标准 API 中提供的模块，如 fs 、 http 、 net 、 vm 等，这些都是由 Node.js 官方提供的模块，编译成了二进制代码。我们可以直接通过 require 获取核心模块，例如require(‘fs’) 。核心模块拥有最高的加载优先级，换言之如果有模块与其命名冲突，Node.js 总是会加载核心模块 文件模块则是存储为单独的文件（或文件夹）的模块，可能是 JavaScript 代码、JSON 或编译好的 C/C++ 代码。文件模块的加载方法相对复杂，但十分灵活，尤其是和 npm 结合使用时。在不显式指定文件模块扩展名的时候，Node.js 会分别试图加上 .js、.json 和 .node扩展名。.js 是 JavaScript 代码，.json 是 JSON 格式的文本，.node 是编译好的 C/C++ 代码。 按路径加载模块 文件模块的加载有两种方式，一种是按路径加载，一种是查找 node_modules 文件夹。 如果 require 参数以“ / ”开头，那么就以绝对路径的方式查找模块名称，例如 require(‘/home/byvoid/module’) 将会按照优先级依次尝试加载 /home/byvoid/module.js、/home/byvoid/module.json 和 /home/byvoid/module.node。 如果 require 参数以“ ./ ”或“ ../ ”开头，那么则以相对路径的方式来查找模块，这种方式在应用中是最常见的。例如前面的例子中我们用了 require(‘./hello’) 来加载同一文件夹下的hello.js。 通过查找 node_modules 目录加载模块 如果 require 参数不以“ / ”、“ ./ ”或“ ../ ”开头，而该模块又不是核心模块,直接使用 require(‘express’) 来代替require(‘./node_modules/express’) 。这是Node.js模块加载的一个重要特性：通过查找 node_modules 目录来加载模块 加载缓存 Node.js 模块不会被重复加载，这是因为 Node.js 通过文件名缓存所有加载过的文件模块，所以以后再访问到时就不会重新加载了,注意，Node.js 是根据实际文件名缓存的，而不是 require() 提供的参数缓存的，也就是说即使你分别通过require(‘express’) 和 require(‘./node_modules/express’) 加载两次，也不会重复加载，因为尽管两次参数不同，解析到的文件却是同一个 加载顺序 下面总结一下使用 require(some_module) 时的加载顺序。 (1) 如果 some_module 是一个核心模块，直接加载，结束。 (2) 如果 some_module 以“ / ”、“ ./ ”或“ ../ ”开头，按路径加载 some_module ，结束。 (3) 假设当前目录为 current_dir，按路径加载 current_dir/node_modules/some_module。 如果加载成功，结束 如果加载失败，令current_dir为其父目录。 - 重复这一过程，直到遇到根目录，抛出异常，结束。 异步存在的陷阱 for循环的陷阱 123456789101112131415var fs = require('fs');var files = ['a.txt','b.txt','c.txt'];for(var i=0;i&lt;files.length;i++)&#123; fs.readFile(files[i],'utf-8',function(err,contents)&#123; console.log(i,12); console.log(files[i]+':'+contents); &#125;);&#125;//undefined: AAA//undefined: BBB//undefined: CCC 因为循环 i值直接变成3,在调回调函数时files[3]为空 12345678910111213141516171819202122//闭包解决var fs = require('fs');var files = ['a.txt', 'b.txt', 'c.txt'];for (var i = 0; i &lt; files.length; i++) &#123;(function(i) &#123;fs.readFile(files[i], 'utf-8', function(err, contents) &#123;console.log(files[i] + ': ' + contents);&#125;);&#125;)(i);&#125;//forEach解决var fs = require('fs');var files = ['a.txt', 'b.txt', 'c.txt'];files.forEach(function(filename) &#123;fs.readFile(filename, 'utf-8', function(err, contents) &#123;console.log(filename + ': ' + contents);&#125;);&#125;); 解决控制流难题 async：async 是一个控制流解耦模块，它提供了async.series 、 async.parallel 、 async.waterfall 等函数，在实现复杂的逻辑时使用这些函数代替回调函数嵌套可以让程序变得更清晰可读且易于维护，但你必须遵循它的编程风格 streamlinejs和jscex则采用了更高级的手段，它的思想是“变同步为异步”，实现了一个JavaScript 到JavaScript 的编译器，使用户可以用同步编程的模式写代码，编译后执行时却是异步的 eventproxy 的思路与前面两者区别更大，它实现了对事件发射器的深度封装，采用一种完全基于事件松散耦合的方式来实现控制流的梳理。 日志输出 用express 的函数12345678910//生产环境var accessLog = fs.createWriteStream('access.log',&#123;flags:'a'&#125;);app.use(logger('combined', &#123;stream : accessLog&#125;));//开发环境var accessLog = fs.createWriteStream('access.log',&#123;flags:'a'&#125;);app.use(logger('dev',&#123;stream : accessLog&#125;)); 使用 cluster 模块 Node.js 提供了一个核心模块： cluster 。 cluster 的功能是生成与当前进程相同的子进程，并且允许父进程和子进程之间共享端口。Node.js 的另一个核心模块child_process 也提供了相似的进程生成功能，但最大的区别在于 cluster 允许跨进程端口复用，给我们的网络服务器开发带来了很大的方便]]></content>
      <tags>
        <tag>node</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[node.js开发指南笔记5(express]]></title>
    <url>%2F2017%2F08%2F15%2Fnode-js%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97%E7%AC%94%E8%AE%B05-express%2F</url>
    <content type="text"><![CDATA[app.js1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465var express = require('express');var path = require('path');var favicon = require('serve-favicon');// morgan中间件记录日志var logger = require('morgan');//cookie存储 var cookieParser = require('cookie-parser');// 可以通过body-parser 对象创建中间件，当接收到客户端请求时所有的中间件都会给req.body 添加属性，请求体为空，则解析为空&#123;&#125; （或者出现错误）。var bodyParser = require('body-parser');// 配置路由var index = require('./routes/index');var users = require('./routes/users');var app = express();// 目录的配置 path.join() 方法使用平台特定的分隔符把全部给定的 path 片段连接到一起，并规范化生成的路径app.set('views', path.join(__dirname, 'views'));app.set('view engine', 'jade');// 设置小图标iconapp.use(favicon(path.join(__dirname, 'public', 'icon.ico')));// 可以将请求信息打印在控制台，便于开发调试app.use(logger('dev'));//生产环境则需要这么做,打印到log日志里面，在根目录// app.use(logger('combined', &#123;stream : accessLog&#125;));// 这个方法返回一个仅仅用来解析json格式的中间件。这个中间件能接受任何body中任何Unicode编码的字符。支持自动的解析gzip和 zlib。app.use(bodyParser.json());// 这个方法也返回一个中间件，这个中间件用来解析body中的urlencoded字符， 只支持utf-8的编码的字符。同样也支持自动的解析gzip和 zlibapp.use(bodyParser.urlencoded(&#123; extended: false &#125;));app.use(cookieParser());// 设置可以访问的静态目录app.use(express.static(path.join(__dirname, 'public')));app.use('/', index);app.use('/users', users);// 捕捉404事件app.use(function(req, res, next) &#123; var err = new Error('Not Found'); err.status = 404; next(err);&#125;);// 错误事件处理app.use(function(err, req, res, next) &#123; // set locals, only providing error in development res.locals.message = err.message; res.locals.error = req.app.get('env') === 'development' ? err : &#123;&#125;; // 渲染页面错误 res.status(err.status || 500); res.render('error');&#125;);module.exports = app;]]></content>
      <tags>
        <tag>node</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jsTips-1]]></title>
    <url>%2F2017%2F08%2F15%2FjsTips-1%2F</url>
    <content type="text"><![CDATA[闭包12345678910111213var generateClosure = function() &#123;var count = 0;var get = function() &#123;count ++;return count;&#125;;return get;&#125;;var counter = generateClosure();console.log(counter()); // 输出 1console.log(counter()); // 输出 2console.log(counter()); // 输出 3 这段代码中， generateClosure() 函数中有一个局部变量 count ，初值为 0。还有一个叫做 get 的函数， get 将其父作用域，也就是 generateClosure() 函数中的 count 变量增加 1，并返回 count 的值。 generateClosure() 的返回值是 get 函数。在外部我们通过 counter 变量调用了 generateClosure() 函数并获取了它的返回值，也就是 get 函数，接下来反复调用几次 counter() ，我们发现每次返回的值都递增了 1。 让我们看看上面的例子有什么特点，按照通常命令式编程思维的理解， count 是generateClosure 函数内部的变量，它的生命周期就是 generateClosure 被调用的时期，当 generateClosure 从调用栈中返回时， count 变量申请的空间也就被释放。问题是，在 generateClosure() 调用结束后， counter() 却引用了“已经释放了的” count变量，而且非但没有出错，反而每次调用 counter() 时还修改并返回了 count 。这是怎么回事呢 这正是所谓闭包的特性。当一个函数返回它内部定义的一个函数时，就产生了一个闭包，闭包不但包括被返回的函数，还包括这个函数的定义环境。上面例子中，当函数generateClosure() 的内部函数 get 被一个外部变量 counter 引用时， counter 和generateClosure() 的局部变量就是一个闭包。如果还不够清晰，下面这个例子可以帮助你理解： 12345678910111213141516var generateClosure = function() &#123;var count = 0;var get = function() &#123;count ++;return count;&#125;;return get;&#125;;var counter1 = generateClosure();var counter2 = generateClosure();console.log(counter1()); // 输出 1console.log(counter2()); // 输出 1console.log(counter1()); // 输出 2console.log(counter1()); // 输出 3console.log(counter2()); // 输出 2 上面这个例子解释了闭包是如何产生的： counter1 和 counter2 分别调用了 generate-Closure() 函数，生成了两个闭包的实例，它们内部引用的 count 变量分别属于各自的运行环境。我们可以理解为，在 generateClosure() 返回 get 函数时，私下将 get 可能引用到的 generateClosure() 函数的内部变量（也就是 count 变量）也返回了，并在内存中生成了一个副本，之后 generateClosure() 返回的函数的两个实例 counter1和 counter2 就是相互独立的了。 理解 bind12345678910111213var someuser = &#123;name: 'byvoid',func: function () &#123;console.log(this.name);&#125;&#125;;var foo = &#123;name: 'foobar'&#125;;func = someuser.func.bind(foo);func(); // 输出 foobarfunc2 = func.bind(someuser);func2(); // 输出 foobar 全局函数 func 通过 someuser.func.bind 将 this 指针绑定到了 foo ，调用 func() 输出了 foobar 。我们试图将 func2 赋值为已绑定的 func 重新通过 bind 将 this 指针绑定到someuser 的结果，而调用 func2 时却发现输出值仍为 foobar ，即 this 指针还是停留在 foo对象上，这是为什么呢？要想解释这个现象，我们必须了解 bind 方法的原理 gulp-smushit 压缩图片]]></content>
      <tags>
        <tag>tips</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[node.js开发指南笔记4]]></title>
    <url>%2F2017%2F08%2F14%2Fnode-js%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97%E7%AC%94%E8%AE%B04%2F</url>
    <content type="text"><![CDATA[使用 http 模块1234567891011121314151617//html页面&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;form method="post" action="http://localhost:3000"&gt; &lt;input type="text" name="name"&gt; &lt;input type="number" name="age"&gt; &lt;input type="submit"&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 123456789101112131415161718192021222324// http服务器var http = require("http");var querystring = require('querystring');var util = require("util");http.createServer(function(req,res)&#123; var post = ""; req.on('data',function(thunk)&#123; post +=thunk; &#125;) req.on('end',function()&#123; post = querystring.parse(post); res.writeHead(200,&#123;"Content-Type":'text/html;charset=utf-8'&#125;); res.write("开始"); res.write(util.inspect(post)); res.end("结束"); &#125;) &#125;).listen(3000); 学习express框架 bin/www 部分 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293#!/usr/bin/env node/** * Module dependencies. */var app = require('../app');var debug = require('debug')('microblog:server');var http = require('http');/** * 配置端口号 */console.log(process.env.PORT);var port = normalizePort(process.env.PORT || '3000');app.set('port', port);/** * 创建http服务 */var server = http.createServer(app);/** * 监听接口以及所有的接口方法以及抛出的异常 */server.listen(port);server.on('error', onError);server.on('listening', onListening);/** * 把数字，字符串转换成端口号，实在是难转的就返回false */function normalizePort(val) &#123; var port = parseInt(val, 10); if (isNaN(port)) &#123; // named pipe return val; &#125; if (port &gt;= 0) &#123; // port number return port; &#125; return false;&#125;/** * 监听事件抛出的异常 */function onError(error) &#123; if (error.syscall !== 'listen') &#123; //error.syscall一个表示失败的系统调用信息的字符串 throw error; &#125; console.log(typeof port,1212); var bind = typeof port === 'string' ? 'Pipe ' + port : 'Port ' + port; // 绑定特定的端口号异常情况 switch (error.code) &#123; case 'EACCES': //eacces权限不够 console.error(bind + ' requires elevated privileges'); process.exit(1); break; case 'EADDRINUSE': //端口号被占用的情况 console.error(bind + ' is already in use'); process.exit(1); //结束进程 break; default: throw error; &#125;&#125;/** * http发出的请求. */function onListening() &#123; var addr = server.address(); console.log(121212,addr); var bind = typeof addr === 'string' ? 'pipe ' + addr : 'port ' + addr.port; debug('Listening on ' + bind); //debugger模式监听 console.log('Listening on' + bind);&#125;]]></content>
      <tags>
        <tag>node</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[node.js开发指南笔记3]]></title>
    <url>%2F2017%2F08%2F13%2Fnode-js%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97%E7%AC%94%E8%AE%B03%2F</url>
    <content type="text"><![CDATA[文件系统 fs fs 模块是文件操作的封装，它提供了文件的读取、写入、更名、删除、遍历目录、链接等 POSIX 文件系统操作。 fs.readFile() 异步操作 fs.readFile(filename,[encoding],[callback(err,data)]) 是最简单的读取文件的函数。它接受一个必选参数 filename ，表示要读取的文件名。第二个参数 encoding是可选的，表示文件的字符编码。 callback 是回调函数，用于接收文件的内容。如果不指定 encoding ，则 callback 就是第二个参数。回调函数提供两个参数 err 和 data ， err 表示有没有错误发生， data 是文件内容。如果指定了 encoding ， data 是一个解析后的字符串，否则 data 将会是以 Buffer 形式表示的二进制数据 不指定编码 123456789101112var fs = require('fs');fs.readFile('content.txt', function(err, data) &#123;if (err) &#123;console.error(err);&#125; else &#123;console.log(data);&#125;&#125;);//输出的内容&lt;Buffer 54 65 78 74 20 e6 96 87 e6 9c ac e6 96 87 e4 bb b6 e7 a4 ba e4 be 8b&gt; tips：Node.js 的异步编程接口习惯是以函数的最后一个参数为回调函数，通常一个函数只有一个回调函数。回调函数是实际参数中第一个是 err ，其余的参数是其他返回的内容。如果没有发生错误， err 的值会是 null 或undefined 。如果有错误发生， err 通常是 Error 对象的实例。 fs.readFileSync() 同步操作 fs.readFileSync(filename, [encoding]) 是 fs.readFile 同步的版本。它接受的参数和 fs.readFile 相同，而读取到的文件内容会以函数返回值的形式返回。如果有错误发生， fs 将会抛出异常，你需要使用 try 和 catch 捕捉并处理异常 fs.open fs.open(path, flags, [mode], [callback(err, fd)]) 是 POSIX open 函数的封装，与 C 语言标准库中的 fopen 函数类似。它接受两个必选参数， path 为文件的路径，flags 可以是以下值 r ：以读取模式打开文件。 r+ ：以读写模式打开文件。 w ：以写入模式打开文件，如果文件不存在则创建。 w+ ：以读写模式打开文件，如果文件不存在则创建。 a ：以追加模式打开文件，如果文件不存在则创建。 a+ ：以读取追加模式打开文件，如果文件不存在则创建 mode 参数用于创建文件时给文件指定权限，默认是 0666。回调函数将会传递一个文件描述符 fs.read fs.read(fd, buffer, offset, length, position, [callback(err, bytesRead,buffer)]) 是 POSIX read 函数的封装，相比 fs.readFile 提供了更底层的接口。 fs.read的功能是从指定的文件描述符 fd 中读取数据并写入 buffer 指向的缓冲区对象。 offset 是buffer 的写入偏移量。 length 是要从文件中读取的字节数。 position 是文件读取的起始位置，如果 position 的值为 null ，则会从当前文件指针的位置读取。回调函数传递bytesRead 和 buffer ，分别表示读取的字节数和缓冲区对象。 12345678910111213141516171819var fs = require('fs');fs.open('text.txt','r',function(err,fd)&#123; if(err)&#123; return; &#125; var buf = new Buffer(20); fs.read(fd,buf,0,20,null,function(err,bytesRead,buffer)&#123; if(err)&#123; return; &#125; console.log("bytesRead:"+bytesRead); //bytesRead:20 console.log(buffer);//&lt;Buffer e8 b6 8a e5 8a aa e5 8a 9b ef bc 8c e8 b6 8a e5 b9 b8 e8 bf&gt; fs.close(fd) &#125;)&#125;) HTTP 服务器与客户端 Node.js 标准库提供了 http 模块，其中封装了一个高效的 HTTP 服务器和一个简易的HTTP 客户端。 http.Server 是一个基于事件的 HTTP 服务器，它的核心由 Node.js 下层 C++部分实现，而接口由 JavaScript 封装，兼顾了高性能与简易性。 http.request 则是一个HTTP 客户端工具，用于向 HTTP 服务器发起请求，例如实现 Pingback或者内容抓取 HTTP 服务器12345678var http = require('http');http.createServer(function(req,res)&#123; res.writeHead(200,&#123;'Content-Type':'text/html;charset=utf-8'&#125;); res.write('在学习'); res.end("node");&#125;).listen(3000); http.Server 的事件 request ：当客户端请求到来时，该事件被触发，提供两个参数 req 和 res ，分别是http.ServerRequest 和 http.ServerResponse 的实例，表示请求和响应信息 connection ：当 TCP 连接建立时，该事件被触发，提供一个参数 socket ，为net.Socket 的实例。 connection 事件的粒度要大于 request ，因为客户端在Keep-Alive 模式下可能会在同一个连接内发送多次请求 close ：当服务器关闭时，该事件被触发。注意不是在用户连接断开时。 以上例子的其实显示表达应该这样写 12345678910var http = require('http'); var server = new http.Server(); server.on('request',function(req,res)&#123; res.writeHead(200,&#123;'Content-Type':'text/html;charset=utf-8'&#125;); res.write("操作一波"); res.end("来呀"); &#125;) server.listen(4000) http.ServerRequest http.ServerRequest 是 HTTP 请求的信息，是后端开发者最关注的内容。它一般由http.Server 的 request 事件发送，作为第一个参数传递，通常简称 request 或 req 。ServerRequest 提供一些属性 HTTP 请求一般可以分为两部分：请求头（Request Header）和请求体（Requset Body）。以上内容由于长度较短都可以在请求头解析完成后立即读取。而请求体可能相对较长，需要一定的时间传输，因此 http.ServerRequest 提供了以下3个事件用于控制请求体传输 data ：当请求体数据到来时，该事件被触发。该事件提供一个参数 chunk ，表示接收到的数据。如果该事件没有被监听，那么请求体将会被抛弃。该事件可能会被调用多次 end ：当请求体数据传输完成时，该事件被触发，此后将不会再有数据到来 close ： 用户当前请求结束时，该事件被触发。不同于 end ，如果用户强制终止了传输，也还是调用 close ServerRequest 的属性 complete 客户端请求是否已经发送完成 httpVersion HTTP 协议版本，通常是 1.0 或 1.1 method HTTP 请求方法，如 GET、POST、PUT、DELETE 等 url 原始的请求路径，例如 /static/image/x.jpg 或 /user?name=byvoid headers HTTP 请求头 trailers HTTP 请求尾（不常见） connection 当前 HTTP 连接套接字，为 net.Socket 的实例 socket connection 属性的别名 client client 属性的别名 获取 GET 请求内容 通过Node.js 的 url 模块中的 parse 函数提供了这个功能 123456789101112131415161718192021222324var http = require('http');var url = require('url');var util = require('util');http.createServer(function(req,res)&#123; res.writeHead(200,&#123;'Content-Type':'text/html;charset=utf-8'&#125;); res.end(util.inspect(url.parse(req.url, true)));&#125;).listen(3000)/*Url &#123; protocol: null, slashes: null, auth: null, host: null, port: null, hostname: null, hash: null, search: '?name=ly&amp;email=ly@ly.com%EF%BC%8C%E6%88%91', query: &#123; name: 'ly', email: 'ly@ly.com，我' &#125;, pathname: '/user', path: '/user?name=ly&amp;email=ly@ly.com%EF%BC%8C%E6%88%91', href: '/user?name=ly&amp;email=ly@ly.com%EF%BC%8C%E6%88%91' &#125;*/ 获取 POST 请求内容 1234567891011121314var http = require('http'); var querystring = require('querystring'); var util = require('util'); http.createServer(function(req,res)&#123; var post = ""; req.on('data',function(chunk)&#123; post +=chunk; &#125;) req.on('end',function()&#123; post = querystring.parse(post); res.end(util.inspect(post)) &#125;) &#125;).listen(3000);//&#123; name: 'ly', age: '18\n' &#125; 用postman测试 上面代码并没有在请求响应函数中向客户端返回信息，而是定义了一个 post 变量，用于在闭包中暂存请求体的信息。通过 req 的 data 事件监听函数，每当接受到请求体的数据，就累加到 post 变量中。在 end 事件触发后，通过 querystring.parse 将 post 解析为真正的 POST 请求格式，然后向客户端返回 tips：不要在真正的生产应用中使用上面这种简单的方法来获取 POST 请求，因为它有严重的效率问题和安全问题 http.ServerResponse http.ServerResponse 是返回给客户端的信息，决定了用户最终能看到的结果。它也是由 http.Server 的 request 事件发送的，作为第二个参数传递，一般简称为response 或 res response.writeHead(statusCode, [headers]) ：向请求的客户端发送响应头。statusCode 是 HTTP 状态码，如 200 （请求成功）、404 （未找到）等。 headers是一个类似关联数组的对象，表示响应头的每个属性。该函数在一个请求内最多只能调用一次，如果不调用，则会自动生成一个响应头 response.write(data, [encoding]) ：向请求的客户端发送响应内容。 data 是一个 Buffer 或字符串，表示要发送的内容。如果 data 是字符串，那么需要指定encoding 来说明它的编码方式，默认是 utf-8 。在 response.end 调用之前，response.write 可以被多次调用。 response.end([data], [encoding]) ：结束响应，告知客户端所有发送已经完成。当所有要返回的内容发送完毕的时候，该函数 必须 被调用一次。它接受两个可选参数，意义和 response.write 相同。如果不调用该函数，客户端将永远处于等待状态 HTTP 客户端 http 模块提供了两个函数 http.request 和 http.get ，功能是作为客户端向 HTTP服务器发起请求 http.request(options, callback) 发起 HTTP 请求。接受两个参数， option 是一个类似关联数组的对象，表示请求的参数， callback 是请求的回调函数。 option常用的参数如下所示 host ：请求网站的域名或 IP 地址。 port ：请求网站的端口，默认 80。 method ：请求方法，默认是 GET。 path ：请求的相对于根的路径，默认是“ / ”。 QueryString 应该包含在其中。例如 /search?query=byvoid 。 headers ：一个关联数组对象，为请求头的内容 callback 传递一个参数，为 http.ClientResponse 的实例 123456789101112131415161718192021222324252627282930var http = require('http');var querystring = require('querystring');var contents = querystring.stringify(&#123; name:'ly', age:'18'&#125;);var options =&#123; host:'127.0.0.9', port:3000, path:'/server.js', method:'POST', headers:&#123; 'Content-Type':"application/x-www-form-urlencoded", 'Content-Length':contents.length &#125;&#125;var req = http.request(options,function(res)&#123; res.setEncoding('utf8'); res.on("data",function(data)&#123; console.log(data); &#125;)&#125;)req.write(contents);req.end(); 简化版的get请求1234567var http = require('http');http.get(&#123;host: 'www.byvoid.com'&#125;, function(res) &#123;res.setEncoding('utf8');res.on('data', function (data) &#123;console.log(data);&#125;);&#125;); http.ClientRequest http.ClientRequest 是由 http.request 或 http.get 返回产生的对象，表示一个已经产生而且正在进行中的 HTTP 请求。它提供一个 response 事件，即 http.request或 http.get 第二个参数指定的回调函数的绑定对象 12345678var http = require('http');var req = http.get(&#123;host: 'www.baidu.com'&#125;);req.on('response', function(res) &#123;res.setEncoding('utf8');res.on('data', function (data) &#123;console.log(data);&#125;);&#125;); http.ClientRequest 像 http.ServerResponse 一样也提供了 write 和 end 函数，用于向服务器发送请求体，通常用于 POST、PUT 等操作。所有写结束以后必须调用 end函数以通知服务器，否则请求无效。 http.ClientRequest 还提供了以下函数 request.abort() ：终止正在发送的请求。 request.setTimeout(timeout, [callback]) ：设置请求超时时间， timeout 为毫秒数。当请求超时以后， callback 将会被调用 http.ClientResponse http.ClientResponse 与 http.ServerRequest 相似，提供了三个事件 data 、 end和 close ，分别在数据到达、传输结束和连接结束时触发，其中 data 事件传递一个参数chunk ，表示接收到的数据 statusCode HTTP 状态码，如 200、404、500 httpVersion HTTP 协议版本，通常是 1.0 或 1.1 headers HTTP 请求头 trailers HTTP 请求尾（不常见） http.ClientResponse 还提供了以下几个特殊的函数 response.setEncoding([encoding]) ：设置默认的编码，当 data 事件被触发时，数据将会以 encoding 编码。默认值是 null ，即不编码，以 Buffer 的形式存储。常用编码为 utf8 response.pause() ：暂停接收数据和发送事件，方便实现下载功能。 response.resume() ：从暂停的状态中恢复]]></content>
      <tags>
        <tag>node</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[node.js开发指南笔记2]]></title>
    <url>%2F2017%2F08%2F11%2Fnode-js%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97%E7%AC%94%E8%AE%B02%2F</url>
    <content type="text"><![CDATA[Node.js核心模块 核心模块是 Node.js 的心脏，它由一些精简而高效的库组成，为 Node.js 提供了基本的 全局对象global node的全局对象是Global Object 它满足以下的条件 在最外层定义的变量 全局对象的属性 隐式定义的变量(未定义直接赋值的变量) tips:在定义变量一定要使用var定义 process 它用于描述当前 Node.js 进程状态的对象，提供了一个与操作系统的简单接口 peocess.argv 第一个元素是 node， 第二个元素是脚本文件名，从第三个元素开始每个元素是一个运行参数 process.stdout 标准输出流，通常我们使用的 console.log() 向标准输出打印字符，而 process.stdout.write() 函数提供了更底层的接口 1process.stdout.write("你的表演"); process.stdin 是标准输入流，初始时它是被暂停的，要想从标准输入读取数据，你必须恢复流，并手动编写流的事件响应函数 1234567process.stdin.resume();process.stdin.on('data',function()&#123; process.stdout.write('开始')&#125;)process.stdin.emit('data'); process.nextTick(callback) 的功能是为事件循环设置一项任务，Node.js 会在下次事件循环调响应时调用 callback 123456789101112131415161718192021222324function doSomething(args,callback)&#123; firsthing(); process.nextTick(callback);&#125;doSomething(process.argv,function onEnd()&#123; compute();&#125;)function firsthing()&#123; setTimeout(function()&#123; console.log("我出来了"); &#125;,3000);&#125;function compute()&#123; setTimeout(function()&#123; console.log("来呀"); &#125;,10000)&#125; process.platform process.pid process.execPath process.memoryUsage() 1234 console.log(process.platform); //win32console.log(process.pid); //9356console.log(process.execPath); //C:\Program Files\nodejs\node.execonsole.log(process.memoryUsage());//&#123; rss: 18862080,heapTotal: 7376896,heapUsed: 3260136,external: 8380 &#125; POSIX表示可移植操作系统接口（Portable Operating System Interface of UNIX，缩写为 POSIX ），POSIX标准定义了操作系统应该为应用程序提供的接口标准，是IEEE为要在各种UNIX操作系统上运行的软件而定义的一系列API标准的总称，其正式称呼为IEEE 1003，而国际标准名称为ISO/IEC 9945。 常用的工具集合util util 是一个 Node.js 核心模块，提供常用函数的集合，用于弥补核心 JavaScript 的功能过于精简的不足 util.inherits 实现一个对象间原型继承的函数 123456789101112131415161718192021222324252627282930313233343536var util = require('util');function Base() &#123; this.name = "base"; this.base = "1995"; this.sayHello = function()&#123; console.log('Hello'+this.name); &#125;&#125;Base.prototype.showName = function() &#123; console.log(this.name);&#125;function Sub() &#123; this.name = "sub"&#125;util.inherits(Sub, Base);var objBase = new Base();objBase.showName();objBase.sayHello();console.log(objBase);console.log("---------------------------");var objSub = new Sub();objSub.showName();// objSub.sayHello(); 只能继承原型的东西，构造函数内部东西不能被继承console.log(objSub); util.inspect(object,[showHidden],[depth],[colors]) object ：要转换的对象 showHidden 是一个可选参数，如果值为 true ，将会输出更多隐藏信息 depth 表示最大递归的层数，如果对象很复杂，你可以指定层数以控制输出信息的多少。如果不指定 depth ，默认会递归2层，指定为 null 表示将不限递归层数完整遍历对象。 如果 color 值为 true ，输出格式将会以 ANSI 颜色编码，通常用于在终端显示更漂亮的效果 12345678910111213var util = require('util');var obj =&#123; name:'ly', hello:function()&#123; console.log("再见"); &#125;&#125;console.log(util.inspect(obj)); //&#123; name: 'ly', hello: [Function: hello] &#125;console.log(util.inspect(obj,true)); //&#123; name: 'ly',hello:&#123; [Function: hello] [length]: 0,[name]: 'hello',[arguments]: null,[caller]: null,[prototype]: hello &#123; [constructor]: [Circular] &#125; &#125; &#125;console.log(util.inspect(obj,true,4,true)); 四个类型测试工具 util.isArray() util.isRegExp() util.isDate() util.isError() 1&lt;!-- 算了不测了都被废弃了 --&gt; 格式化以及调试工具 util.format() util.debuglog() 12345const util = require('util');const debuglog = util.debuglog('foo');debuglog('hello from foo [%d]', 123);&lt;!-- 很少用的感觉 --&gt; 事件驱动 events Node.js 本身架构就是事件式的，而它提供了唯一的接口，所以堪称 Node.js 事件编程的基石。 events 模块不仅用于用户代码与 Node.js 下层事件循环的交互，还几乎被所有的模块依赖。 事件发射器 EventEmitter.on(event, listener) 为指定事件注册一个监听器，接受一个字符串 event 和一个回调函数 listener EventEmitter.emit(event, [arg1], [arg2], […]) 发射 event 事件，传递若干可选参数到事件监听器的参数表 EventEmitter.once(event, listener) 为指定事件注册一个单次监听器，即监听器最多只会触发一次，触发后立刻解除该监听器。 EventEmitter.removeListener(event, listener) 移除指定事件的某个监听器， listener 必须是该事件已经注册过的监听器 EventEmitter.removeAllListeners([event]) 移除所有事件的所有监听器，如果指定 event ，则移除指定事件的所有监听器 setMaxListeners(n) 设定最大监听数，不能超过10个 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960 var events = require('events');var emitter = new events.EventEmitter();emitter.on('someEvent',function(arg1,arg2)&#123; console.log('listener1',arg1,arg2);&#125;);emitter.on('someEvent',function(arg1,arg2)&#123; console.log('listener2',arg1,arg2);&#125;);emitter.emit('someEvent',"ly",1995);// listener1 ly 1995// listener2 ly 1995console.log("----------移除绑定事件-----------------")// 移除绑定事件var s=function(arg1,arg2)&#123; console.log('listener1',arg1,arg2);&#125;emitter.on('add',s)emitter.emit('add',"ly",1996);emitter.removeListener("add",s);emitter.emit('add',"ly",1996);console.log("----------结束-----------------")console.log("----------只触发一次的函数-----------------");emitter.once('once',function()&#123; console.log('我只执行一次哈');&#125;);emitter.emit('once');emitter.emit('once');// 移除所有事件console.log("----------会执行-----------------");emitter.emit('someEvent',"ly",1995);emitter.removeAllListeners();console.log("----------不会执行-----------------");emitter.emit('someEvent',"ly",1995); EventEmitter 定义了一个特殊的事件 error ，它包含了“错误”的语义，我们在遇到异常的时候通常会发射 error 事件。当 error 被发射时， EventEmitter 规定如果没有响应的监听器，Node.js 会把它当作异常，退出程序并打印调用栈。我们一般要为会发射 error事件的对象设置监听器，避免遇到错误后整个程序崩溃 123456789101112131415var events = require('events');var emmitter = new events.EventEmitter();emmitter.once('once',function()&#123; console.log('我只执行一次哈');&#125;);emmitter.on('error', (err) =&gt; &#123; console.log(err); //whoops! there was an error &#125;); emmitter.emit('once');emmitter.emit('error',new Error("什么错误")); 继承 EventEmitter 大多数时候我们不会直接使用 EventEmitter ，而是在对象中继承它。包括 fs 、 net 、http 在内的，只要是支持事件响应的核心模块都是 EventEmitter 的子类 为什么要这样做呢？原因有两点。首先，具有某个实体功能的对象实现事件符合语义，事件的监听和发射应该是一个对象的方法。其次 JavaScript 的对象机制是基于原型的，支持部分多重继承，继承 EventEmitter 不会打乱对象原有的继承关系]]></content>
      <tags>
        <tag>node</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[node.js开发指南笔记1]]></title>
    <url>%2F2017%2F08%2F09%2Fnode-js%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97%E7%AC%94%E8%AE%B01%2F</url>
    <content type="text"><![CDATA[创建一个服务12345678var http = require('http');http.createServer(function(req,res)&#123; res.writeHead(200,&#123;'Content-Type':'text/html;charset=utf-8'&#125;); res.write('在学习'); res.end("node");&#125;).listen(3000); 利用http创建一个监听的服务器 localhost:3000 创建一个读取文件内容的异步线程函数12345678910var fs = require('fs');fs.readFile('file.txt', 'utf-8', function(err, data) &#123; if (err) &#123; console.error(err); &#125; else &#123; console.log(data); &#125;&#125;);console.log('end.'); 执行结果 end先出来 然后是文件内容 readFile()的三个参数,第一个是文件名（路径），第二个是编码方式，第三个是一个回调函数 创建一个读取文件内容的同步线程函数12345678910var fs = require('fs');var data = fs.readFileSync('file.txt', 'utf-8');console.log(data);console.log('end.');//结果Contents of the file.end. node中的事件 Node.js 所有的异步 I/O 操作在完成时都会发送一个事件到事件队列 事件由 EventEmitter 对象提供,fs.readFile()以及fs.readFileSync()都是由它实现 12345678910var EventEmitter = require('events').EventEmitter;var event = new EventEmitter();event.on('some_event',function()&#123; console.log('我被执行了');&#125;)setTimeout(function()&#123; event.emit('some_event');&#125;,1000); 引入模块概念 exports 是模块公开的接口， require 用于从外部获取一个模块的接口 第一种引入方式 1234567891011121314151617181920//module1.jsfunction Maths()&#123; this.add=function(a,b)&#123; console.log(a+b); &#125; this.minus=function(a,b)&#123; console.log(a-b); &#125;&#125;exports.Maths = Maths;//demo.jsvar Maths = require('./module1').Maths;var xx = new Maths();console.log(xx.add(1,6)); //7 第二种方式 12345678910111213141516171819202122//module1.jsfunction Maths()&#123; this.add=function(a,b)&#123; console.log(a+b); &#125; this.minus=function(a,b)&#123; console.log(a-b); &#125;&#125;//demo1.jsvar Maths = require('./module1');var math = new Maths();console.log(math.add(1,8)); //9module.exports = Maths; 引入包的概念 符合Commonjs规范的包应该具备以下条件 package.json必须在包的顶层目录下 二进制文件必须在lib目录下 文档应该在doc目录下 单元测试在test目录下 一个简单的包实例 建一个目录叫somepackage，里面建一个json文件和一个目录文件lib，目录文件里面写一个模块hello.js 12345678910// package.json&#123; "main":"./lib/hello.js"&#125;//lib/hello.js exports.hello = function() &#123; console.log('hello,ly');&#125; 调用这个模块 123//与somepackage同级 getHello.jsvar somePackage = require('./somePackage');somePackage.hello(); 运行 node getHello.js 输出 hello，ly 我们在调用某个包时会先检查包中的package.json,将main字段作为入口模块，如果不存在则会找index.js或者index.node package.json作为描述包的文件 有几个必须存在的字段 name:包的名称，必须是唯一的，由小写英文字母、数字和下划线组成，不能包含空格 description:包的简要说明 version ：符合语义化版本识别规范的版本字符串 keywords ：关键字数组，通常用于搜索 maintainers ：维护者数组，每个元素要包含 name 、 email （可选）、 web （可选）字段 contributors ：贡献者数组，格式与 maintainers 相同。包的作者应该是贡献者数组的第一个元素 bugs ：提交bug的地址，可以是网址或者电子邮件地址 licenses 许可证数组，每个元素要包含 type （许可证的名称）和 url （链接到许可证文本的地址）字段 repositories ：仓库托管地址数组，每个元素要包含 type （仓库的类型，如 git ）、url （仓库的地址）和 path （相对于仓库的路径，可选）字段 dependencies ：包的依赖，一个关联数组，由包名称和版本号组成 书中给出的实例 { "name": "mypackage", "description": "Sample package for CommonJS. This package demonstrates the required elements of a CommonJS package.", "version": "0.7.0", "keywords": [ "package", "example" ], "maintainers": [ { "name": "Bill Smith", "email": "bills@example.com", } ], "contributors": [ { "name": "BYVoid", "web": "http://www.byvoid.com/" } ], "bugs": { "mail": "dev@example.com", "web": "http://www.example.com/bugs" }, "licenses": [ { "type": "GPLv2", "url": "http://www.example.org/licenses/gpl.html" } ], "repositories": [ { "type": "git", "url": "http://github.com/BYVoid/mypackage.git" } ], "dependencies": { "webkit": "1.2", "ssl": { "gnutls": ["1.0", "2.0"], "openssl": "0.9.8" } } } 包管理器 npm 安装包 npm i 包名 对于全局安装的包(npm [install/i] -g [package_name]),它不会装在本地的node_modules下面,他会安装在系统目录下的/usr/local/lib/node_modules/ 同时package.json 的bin字段包含的文件会被链接到 /usr/local/bin/ 于是可以在命令行中直接运行了 创建全局链接 - 将全局包当本地包使用 npm link express./node_modules/express -&gt; /usr/local/lib/node_modules/express win系统不支持 包的发布 npm init 初始化 npm adduser 输入用户名、密码、邮箱 npm whoami 测验是否已经取得了账号 npm publish 发布 修改版本号 version 跟新 npm unpublish 取消发布 调试 node debug 文件 run 执行脚本，在第一行暂停 restart 重新执行脚本 cont, c 继续执行，直到遇到下一个断点 next, n 单步执行 step, s 单步执行并进入函数 out, o 从函数中步出 setBreakpoint(), sb() 在当前行设置断点 setBreakpoint(‘f()’), sb(…) 在函数f的第一行设置断点 setBreakpoint(‘script.js’, 20), sb(…) 在 script.js 的第20行设置断点 clearBreakpoint, cb(…) 清除所有断点 backtrace, bt 显示当前的调用栈 list(5) 显示当前执行到的前后5行代码 watch(expr) 把表达式 expr 加入监视列表 unwatch(expr) 把表达式 expr 从监视列表移除 watchers 显示监视列表中所有的表达式和值 repl 在当前上下文打开即时求值环境 kill 终止当前执行的脚本 scripts 显示当前已加载的所有脚本 version 显示 V8 的版本 远程调试 暂时不考虑 命令行 node –debug [= port ] script.js node –debug-brk [= port ] script.js]]></content>
      <tags>
        <tag>node</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[node 常用的包]]></title>
    <url>%2F2017%2F08%2F09%2Fnode-%E5%B8%B8%E7%94%A8%E7%9A%84%E5%8C%85%2F</url>
    <content type="text"><![CDATA[cnpm i -g supervisor 这个命令不用自己重新运行修改后的代码，它会监视你对代码的改动,当代码被改动时，运行的脚本会被终止，然后重新启动 superagent 用于抓取整个网页 cheerio 类似jquery supertest 用于请求数据 nodemon 热启动 自动检测代码]]></content>
      <tags>
        <tag>node</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[几种自适应布局]]></title>
    <url>%2F2017%2F08%2F05%2F%E5%87%A0%E7%A7%8D%E8%87%AA%E9%80%82%E5%BA%94%E5%B8%83%E5%B1%80%2F</url>
    <content type="text"><![CDATA[前言 由于现在电脑屏幕分辨率不同的原因,页面布局就不能写死宽度了，否自在分辨率高的屏幕可能会有留白的情况，所以页面一般采用自适应布局.主流的有三栏布局，和两栏布局.下面便是两种布局的几种方法(我写的demo地址http://www.aymfx.cn/ife-2018/layout/index.html)。 三栏布局圣杯布局(双飞翼布局) 这个好像淘宝UED的工程师写的，淘宝页面也基本可以看到这种布局的影子，它的几个特点 三列布局，中间宽度自适应，两边定宽； 中间栏要在浏览器中优先展示渲染； 允许任意列的高度最高 12345678910111213&lt;section class="demo9"&gt; &lt;div class="center-div"&gt; &lt;div class="content"&gt; 我是中间的aaaaaaaaaa &lt;/div&gt; &lt;/div&gt; &lt;div class="left-div"&gt; 我是左边的（负边距布局) &lt;/div&gt; &lt;div class="right-div"&gt; 我是右边的 &lt;/div&gt; &lt;/section&gt; 主意看顺序啊，中间内容分的在最上面12345678910111213141516171819202122.demo9 &#123; height: 60px; width: 100%; &#125; .demo9 .left-div &#123; background: #99d; height: 60px; width: 100px; float: left; margin-left: -100%; &#125; .demo9 .center-div &#123; background: #fff; height: 60px; float: left; width: 100%; &#125; .demo9 .center-div .content &#123; padding: 0 100px; &#125; .demo9 .right-div &#123; float: left; background: #cfc; height: 60px; width: 100px; margin-left: -100px; &#125; 三块都要加浮动，中间的一块宽度为100%,通过margin-left: -100%;将左边的div放到最前面，通过margin-left: -100px;方到右边，要主意一个问题,位置是对的，但是我们的写内容的时候，会被左右两块挡住，所以我们必须在加一个div在中间块，通过给它设置padding: 0 100px; ,来确保内容不会被遮盖 浮动的方式 这个就是通过左右两块浮动，来解决自适应布局的问题，我们来看下代码1234567891011&lt;section class="demo8"&gt; &lt;div class="left-div"&gt; 我是左边的（浮动布局) &lt;/div&gt; &lt;div class="right-div"&gt; 我是右边的 &lt;/div&gt; &lt;div class="center-div"&gt; 我是中间的 &lt;/div&gt; &lt;/section&gt; 主意还是顺序哈，这回中间的在最后了12345678910111213141516.demo8 .left-div &#123; background: #99d; height: 60px; width: 100px; float: left; &#125;.demo8 .center-div &#123; margin: 0 100px; background: #fff; height: 60px; &#125;.demo8 .right-div &#123; float: right; background: #cfc; height: 60px; width: 100px; &#125; margin: 0 100px;这个也是必须加的防止内容被挡住 定位 这个是比较好理解的了，通过脱离文档流使得中间的div不会被挤下来123456789101112&lt;section class="demo11"&gt; &lt;div class="left-div"&gt; 我是左边的（定位) &lt;/div&gt; &lt;div class="center-div"&gt; 我是中间的 &lt;/div&gt; &lt;div class="right-div"&gt; 我是右边的 &lt;/div&gt; &lt;/section&gt; 顺序不用变了。– 12345678910111213141516171819202122.demo11 &#123; position: relative; height: 60px; width: 100%; &#125; .demo11 .left-div &#123; background: #99d; height: 60px; position: absolute; width: 100px; left: 0; top: 0; &#125; .demo11 .center-div &#123; background: #fff; margin: 0 100px; height: 60px; &#125; .demo11 .right-div &#123; background: #cfc; position: absolute; width: 100px; right: 0; top: 0; height: 60px; &#125; 这就是三栏布局比较常用的布局了 两栏布局 两栏布局有好多种方式，我就写写我记得的几种 浮动布局12345678&lt;section class="demo4"&gt; &lt;div class="left-div"&gt; 我是左边的（浮动布局） &lt;/div&gt; &lt;div class="right-div"&gt; 我是右边的 &lt;/div&gt; &lt;/section&gt; 12345678910.demo4 .left-div &#123; width: 100px; background: #99d; height: 60px; float: left; &#125;.demo4 .right-div &#123; margin-left: 100px; background: #cfc; height: 60px; &#125; flex布局 12345678&lt;section class="demo5"&gt; &lt;div class="left-div"&gt; 我是左边的（flex布局） &lt;/div&gt; &lt;div class="right-div"&gt; 我是右边的 &lt;/div&gt; &lt;/section&gt; 12345678910.demo5 &#123; display: flex; &#125; .demo5 .left-div &#123; width: 100px; background: #99d; height: 60px; &#125; .demo5 .right-div &#123; background: #cfc; height: 60px; flex: 1 1 auto; &#125; calc布局 calc 是css的一种计算方式 css3新增的属性，兼容性ie10以上啦1234567&lt;section class="demo12"&gt; &lt;div class="left-div"&gt; 我是左边的（calc布局） &lt;/div&gt;&lt;div class="right-div"&gt; 我是右边的 &lt;/div&gt; &lt;/section&gt; 1234567891011121314.demo12 .left-div &#123; width: 100px; background: #99d; height: 60px; display: inline-block; vertical-align: top; box-sizing: border-box; &#125;.demo12 .right-div &#123; box-sizing: border-box; background: #cfc; height: 60px; display: inline-block; width: calc(100% - 100px); &#125; 定位布局1234567&lt;section class="demo13"&gt; &lt;div class="left-div"&gt; 我是左边的（定位布局） &lt;/div&gt;&lt;div class="right-div"&gt; 我是右边的 &lt;/div&gt; &lt;/section&gt; 123456789101112131415.demo13 &#123; position: relative; height: 60px; width: 100%; &#125; .demo13 .left-div &#123; background: #99d; height: 60px; position: absolute; width: 100px; left: 0; top: 0; &#125; .demo13 .right-div &#123; background: #cfc; margin-left: 100px; height: 60px; &#125; bfc布局1234567&lt;section class="demo14"&gt; &lt;div class="left-div"&gt; 我是左边的（bfc布局） &lt;/div&gt;&lt;div class="right-div"&gt; 我是右边的 &lt;/div&gt; &lt;/section&gt; 主要是利用float和overflow触发了bfc,实现自适应的 1234567891011.demo14 &#123; overflow: auto; &#125; .demo14 .left-div &#123; background: #99d; height: 60px; width: 100px; float: left; &#125; .demo14 .right-div &#123; background: #cfc; height: 60px; overflow: auto; &#125; grid布局 这是比较新的布局，有点类似bootstrap的布局特色，网格布局，自适应能力超强，不仅仅用来做这个，还有很强大的功能 1234567&lt;section class="demo15"&gt; &lt;div class="left-div"&gt; 我是左边的（grad布局） &lt;/div&gt;&lt;div class="right-div"&gt; 我是右边的 &lt;/div&gt; &lt;/section&gt; 1234567891011121314.demo15 &#123; display: grid; grid-template-columns: 100px auto; align-items: start; &#125; .demo15 .left-div &#123; background: #99d; height: 60px; box-sizing: border-box; grid-column: 1; &#125; .demo15 .right-div &#123; background: #cfc; height: 60px; box-sizing: border-box; grid-column: 2; &#125;]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>html</tag>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[解决下面点击时出现图片轮廓的问题]]></title>
    <url>%2F2017%2F08%2F02%2F%E8%A7%A3%E5%86%B3%E4%B8%8B%E9%9D%A2%E7%82%B9%E5%87%BB%E6%97%B6%E5%87%BA%E7%8E%B0%E5%9B%BE%E7%89%87%E8%BD%AE%E5%BB%93%E7%9A%84%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[解决下面点击时出现图片轮廓的问题 解决方式 a { -webkit-tap-highlight-color: transparent; -webkit-touch-callout: none; -webkit-user-select: none; } tips： 适合pc和移动端的]]></content>
      <tags>
        <tag>methods</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[node-review]]></title>
    <url>%2F2017%2F08%2F01%2Fnode-review%2F</url>
    <content type="text"><![CDATA[建一个简单的express 对于学习node的人来说首先node安装是必备的，这里就跳过了 http://expressjs.com/ 它的官网 安装 express npm i express 新建一个app.js文件，写以下的代码 12345678910111213141516//引入 `express` 模块var express = require(&apos;express&apos;); // 调用 express 实例，它是一个函数，不带参数调用时，会返回一个 express 实例，将这个变量赋予 app 变量var app = express(); //调用get方法，当我们访问/这个根目录时，我们会执行回调，send用于向网页输出字符串app.get(&apos;/&apos;, function(req, res) &#123; res.send(&apos;Hello,world&apos;);&#125;)// 定义好我们 app 的行为之后，让它监听本地的 3000 端口。这里的第二个函数是个回调函数，会在 listen 动作成功后执行，我们这里执行了一个命令行输出操作，告诉我们监听动作已完成。app.listen(3000, function() &#123; console.log(&quot;app is listen at port 3000&quot;);&#125;) 参考 // app 本身有很多方法，其中包括最常用的 get、post、put/patch、delete，在这里我们调用其中的 get 方法，为我们的 / 路径指定一个 handler 函数。 // 这个 handler 函数会接收 req 和 res 两个对象，他们分别是请求的 request 和 response。 // request 中包含了浏览器传来的各种信息，比如 query 啊，body 啊，headers 啊之类的，都可以通过 req 对象访问到。 // res 对象，我们一般不从里面取信息，而是通过它来定制我们向浏览器输出的信息，比如 header 信息，比如想要向浏览器输出的内容。这里我们调用了它的 #send 方法，向浏览器输出一个字符串。 执行 node app.js 然后在浏览器地址栏输出&gt; http://localhost:3000/ 学习使用外部模块 npm init 初始化 cnpm i express utility -S 安装两个依赖块 https://github.com/node-modules/utility utility是一个工具类，在这个地方用于加密哦 新建一个app.js文件，写以下的代码 1234567891011121314151617var express = require(&apos;express&apos;);var utility = require(&apos;utility&apos;);var app = express();app.get(&apos;/&apos;, function(req, res) &#123; //query用来获取地址栏后面的参数 var message = req.query.message; //使用工具函数进行加密处理 var md5Value = utility.md5(message); res.send(md5Value);&#125;);app.listen(3000, function(req, res) &#123; console.log(&apos;app is running at port 3000&apos;)&#125;) 执行 node app.js 然后在浏览器地址栏输出&gt; http://localhost:3000/?message=&#39;liuyang&#39; 使用 superagent 与 cheerio 完成简单爬虫 superagent superagent(http://visionmedia.github.io/superagent/ ) 是个 http 方面的库，可以发起 get 或 post 请求。 cheerio (https://github.com/cheeriojs/cheerio ) 大家可以理解成一个 Node.js 版的 jquery，用来从网页中以 css selector 取数据，使用方式跟 jquery 一样一样的。 新建一个app.js文件，写以下的代码 12345678910111213141516171819202122232425262728293031323334var express = require(&apos;express&apos;)var superagent = require(&apos;superagent&apos;);var cheerio = require(&apos;cheerio&apos;);var app = express();app.get(&apos;/&apos;, function(req, res, next) &#123; //用superagent去抓取页面内容 superagent.get(&apos;http://www.qdfuns.com/&apos;).end(function(err, sres) &#123; if (err) &#123; return next(err) &#125; //加载取到的页面，然后创建一个类似jquery的实例 var $ = cheerio.load(sres.text); var items = []; $(&quot;.media-body&quot;).each(function(idx, ele) &#123; var $ele = $(ele); items.push(&#123; title: $ele.text() &#125;) &#125;) res.send(items); &#125;)&#125;)app.listen(3000, function(req, res) &#123; console.log(&apos;app is running at port 3000&apos;)&#125;) 利用这两个模块，我们能抓取我们所需要的数据 使用 eventproxy 控制并发 这一小节内容，利用eventproxy，实现并发抓取1+40,1就是抓取40个主题，40是抓取每个主题链接下面的评论，也就是说我们要发起1+40个请求，后四十个请求一起发起 eventproxy https://github.com/JacksonTian/eventproxy 并发执行异步回调，移除被广为诟病的深度callback嵌套问题，将串行等待变成并行等待，提升多异步协作场景下的执行效率 eventproxy 提供了不少其他场景所需的 API，但最最常用的用法就是以上的这种，即： 先 var ep = new eventproxy(); 得到一个 eventproxy 实例。 告诉它你要监听哪些事件，并给它一个回调函数。ep.all(‘event1’, ‘event2’, function (result1, result2) {})。 在适当的时候 ep.emit(‘event_name’, eventData)。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061var express = require(&apos;express&apos;)var superagent = require(&apos;superagent&apos;);var cheerio = require(&apos;cheerio&apos;);var eventproxy = require(&apos;eventproxy&apos;);var url = require(&apos;url&apos;);var cnodeUrl = &apos;https://cnodejs.org/&apos;var app = express();var topicUrls = [];var topicsS = [];app.get(&apos;/&apos;, function(req, res, next) &#123; superagent.get(cnodeUrl).end(function(err, sres) &#123; if (err) &#123; return next(err) &#125; var $ = cheerio.load(sres.text); $(&quot;#topic_list .topic_title&quot;).each(function(idx, ele) &#123; var $ele = $(ele); //url.resolve，可以补全前面的域名，进行拼接操作 var href = url.resolve(cnodeUrl, $ele.attr(&apos;href&apos;)); topicUrls.push(href); &#125;) topicUrls.forEach(function(topiculr) &#123; superagent.get(topiculr).end(function(err, res) &#123; console.log(&quot;fetch&quot; + topiculr + &apos;successful&apos;); ep.emit(&apos;topic_html&apos;, [topiculr, res.text]) &#125;) &#125;) //创建一个eventproxy实例 var ep = new eventproxy(); //这个表示重复监听topic_html事件40次后执行回调函数 ep.after(&apos;topic_html&apos;, topicUrls.length, function(topics) &#123; console.log(1212); //它将emit过来东西全部保存在数组里，然后用map将它遍历 topicsS = topics.map(function(topicPair) &#123; var topicUrl = topicPair[0]; var topicHtml = topicPair[1]; var $ = cheerio.load(topicHtml); return (&#123; title: $(&apos;.topic_full_title&apos;).text().trim(), href: topicUrl, commit1: $(&apos;.reply_content&apos;).eq(0).text().trim() &#125;) &#125;) res.send(topicsS); &#125;) &#125;)&#125;)app.listen(3000, function(req, res) &#123; console.log(&apos;app is running at port 3000&apos;)&#125;) 使用 async 控制并发 async https://github.com/caolan/async 用于延迟并发，减少一起并发导致网站出问题 123456789101112131415161718192021222324252627282930var async = require(&apos;async&apos;);var concurrencyCount = 0;//模拟假的数据请求，返回一个callback值var fetchUrl = function(url, callback) &#123; var delay = parseInt((Math.random() * 10000000) % 2000, 10); concurrencyCount++; console.log(&apos;现在的并发数是&apos;, concurrencyCount, &apos;，正在抓取的是&apos;, url, &apos;，耗时&apos; + delay + &apos;毫秒&apos;); setTimeout(function() &#123; concurrencyCount--; //用这个做拼接 callback(null, url + &apos;html content&apos;) &#125;, delay)&#125;;var urls = [];for (var i = 0; i &lt; 30; i++) &#123; urls.push(&apos;http://datasource_&apos; + i);&#125;//限制并发的次数async.mapLimit(urls, 5, function(url, callback) &#123; fetchUrl(url, callback);&#125;, function(err, result) &#123; console.log(&apos;final:&apos;); //最终结果汇总 console.log(result);&#125;) 测试用例：mocha，should，istanbul 学习使用测试框架 mocha : http://mochajs.org/ 学习使用断言库 should : https://github.com/tj/should.js 学习使用测试率覆盖工具 istanbul : https://github.com/gotwarlost/istanbul 简单 Makefile 的编写 : http://blog.csdn.net/haoel/article/details/2886 学习使用断言库 expect :https://github.com/LearnBoost/expect.js/ 先建一个文件 main.js 1234567891011121314151617181920var fibonacci = function(n) &#123; if (n === 0) &#123; return 0; &#125; if (n === 1) &#123; return 1; &#125; return fibonacci(n - 1) + fibonacci(n - 2);&#125;;if (require.main === module) &#123; // 如果是直接执行 main.js，则进入此处 // 如果 main.js 被其他文件 require，则此处不会执行。 var n = Number(process.argv[2]); console.log(&apos;fibonacci(&apos; + n + &apos;) is&apos;, fibonacci(n));&#125;exports.fibonacci = fibonacci; 在同级目录下建一个文件夹命名必须为test 在它的子目录建一个文件main-test.js 12345678910111213141516171819202122232425262728293031323334var main = require(&apos;../main&apos;);var should = require(&apos;should&apos;);describe(&apos;test/main.test.js&apos;, function() &#123; it(&apos;should equal 0 when n === 0&apos;, function() &#123; main.fibonacci(0).should.equal(0); &#125;); it(&apos;should equal 1 when n === 1&apos;, function() &#123; main.fibonacci(1).should.equal(1); &#125;); it(&apos;should equal 55 when n === 10&apos;, function() &#123; main.fibonacci(10).should.equal(55); &#125;); it(&apos;should throw when n &gt; 10&apos;, function() &#123; (function() &#123; main.fibonacci(11); &#125;).should.throw(&apos;n should &lt;= 10&apos;); &#125;); it(&apos;should throw when n &lt; 0&apos;, function() &#123; (function() &#123; main.fibonacci(-1); &#125;).should.throw(&apos;n should &gt;= 0&apos;); &#125;); it(&apos;should throw when n isnt Number&apos;, function() &#123; (function() &#123; main.fibonacci(&apos;呵呵&apos;); &#125;).should.throw(&apos;n should be a Number&apos;); &#125;);&#125;); 由于node的计算能力以及边界值得原因后三个可能过不了，需要修补下代码 12345678910111213141516171819var fibonacci = function (n) &#123; if (typeof n !== &apos;number&apos;) &#123; throw new Error(&apos;n should be a Number&apos;); &#125; if (n &lt; 0) &#123; throw new Error(&apos;n should &gt;= 0&apos;); &#125; if (n &gt; 10) &#123; throw new Error(&apos;n should &lt;= 10&apos;); &#125; if (n === 0) &#123; return 0; &#125; if (n === 1) &#123; return 1; &#125; return fibonacci(n-1) + fibonacci(n-2);&#125;; 测试用例的覆盖率 安装 npm i istanbul -g 执行 $ istanbul cover _mocha （有大问题，window有坑） 浏览器端测试：mocha，chai，phantomjs 学习使用测试框架 mocha 进行前端测试 : http://mochajs.org/ 了解全栈的断言库 chai: http://chaijs.com/ 了解 headless 浏览器 phantomjs: http://phantomjs.org/ 第一步需要安装mocha cnpm i mocha -g 初始化mocha mocha init . 会生成几个初始化的文件 引入chai,在index.html 1234567891011121314&lt;!--引入 断言库 chaijs --&gt; &lt;script src=&apos;https://cdn.rawgit.com/chaijs/chai/master/chai.js&apos;&gt;&lt;/script&gt; &lt;!--需要测试的代码--&gt; &lt;script&gt; var fibonacci = function(n) &#123; if (n === 0) &#123; return 0; &#125; if (n === 1) &#123; return 1; &#125; return fibonacci(n - 1) + fibonacci(n - 2); &#125;; 在test.js中写测试用例 1234567var should = chai.should();describe(&apos;我只是一个测试&apos;, function() &#123; it(&quot;测试是否等于0&quot;, function() &#123; window.fibonacci(0).should.equal(0); &#125;)&#125;) 运行index看结果 测试反馈 初始化 npm init 安装依赖 cnpm i mocha-phantomjs –save-dev 在package.json 加入这么一句话 123&quot;scripts&quot;: &#123; &quot;test&quot;: &quot;mocha-phantomjs index.html --ssl-protocol=any --ignore-ssl-errors=true&quot;&#125;, npm test]]></content>
      <tags>
        <tag>node</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jQuery源码学习（2）-构造jquery对象（1）]]></title>
    <url>%2F2017%2F07%2F29%2FjQuery%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%EF%BC%882%EF%BC%89-%E6%9E%84%E9%80%A0jquery%E5%AF%B9%E8%B1%A1%EF%BC%881%EF%BC%89%2F</url>
    <content type="text"><![CDATA[构造函数jQuery jQuery(select [,context]) 第一个参数是选择器，用于选择docunment里面的html元素，当传入的参数不是选择器时，会返回一个空的jquery对象 第二个是上下文对象，也就是限制从哪个范围开始查找元素，默认从document 当指定了第二个参数，实际上就是调用了$(selsect).find(xxx) jQuery(html[,ownerDocument])、jQuery(html,props) html 表示如果是html代码，jquery将其转换成一个jquery对象，可以进行插入dom 操作 类似于:$(“ly“).appendTo(‘body’),可以是单标签 ownerDocument 表示可以创建新的文档对象，默认当前文档 props 必须是单标签写法 1234567$(&quot;&lt;div/&gt;&quot;, &#123; &quot;class&quot;: &quot;test&quot;, text: &quot;Click me!&quot;, click: function() &#123; $(this).toggleClass(&quot;bar&quot;); &#125; &#125;).appendTo(&quot;body&quot;); jQuery(element) jQuery(elementArray) 该方法是将dom元素封装成jquery元素然年调用jquery方法 多用于事件的监听 123$(&apos;div&apos;).click(function()&#123; $(this).show();&#125;) jQuery(object) 对于普通的js对象也可以包装成jquery对象的 12345678910var names = &#123; first: &apos;liu&apos;, last: &apos;yang&apos; &#125; var $names = $(names); console.log($names); $names.on(&apos;binds&apos;, function() &#123; console.log(&apos;我叫&apos;, $names[0].first + $names[0].last); &#125;) $names.trigger(&apos;binds&apos;); //自动触发 jQuery(callback) 如果传入一个函数，在document绑定一个ready事件监听函数，当dom加载时执行 ready比load早执行，不是原生函数,它由DOMContentLoaded事件onreadystatechange事件以及函数doScrollCheck()的统称 jQuery(jQuery object) 如归传入的是jquery对象，会创建一个一样的副本，并且返回，他们引用的同一个地址 jQuery() 不传参则返回一个空的jquery对象 jQuery.fn.init(selector,context,rootjQuery) 12个分支 也就是有12种处理方式的写法，具体参考书吧 以下也有讲解 selector:接收的是dom对象 context : 上下文对象 rootjQuery 用于以下情况 1234567891011121314151617181920212223242526272829303132333435363738394041424344//id查找失败if (elem.id !== match[2]) &#123; return rootjQuery.find(selector); &#125;//selector是选择器且没有contextif (!context || context.jquery) &#123; return (context || rootjQuery).find(selector); &#125;//selector是函数if (jQuery.isFunction(selector)) &#123; return rootjQuery.ready(selector); &#125;//怎么定义rootjQuery？ rootjQuery = jQuery(document);//如果判断选择器是false，返回的是空的$(); if (!selector) &#123; return this; &#125; //如果字符串是body，则获取document.body if (selector === &quot;body&quot; &amp;&amp; !context &amp;&amp; document.body) &#123; console.log(&quot;是我呀&quot;); this.context = document; this[0] = document.body; this.selector = selector; this.length = 1; return this; &#125; //用于匹配html代码以及id,第一个是selector 第二个是html或者undefind quickExpr = /^(?:[^#&lt;]*(&lt;[\w\W]+&gt;)[^&gt;]*$|#([\w\-]*)$)/,// 匹配单标记 rsingleTag = /^&lt;(\w+)\s*\/?&gt;(?:&lt;\/\1&gt;)?$/,]]></content>
      <tags>
        <tag>jquery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jQuery源码学习（1）-总体架构]]></title>
    <url>%2F2017%2F07%2F28%2FjQuery%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%EF%BC%881%EF%BC%89-%E6%80%BB%E4%BD%93%E6%9E%B6%E6%9E%84%2F</url>
    <content type="text"><![CDATA[准备 jquery技术内幕书籍 jquery1.7.1源码 总体架构jquery的三个部分 入口模块 构造jQuery对象的jquery() 底层支持模块 工具方法Utilities 回调函数列表 Callbacks Object 异步队列Deferred Object 浏览器功能测试Support 数据缓存Data 队列Queue 选择器Sizzle 功能模块 属性操作 Attributes 事件系统 Events DOM遍历Traversing 样式操作css 计算机样式&amp; 内联样式 坐标Offset 尺寸Dimension 异步请求Ajax 动画Effects 整体的结构 源码整体结构 LY ===Jquery 自己改了下 123456789101112131415161718(function(window, undefind) &#123; //构造jQuery对象 var LY = (function() &#123; var LY = function() &#123; return new LY.fn.init(); &#125; return LY; &#125;)(); //一些基础的功能 ..... //将ly对象挂载到window下面 window.LY = window.ly = LY;&#125;)(window) 三种自执行匿名函数 (function(){})() //jquery采用的这种 (function(){}()) !function(){}(); 为什么要传入 window以及undefined 在匿名函数里面 传入 window 变量，使得 window 由全局变量变为局部变量，当在 jQuery 代码块中访问 window时，不需要将作用域链回退到顶层作用域，这样可以更快的访问 window 将 window 作为参数传入，可以在压缩代码时进行优化 对于undefind也是如此，但是它最重要的原因是undefined的可能被重写值(在某些浏览器) 为什么在自执行函数前面加分号 保障浏览器正确识别]]></content>
      <tags>
        <tag>jquery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自适应适配]]></title>
    <url>%2F2017%2F07%2F21%2F%E8%87%AA%E9%80%82%E5%BA%94%E9%80%82%E9%85%8D%2F</url>
    <content type="text"><![CDATA[//自适应方案 ;(function(win) { var doc = win.document; var docEl = doc.documentElement; var dpr = 0; var tid = 0; var isAndroid = win.navigator.appVersion.match(/android/gi); var isIPhone = win.navigator.appVersion.match(/iphone/gi); var devicePixelRatio = win.devicePixelRatio; if(isIPhone) { // iOS下，对于2和3的屏，用2倍的方案，其余的用1倍方案 if(devicePixelRatio &gt;= 3 &amp;&amp; (!dpr || dpr &gt;= 3)) { dpr = 2; } else if(devicePixelRatio &gt;= 2 &amp;&amp; (!dpr || dpr &gt;= 2)) { dpr = 2; } else { dpr = 1; } } else { // 其他设备下，仍旧使用1倍的方案 dpr = 1; } function refreshRem() { var width = docEl.getBoundingClientRect().width; if(width &gt; 750) { width = 750; } var rem = width / 7.5; docEl.style.fontSize = rem + &apos;px&apos;; } win.addEventListener(&apos;resize&apos;, function() { clearTimeout(tid); tid = setTimeout(refreshRem, 300); }, false); win.addEventListener(&apos;pageshow&apos;, function(e) { if(e.persisted) { clearTimeout(tid); tid = setTimeout(refreshRem, 300); } }, false); refreshRem(); docEl.setAttribute(&apos;data-dpr&apos;, dpr); })(window);]]></content>
  </entry>
  <entry>
    <title><![CDATA[react-es5vses6]]></title>
    <url>%2F2017%2F07%2F19%2Freact-es5vses6%2F</url>
    <content type="text"><![CDATA[create react APP12345class Greeting extends React.Component &#123; render() &#123; return &lt;h1&gt;Hello, &#123;this.props.name&#125;&lt;/h1&gt;; &#125;&#125; 123456var createReactClass = require(&apos;create-react-class&apos;);var Greeting = createReactClass(&#123; render: function() &#123; return &lt;h1&gt;Hello, &#123;this.props.name&#125;&lt;/h1&gt;; &#125;&#125;); Declaring Default Props1234567class Greeting extends React.Component &#123; // ...&#125;Greeting.defaultProps = &#123; name: &apos;Mary&apos;&#125;; 12345678910var Greeting = createReactClass(&#123; getDefaultProps: function() &#123; return &#123; name: &apos;Mary&apos; &#125;; &#125;, // ...&#125;); Setting the Initial State1234567class Counter extends React.Component &#123; constructor(props) &#123; super(props); this.state = &#123;count: props.initialCount&#125;; &#125; // ...&#125; 123456var Counter = createReactClass(&#123; getInitialState: function() &#123; return &#123;count: this.props.initialCount&#125;; &#125;, // ...&#125;); AutoBind123456789101112131415161718192021class SayHello extends React.Component &#123; constructor(props) &#123; super(props); this.state = &#123;message: &apos;Hello!&apos;&#125;; // This line is important! this.handleClick = this.handleClick.bind(this); &#125; handleClick() &#123; alert(this.state.message); &#125; render() &#123; // Because `this.handleClick` is bound, we can use it as an event handler. return ( &lt;button onClick=&#123;this.handleClick&#125;&gt; Say hello &lt;/button&gt; ); &#125;&#125; 1234567891011121314151617var SayHello = createReactClass(&#123; getInitialState: function() &#123; return &#123;message: &apos;Hello!&apos;&#125;; &#125;, handleClick: function() &#123; alert(this.state.message); &#125;, render: function() &#123; return ( &lt;button onClick=&#123;this.handleClick&#125;&gt; Say hello &lt;/button&gt; ); &#125;&#125;);]]></content>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[react-生命周期]]></title>
    <url>%2F2017%2F07%2F19%2Freact-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%2F</url>
    <content type="text"><![CDATA[对于在哪里进行setState()的操作请看下面这个例子import React,{Component , PropTypes} from ‘react’import ‘../css/Life.scss’; class Life extends Component{ constructor (props) { super(props) this.state={ count:1, name:’点我’, num:0 } //有警告，页面能刷新正常运行，但是不会加1 此构造函数只执行一次 // this.setState(prevState =&gt;({count:prevState.count+1})) console.log(“constructor”,this.props,0); this.handleEvent = this.handleEvent.bind(this) } handleEvent () { this.setState(prevState =&gt; ({count:prevState.count+1})) } static propsTyps = { age:PropTypes.number, sex:PropTypes.string, } static defaultProps = { } componentWillMount () { //执行这个函数，然后加1，然后渲染 此构造函数只执行一次 // this.setState(prevState =&gt;({count:prevState.count+1})) console.log(&quot;componentWillMount,&quot;,111); } render(){ console.log(&quot;render,&quot;,2222); //有警告，且直接运行不了 Maximum call stack size exceeded // this.setState(prevState =&gt;({count:prevState.count+1})) return (&lt;div&gt; &lt;p&gt;计数:{this.state.count}&lt;/p&gt; &lt;p&gt;年龄:{this.props.age}&lt;/p&gt; &lt;button onClick={this.handleEvent}&gt;{this.state.name}&lt;/button&gt; &lt;/div&gt;) } componentDidMount () { //渲染后，执行这个函数，然后又加1，再次渲染---此钩子只执行一次 // this.setState(prevState =&gt;({count:prevState.count+1})) console.log(&quot;componentDidMount,&quot;,3333); } componentWillReceiveProps (nextProps) { //这个主要用于父组件改变了传入的props，才进行触发事件 //这个也可以支持设置状态 // this.setState(prevState =&gt;({count:prevState.count+1})) console.log(&quot;componentWillReceiveProps&quot;,nextProps,4444); } shouldComponentUpdate(nextProps,nextState) { //他主要作用就是是否更新组件，true表示更新，false表示不更新 //这个也可以支持设置状态，但是书上说不可以，也许有别的原因 // this.setState(prevState =&gt;({count:prevState.count+1})) // debugger; console.log(nextState,nextProps,55555); return true; } componentWillUpdate(nextProps,nextState) { //放在这里容易造成死循环 // this.setState(prevState =&gt;({count:prevState.count+1})) console.log(nextState,nextProps,66666); } componentDidUpdate() { //放在这里容易造成死循环,最好加判断 if(this.state.count&lt;20){ this.setState(prevState =&gt;({count:prevState.count+1})) } console.log(&apos;componentDidUpdate&apos;,77777); } } export default Life; 上面是子组件 我是父组件 import React, { Component } from ‘react’;import logo from ‘./logo.svg’;import ‘./css/App.scss’;import Life from ‘./components/Life’ class App extends Component { constructor(props) { super(props) this.state={ age:18 } } render() { return ( Welcome to React {this.setState({age:e.target.value})}}/&gt; ); }} export default App; 总结 现在学的比较浅，组件有 construct componentWillMount() 以及componentDidMount在初始化过程中只执行一次,其他钩子函数在数据状态改变时会执行。]]></content>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[react - 用sass编写css]]></title>
    <url>%2F2017%2F07%2F19%2Freact-%E7%94%A8sass%E7%BC%96%E5%86%99css%2F</url>
    <content type="text"><![CDATA[前言 这适用于create-react-app配置的react开发环境， 第一步安装编译所需的依赖 npm install sass-loader node-sass –save-dev 在node_modules/react-scripts/config下找到 webpack.config.dev.js 文件在exculde中添加scss，用来匹配scss文件1234567891011exclude: [ /\.html$/, /\.(js|jsx)$/, /\.css$/, /\.json$/, /\.bmp$/, /\.gif$/, /\.jpe?g$/, /\.png$/, /\.scss$/,//这里添加 ], 这里添加sass配置文件123456789101112131415&#123; test: [/\.bmp$/, /\.gif$/, /\.jpe?g$/, /\.png$/], loader: require.resolve(&apos;url-loader&apos;), options: &#123; limit: 10000, name: &apos;static/media/[name].[hash:8].[ext]&apos;, &#125;,&#125;,// 编译sass &#123; test:/\.scss$/, loaders: [&apos;style-loader&apos;, &apos;css-loader&apos;, &apos;sass-loader&apos;],&#125;, 这是开发环境的配置，如需在生产环境开发只需在webpack.config.prod.js做同样的配置 配置完成后记得重新运行命令 npm start or yarn start]]></content>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[react-Optimizing Performance]]></title>
    <url>%2F2017%2F07%2F18%2Freact-Optimizing-Performance%2F</url>
    <content type="text"><![CDATA[性能优化 react做了很多处理，最大限度的减少了dom的操作，使我们能快速的开发，而不需要做很多操作，但是有些地方需要我们手动去操作react应用，提高性能 使用生产环境下的react.js,这样可以减少体积以及在生产环境下不需要的提示 创建 reactAPP —&gt; npm run build 进行打包压缩 利用branch创建更高效的生产版本 npm install –save-dev uglify-js-brunch 或者 yarn add –dev uglify-js-brunch brunch build -p 利用webpack创建，如果是用create-react创建的可以不考虑重新建 虚拟节点，避免重复渲染123shouldComponentUpdate(nextProps, nextState) &#123; return true;&#125; 第一种方式 1234567891011121314151617181920212223242526272829class CounterButton extends Component &#123; constructor(props)&#123; super(props); this.state = &#123;count:1&#125; &#125; shouldComponentUpdate(nextProps,nextState) &#123; if(this.props.color !== nextProps.color)&#123; return true; &#125; if(this.state.count !==nextState.count)&#123; return true; &#125; return false; &#125; render()&#123; return ( &lt;button color=&#123;this.props.color&#125; onClick=&#123;()=&gt;this.setState(state =&gt; (&#123;count:state.count+1&#125;))&#125;&gt; Count:&#123;this.state.count&#125; &lt;/button&gt; ) &#125;&#125; 第二种方式 1234567891011121314151617class CounterButton extends React.PureComponent &#123; constructor(props)&#123; super(props); this.state = &#123;count:1&#125; &#125; render()&#123; return ( &lt;button color=&#123;this.props.color&#125; onClick=&#123;()=&gt;this.setState(state =&gt; (&#123;count:state.count+1&#125;))&#125;&gt; Count:&#123;this.state.count&#125; &lt;/button&gt; ) &#125;&#125; 第二种适合复杂的情况下的浅比较，但是在某些情况下浅比较也会错失，如数据的突变情况 12345678910111213141516171819202122232425262728293031class ListOfWords extends React.PureComponent&#123; render()&#123; return (&lt;div&gt;&#123;this.props.words.join(&apos;,&apos;)&#125;&lt;/div&gt;) &#125;&#125;class WordAdder extends Component &#123; constructor(props)&#123; super(props); this.state = &#123;words:[&apos;maodan&apos;]&#125;; this.handleClick = this.handleClick.bind(this); &#125; handleClick()&#123; //这是造成不跟新的原因 const words =this.state.words; words.push(&apos;iloveyou&apos;); this.setState(&#123;words:words&#125;) &#125; render()&#123; return(&lt;div&gt; &lt;button onClick=&#123;this.handleClick&#125;&gt;确定&lt;/button&gt; &lt;ListOfWords words=&#123;this.state.words&#125;/&gt; &lt;/div&gt;) &#125;&#125; 123456//可以使用concat链接解决、handleClick() &#123; this.setState(prevState =&gt;(&#123;words:[...prevState.words,&apos;iloveyou&apos;]&#125;)) &#125; 不可变的数据结构为您提供了一种跟踪对象变化的廉价方法，这就是我们需要实现的组件。这通常会给你带来一个很好的性能提升 没怎么看懂 https://facebook.github.io/react/docs/optimizing-performance.html]]></content>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[react-Uncontrolled Components]]></title>
    <url>%2F2017%2F07%2F17%2Freact-Uncontrolled-Components%2F</url>
    <content type="text"><![CDATA[引用文字 不受控制的组件 受控制的组件表单数据由一个react组件处理，而不受控制的组件由dom元素自己处理 我们可以通过控制ref来跟新组件状态 123456789101112131415161718192021222324class NameForm extends Component&#123; constructor(props) &#123; super(props); this.handleSubmit = this.handleSubmit.bind(this) &#125; handleSubmit(event) &#123; console.log(&apos;A name was submitted:&apos;+this.input.value); console.log(&apos;A age was submitted:&apos;+this.refs.age.value); event.preventDefault(); &#125; render() &#123; return ( &lt;form onSubmit=&#123;this.handleSubmit&#125;&gt; &lt;label&gt; Name: &lt;input type=&quot;text&quot; ref=&#123;(input) =&gt;this.input = input&#125;/&gt; &lt;/label&gt; &lt;label&gt; age: &lt;input type=&quot;text&quot; ref=&quot;age&quot;/&gt; &lt;/label&gt; &lt;input type=&quot;submit&quot; value=&quot;提交&quot;/&gt; &lt;/form&gt;) &#125;&#125; 默认值 对于checkbox和radio采用defaultChecked,对于select和textarea采用defaultValue 1234567891011121314render() &#123; return ( &lt;form onSubmit=&#123;this.handleSubmit&#125;&gt; &lt;label&gt; Name: &lt;input defaultValue=&quot;Bob&quot; type=&quot;text&quot; ref=&#123;(input) =&gt; this.input = input&#125; /&gt; &lt;/label&gt; &lt;input type=&quot;submit&quot; value=&quot;Submit&quot; /&gt; &lt;/form&gt; );&#125;]]></content>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[react-Lifting State Up]]></title>
    <url>%2F2017%2F07%2F16%2Freact-Lifting-State-Up%2F</url>
    <content type="text"><![CDATA[案例一 通过输入温度改变条件 1234567891011121314151617181920212223242526272829303132333435363738function BoilingVerdict(props) &#123; if(props.celsius&gt;=100) &#123; return &lt;p&gt;水开了&lt;/p&gt; &#125; return &lt;p&gt;水没开&lt;/p&gt;&#125;class Calculator extends Component &#123; constructor (props) &#123; super(props) this.handleChange = this.handleChange.bind(this); this.state = &#123;temperature:&apos;&apos;&#125; &#125; handleChange(e) &#123; this.setState(&#123;temperature:e.target.value&#125;) &#125; render()&#123; const temperature = this.state.temperature; return (&lt;div&gt; &lt;fieldest&gt; &lt;legend&gt; 输入温度吧 &lt;/legend&gt; &lt;input type=&quot;text&quot; value=&#123;temperature&#125; onChange=&#123;this.handleChange&#125; /&gt; &lt;BoilingVerdict celsius=&#123;parseFloat(temperature)&#125; /&gt; &lt;/fieldest&gt; &lt;/div&gt;) &#125;&#125; 通过输入温度改变不同的的状态,共享状态是通过将其移动到需要它的组件的最接近的共同祖先来完成的，通过event up 改变父组件状态值 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091const scaleNames = &#123; c: &apos;Celsius&apos;, f: &apos;Fahrenheit&apos;&#125;;function toCelsius(fahrenheit) &#123; return (fahrenheit - 32) * 5 / 9;&#125;function toFahrenheit(celsius) &#123; return (celsius * 9 / 5) + 32;&#125;function tryConvert(temperature, convert) &#123; const input = parseFloat(temperature); if (Number.isNaN(input)) &#123; return &apos;&apos;; &#125; const output = convert(input); const rounded = Math.round(output * 1000) / 1000; return rounded.toString();&#125;function BoilingVerdict(props) &#123; if (props.celsius &gt;= 100) &#123; return &lt;p&gt;The water would boil.&lt;/p&gt;; &#125; return &lt;p&gt;The water would not boil.&lt;/p&gt;;&#125;class TemperatureInput extends React.Component &#123; constructor(props) &#123; super(props); this.handleChange = this.handleChange.bind(this); &#125; handleChange(e) &#123; this.props.onTemperatureChange(e.target.value); &#125; render() &#123; const temperature = this.props.temperature; const scale = this.props.scale; return ( &lt;fieldset&gt; &lt;legend&gt;Enter temperature in &#123;scaleNames[scale]&#125;:&lt;/legend&gt; &lt;input value=&#123;temperature&#125; onChange=&#123;this.handleChange&#125; /&gt; &lt;/fieldset&gt; ); &#125;&#125;class Calculator extends React.Component &#123; constructor(props) &#123; super(props); this.handleCelsiusChange = this.handleCelsiusChange.bind(this); this.handleFahrenheitChange = this.handleFahrenheitChange.bind(this); this.state = &#123;temperature: &apos;&apos;, scale: &apos;c&apos;&#125;; &#125; handleCelsiusChange(temperature) &#123; this.setState(&#123;scale: &apos;c&apos;, temperature&#125;); &#125; handleFahrenheitChange(temperature) &#123; this.setState(&#123;scale: &apos;f&apos;, temperature&#125;); &#125; render() &#123; const scale = this.state.scale; const temperature = this.state.temperature; const celsius = scale === &apos;f&apos; ? tryConvert(temperature, toCelsius) : temperature; const fahrenheit = scale === &apos;c&apos; ? tryConvert(temperature, toFahrenheit) : temperature; return ( &lt;div&gt; &lt;TemperatureInput scale=&quot;c&quot; temperature=&#123;celsius&#125; onTemperatureChange=&#123;this.handleCelsiusChange&#125; /&gt; &lt;TemperatureInput scale=&quot;f&quot; temperature=&#123;fahrenheit&#125; onTemperatureChange=&#123;this.handleFahrenheitChange&#125; /&gt; &lt;BoilingVerdict celsius=&#123;parseFloat(celsius)&#125; /&gt; &lt;/div&gt; ); &#125;&#125; 在任何一个react对象中，任何数据都应该是单一来源。 这个状态需要第一时间被添加到它需要的组件上，如果其他组件也需要它，我们可以把他的状态提升到它最近的组件上，而不是试图在不同组件同步,这就是自相而下的数据流。]]></content>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[react-Refs and the DOM]]></title>
    <url>%2F2017%2F07%2F14%2Freact-Refs-and-the-DOM%2F</url>
    <content type="text"><![CDATA[有时候我们需要修改子元素，我们必须通过父元素的传递props来重新渲染，reac提供了方便修改子元素的方法，那就是采用refs属性进行操作dom，但是我们不要随便操作dom什么时候使用refs 管理焦点，文本，媒体播放 需要触发的命令动画 继承的第三方dom库 举一个例子123456789101112131415161718192021// refclass CustomTextInput extends Component &#123; constructor(props)&#123; super(props) this.focus = this.focus.bind(this); &#125; focus()&#123; this.textInput.focus(); &#125; render()&#123; return (&lt;div&gt; &lt;input type=&quot;text&quot; ref=&#123;(input) =&gt; &#123;this.textInput = input&#125;&#125; /&gt; &lt;/div&gt;) &#125;&#125; 我们必须在class定义的组件使用ref，是function将不起作用的，那是因为他们不存在实例，但是我们可以在function中具体的html元素或者类组件使用ref 123456789101112131415161718192021function CustomTextInput(props) &#123; // textInput must be declared here so the ref callback can refer to it let textInput = null; function handleClick() &#123; textInput.focus(); &#125; return ( &lt;div&gt; &lt;input type=&quot;text&quot; ref=&#123;(input) =&gt; &#123; textInput = input; &#125;&#125; /&gt; &lt;input type=&quot;button&quot; value=&quot;Focus the text input&quot; onClick=&#123;handleClick&#125; /&gt; &lt;/div&gt; ); &#125; 暴露refs给父组件 在一些情况下，我们想访问父组件下的子组件，但是通常是不允许的，这会破坏组件的封装性，但是我们可以传一个特殊的属性给子元素，从而操作子元素的dom 123456789101112131415161718192021function CustomTextInput(props) &#123; console.log(props.inputRef); return ( &lt;div&gt; &lt;input ref=&#123;props.inputRef&#125; /&gt; &lt;/div&gt; );&#125;class Parent extends React.Component &#123; render() &#123; // console.log(this.inpsstElement); return ( &lt;CustomTextInput inputRef=&#123;el =&gt; this.inputElement =el&#125; /&gt; ); &#125;&#125; 以上的方式既适合class组件也是function组件]]></content>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[react-Typechecking With PropTypes]]></title>
    <url>%2F2017%2F07%2F14%2Freact-Typechecking-With-PropTypes%2F</url>
    <content type="text"><![CDATA[利用类型检查限制属性的类型，防止出现类型不准确的情况123456789101112131415161718//类型的匹配class Greeting extends Component &#123; render() &#123; console.log(); return (&lt;div&gt; &lt;h1&gt; Hello,&#123;this.props.name&#125; &lt;/h1&gt; &lt;/div&gt;) &#125;&#125;Greeting.PropTypes = &#123; name:PropTypes.string&#125; PropTypes1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980import PropTypes from &apos;prop-types&apos;;MyComponent.propTypes = &#123; // You can declare that a prop is a specific JS primitive. By default, these // are all optional. optionalArray: PropTypes.array, optionalBool: PropTypes.bool, optionalFunc: PropTypes.func, optionalNumber: PropTypes.number, optionalObject: PropTypes.object, optionalString: PropTypes.string, optionalSymbol: PropTypes.symbol, // Anything that can be rendered: numbers, strings, elements or an array // (or fragment) containing these types. optionalNode: PropTypes.node, // A React element. optionalElement: PropTypes.element, // You can also declare that a prop is an instance of a class. This uses // JS&apos;s instanceof operator. optionalMessage: PropTypes.instanceOf(Message), // You can ensure that your prop is limited to specific values by treating // it as an enum. optionalEnum: PropTypes.oneOf([&apos;News&apos;, &apos;Photos&apos;]), // An object that could be one of many types optionalUnion: PropTypes.oneOfType([ PropTypes.string, PropTypes.number, PropTypes.instanceOf(Message) ]), // An array of a certain type optionalArrayOf: PropTypes.arrayOf(PropTypes.number), // An object with property values of a certain type optionalObjectOf: PropTypes.objectOf(PropTypes.number), // An object taking on a particular shape optionalObjectWithShape: PropTypes.shape(&#123; color: PropTypes.string, fontSize: PropTypes.number &#125;), // You can chain any of the above with `isRequired` to make sure a warning // is shown if the prop isn&apos;t provided. requiredFunc: PropTypes.func.isRequired, // A value of any data type requiredAny: PropTypes.any.isRequired, // You can also specify a custom validator. It should return an Error // object if the validation fails. Don&apos;t `console.warn` or throw, as this // won&apos;t work inside `oneOfType`. customProp: function(props, propName, componentName) &#123; if (!/matchme/.test(props[propName])) &#123; return new Error( &apos;Invalid prop `&apos; + propName + &apos;` supplied to&apos; + &apos; `&apos; + componentName + &apos;`. Validation failed.&apos; ); &#125; &#125;, // You can also supply a custom validator to `arrayOf` and `objectOf`. // It should return an Error object if the validation fails. The validator // will be called for each key in the array or object. The first two // arguments of the validator are the array or object itself, and the // current item&apos;s key. customArrayProp: PropTypes.arrayOf(function(propValue, key, componentName, location, propFullName) &#123; if (!/matchme/.test(propValue[key])) &#123; return new Error( &apos;Invalid prop `&apos; + propFullName + &apos;` supplied to&apos; + &apos; `&apos; + componentName + &apos;`. Validation failed.&apos; ); &#125; &#125;)&#125;; 必须存在一个子元素 Requiring Single Child1234567891011121314151617import PropTypes from &apos;prop-types&apos;;class MyComponent extends React.Component &#123; render() &#123; // This must be exactly one element or it will warn. const children = this.props.children; return ( &lt;div&gt; &#123;children&#125; &lt;/div&gt; ); &#125;&#125;MyComponent.propTypes = &#123; children: PropTypes.element.isRequired&#125;; Default Prop Values 默认的属性值123456789101112131415161718class Greeting extends React.Component &#123; render() &#123; return ( &lt;h1&gt;Hello, &#123;this.props.name&#125;&lt;/h1&gt; ); &#125;&#125;// Specifies the default values for props:Greeting.defaultProps = &#123; name: &apos;Stranger&apos;&#125;;// Renders &quot;Hello, Stranger&quot;:ReactDOM.render( &lt;Greeting /&gt;, document.getElementById(&apos;example&apos;)); 属性检查发生在默认属性值完成之后，所以他也可以对默认属性进行检查类型]]></content>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[react -JSX In Depth]]></title>
    <url>%2F2017%2F07%2F13%2Freact-JSX-In-Depth%2F</url>
    <content type="text"><![CDATA[JSX的语法糖是以下格式 React.createElement(component,props,..childeren) 123456789101112compiles before:&lt;MyButton color=&quot;blue&quot; shadowSize=&#123;2&#125;&gt; Click Me&lt;/MyButton&gt;compiles into:React.createElement( MyButton, &#123;color: &apos;blue&apos;, shadowSize: 2&#125;, &apos;Click Me&apos;) 使用点作为jsx的类型 Using Dot Notation for JSX Type123456789const MyComponents = &#123; DatePicker: function DatePicker(props) &#123; return &lt;div&gt;Imagine a &#123;props.color&#125; datepicker here.&lt;/div&gt;; &#125;&#125;function BlueDatePicker() &#123; return &lt;MyComponents.DatePicker color=&quot;blue&quot; /&gt;;&#125; 自定义的组件必须大写，否则jsx认为元素是html标签1234567891011121314151617181920212223242526import React from &apos;react&apos;;// Wrong! This is a component and should have been capitalized:function hello(props) &#123; // Correct! This use of &lt;div&gt; is legitimate because div is a valid HTML tag: return &lt;div&gt;Hello &#123;props.toWhat&#125;&lt;/div&gt;;&#125;function HelloWorld() &#123; // Wrong! React thinks &lt;hello /&gt; is an HTML tag because it&apos;s not capitalized: return &lt;hello toWhat=&quot;World&quot; /&gt;;&#125;import React from &apos;react&apos;;// Correct! This is a component and should be capitalized:function Hello(props) &#123; // Correct! This use of &lt;div&gt; is legitimate because div is a valid HTML tag: return &lt;div&gt;Hello &#123;props.toWhat&#125;&lt;/div&gt;;&#125;function HelloWorld() &#123; // Correct! React knows &lt;Hello /&gt; is a component because it&apos;s capitalized. return &lt;Hello toWhat=&quot;World&quot; /&gt;;&#125; JSX的类型不能是一个不能是一个表达式1234567891011121314151617181920212223242526import React from &apos;react&apos;;import &#123; PhotoStory, VideoStory &#125; from &apos;./stories&apos;;const components = &#123; photo: PhotoStory, video: VideoStory&#125;;function Story(props) &#123; // Wrong! JSX type can&apos;t be an expression. return &lt;components[props.storyType] story=&#123;props.story&#125; /&gt;;&#125;import React from &apos;react&apos;;import &#123; PhotoStory, VideoStory &#125; from &apos;./stories&apos;;const components = &#123; photo: PhotoStory, video: VideoStory&#125;;function Story(props) &#123; // Correct! JSX type can be a capitalized variable. const SpecificStory = components[props.storyType]; return &lt;SpecificStory story=&#123;props.story&#125; /&gt;;&#125; Props in JSX 在jsx中只能存在表达式，if和for 都不属于表达式，所以在里面不能用他们，但是有替代方法 123456789function NumberDescriber(props) &#123; let description; if (props.number % 2 == 0) &#123; description = &lt;strong&gt;even&lt;/strong&gt;; &#125; else &#123; description = &lt;i&gt;odd&lt;/i&gt;; &#125; return &lt;div&gt;&#123;props.number&#125; is an &#123;description&#125; number&lt;/div&gt;;&#125; 使用字面量以及符号转义 1234567&lt;MyComponent message=&quot;hello world&quot; /&gt;&lt;MyComponent message=&#123;&apos;hello world&apos;&#125; /&gt;&lt;MyComponent message=&quot;&amp;lt;3&quot; /&gt;&lt;MyComponent message=&#123;&apos;&lt;3&apos;&#125; /&gt; 属性默认为true，一般不推荐使用，与es6的{foo}({foo:foo})省略很相近123&lt;MyTextBox autocomplete /&gt;&lt;MyTextBox autocomplete=&#123;true&#125; /&gt; 利用es6的…传播属性（props）12345678function App1() &#123; return &lt;Greeting firstName=&quot;Ben&quot; lastName=&quot;Hector&quot; /&gt;;&#125;function App2() &#123; const props = &#123;firstName: &apos;Ben&apos;, lastName: &apos;Hector&apos;&#125;; return &lt;Greeting &#123;...props&#125; /&gt;;&#125; false null undefind true 这些不会被渲染出来但是他们将可以作为boolean值判断1234&lt;div&gt; &#123;showHeader &amp;&amp; &lt;Header /&gt;&#125; &lt;Content /&gt;&lt;/div&gt;]]></content>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[react-Composition vs Inheritance]]></title>
    <url>%2F2017%2F07%2F13%2Freact-Composition-vs-Inheritance%2F</url>
    <content type="text"><![CDATA[组合vs继承 react 推荐使用组合，组合可以提高重复利用性，减少模块间的耦合 包含 react组件不知道有没有子元素，对那些像盒子一样的公共组件，它通过一个特殊的children属性来添加子组件输出 1234567891011121314151617//包含function FancyBorder(props) &#123; return ( &lt;div&gt; &lt;p&gt;&#123;props.color&#125;&lt;/p&gt; &#123;props.children&#125; &lt;/div&gt; )&#125;function WelcomeDialog() &#123; return (&lt;FancyBorder color=&quot;blue&quot;&gt; &lt;h1&gt;我是标题啊&lt;/h1&gt; &lt;p&gt;我是内容啊&lt;/p&gt; &lt;/FancyBorder&gt;)&#125; 在FancyBorder组件里面的内容将被传递给它的props.children属性，按原样输出 我们可以自定义自己传入的子组件12345678910111213141516171819202122232425function Contacts() &#123; return (&lt;div&gt;我是Contacts&lt;/div&gt;)&#125;function Chat() &#123; return (&lt;div&gt;我是Chat&lt;/div&gt;)&#125;function SplitPane(props) &#123; return ( &lt;div&gt; &lt;p&gt;显示啊&lt;/p&gt; &lt;div&gt; &#123;props.left&#125; &lt;/div&gt; &lt;div&gt; &#123;props.right&#125; &lt;/div&gt; &lt;/div&gt; )&#125;function Just() &#123; return (&lt;SplitPane left=&#123;&lt;Contacts/&gt;&#125; right=&#123;&lt;Chat/&gt;&#125;/&gt;)&#125; 被定义为类的组件在组合方面同样优秀123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354//类的组合function FancyBorder(props) &#123; return ( &lt;div style=&#123;&#123;background:&quot;#f99&quot;&#125;&#125;&gt; &lt;p&gt;&#123;props.color&#125;Dialog&lt;/p&gt; &lt;p&gt; &#123;props.children&#125; &lt;/p&gt; &lt;/div&gt; )&#125;function Dialog(props) &#123; return ( &lt;FancyBorder color=&quot;blue&quot;&gt; &lt;h2&gt;我是Dialog&lt;/h2&gt; &lt;h1 className=&quot;Dialog-title&quot;&gt; &#123;props.title&#125; &lt;/h1&gt; &lt;p className=&quot;Dialog-message&quot;&gt; &#123;props.message&#125; &lt;/p&gt; &#123;props.children&#125; &lt;/FancyBorder&gt; )&#125;class SignUpDailog extends Component &#123; constructor(props) &#123; super(props); this.handleChange = this.handleChange.bind(this); this.handleSignUp= this.handleSignUp.bind(this); this.state = &#123;login:&apos;&apos;&#125; &#125; render()&#123; return (&lt;Dialog title=&quot;我是真标题&quot; message=&quot;我是假信息&quot;&gt; &lt;input type=&quot;text&quot; value=&#123;this.state.login&#125; onChange=&#123;this.handleChange&#125;/&gt; &lt;button onClick=&#123;this.handleSignUp&#125;&gt;点我&lt;/button&gt; &lt;/Dialog&gt;) &#125; handleChange(e)&#123; this.setState(&#123;login:e.target.value&#125;) &#125; handleSignUp()&#123; alert(`hahah ,$&#123;this.state.login&#125;`) &#125;&#125;]]></content>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[react -Forms]]></title>
    <url>%2F2017%2F07%2F11%2Freact-Forms%2F</url>
    <content type="text"><![CDATA[react中的表单1234567&lt;form&gt; &lt;label&gt; Name: &lt;input type=&quot;text&quot; name=&quot;name&quot; /&gt; &lt;/label&gt; &lt;input type=&quot;submit&quot; value=&quot;Submit&quot; /&gt;&lt;/form&gt; 控制组件 Controlled Components 将用户操作输入框与setState()状态值改变联合起来，从而实现单一数据流，这叫控制组件 123456789101112131415161718192021222324252627282930class NameForm extends React.Component &#123; constructor(props) &#123; super(props); this.state = &#123;value: &apos;&apos;&#125;; this.handleChange = this.handleChange.bind(this); this.handleSubmit = this.handleSubmit.bind(this); &#125; handleChange(event) &#123; this.setState(&#123;value: event.target.value&#125;); &#125; handleSubmit(event) &#123; alert(&apos;A name was submitted: &apos; + this.state.value); event.preventDefault(); &#125; render() &#123; return ( &lt;form onSubmit=&#123;this.handleSubmit&#125;&gt; &lt;label&gt; Name: &lt;input type=&quot;text&quot; value=&#123;this.state.value&#125; onChange=&#123;this.handleChange&#125; /&gt; &lt;/label&gt; &lt;input type=&quot;submit&quot; value=&quot;Submit&quot; /&gt; &lt;/form&gt; ); &#125;&#125; The textarea Tag 对于文本框，react依然通过value来进行操作 1234567&lt;form onSubmit=&#123;this.handleSubmit&#125;&gt; &lt;label&gt; Name: &lt;textarea value=&#123;this.state.value&#125; onChange=&#123;this.handleChange&#125; /&gt; &lt;/label&gt; &lt;input type=&quot;submit&quot; value=&quot;Submit&quot; /&gt;&lt;/form&gt; The select Tag 对于下拉框，我们将默认值放在了select上,于是只要更新一个地方就好 123456789101112&lt;form onSubmit=&#123;this.handleSubmit&#125;&gt; &lt;label&gt; Pick your favorite La Croix flavor: &lt;select value=&#123;this.state.value&#125; onChange=&#123;this.handleChange&#125;&gt; &lt;option value=&quot;grapefruit&quot;&gt;Grapefruit&lt;/option&gt; &lt;option value=&quot;lime&quot;&gt;Lime&lt;/option&gt; &lt;option value=&quot;coconut&quot;&gt;Coconut&lt;/option&gt; &lt;option value=&quot;mango&quot;&gt;Mango&lt;/option&gt; &lt;/select&gt; &lt;/label&gt; &lt;input type=&quot;submit&quot; value=&quot;Submit&quot; /&gt;&lt;/form&gt; 1234567891011121314151617181920212223242526272829303132333435363738394041424344class Reservation extends Component &#123; constructor(props) &#123; super(props) this.state =&#123; isGoing:true, numberOfGuests:2 &#125; this.handleInputChange = this.handleInputChange.bind(this) &#125; handleInputChange(event) &#123; const target =event.target; const value =target.type == &apos;checkbox&apos; ? target.checked : target.value; const name =target.name; console.log(value,name,520) this.setState(&#123; [name]:value &#125;) &#125; render () &#123; return ( &lt;form&gt; &lt;label&gt; Is going: &lt;input type=&quot;checkbox&quot; name=&quot;isGoing&quot; checked=&#123;this.state.isGoing&#125; onChange=&#123;this.handleInputChange&#125; /&gt; &lt;/label&gt; &lt;br/&gt; &lt;laber&gt; Number of guests: &lt;input type=&quot;number&quot; name=&quot;numberOfGuests&quot; value=&#123;this.state.numberValue&#125; onChange=&#123;this.handleInputChange&#125; /&gt; &lt;/laber&gt; &lt;/form&gt; ) &#125;&#125;]]></content>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[react-Lists and Keys]]></title>
    <url>%2F2017%2F07%2F10%2Freact-Lists-and-Keys%2F</url>
    <content type="text"><![CDATA[Rendering Multiple Components 如何重复渲染多个组件1234567891011//生成无序列表function NumberList(props) &#123; const numbers = props.numbers; const listItems = numbers.map((number) =&gt; &lt;li&gt;&#123;number&#125;&lt;/li&gt;) return ( &lt;ul&gt; &#123;listItems&#125; &lt;/ul&gt; )&#125; 在做循环渲染的时候，控制台会报出an array or iterator should have a unique “key” prop，我们必须添加一个key const listItems = numbers.map((number) =&gt; {number}) Keys help React identify which items have changed, are added, or are removed 不推荐使用一下方式，因为列表一旦重新，它的效率非常慢123456const todoItems = todos.map((todo, index) =&gt; // Only do this if items have no stable IDs &lt;li key=&#123;index&#125;&gt; &#123;todo.text&#125; &lt;/li&gt;); 当li为根元素时，我们只能把key加到组件上 Example: Incorrect Key Usage 12345678910111213141516171819202122232425262728function ListItem(props) &#123; const value = props.value; return ( // Wrong! There is no need to specify the key here: &lt;li key=&#123;value.toString()&#125;&gt; &#123;value&#125; &lt;/li&gt; );&#125;function NumberList(props) &#123; const numbers = props.numbers; const listItems = numbers.map((number) =&gt; // Wrong! The key should have been specified here: &lt;ListItem value=&#123;number&#125; /&gt; ); return ( &lt;ul&gt; &#123;listItems&#125; &lt;/ul&gt; );&#125;const numbers = [1, 2, 3, 4, 5];ReactDOM.render( &lt;NumberList numbers=&#123;numbers&#125; /&gt;, document.getElementById(&apos;root&apos;)); Example: Correct Key Usage 123456789101112131415161718192021222324function ListItem(props) &#123; // Correct! There is no need to specify the key here: return &lt;li&gt;&#123;props.value&#125;&lt;/li&gt;;&#125;function NumberList(props) &#123; const numbers = props.numbers; const listItems = numbers.map((number) =&gt; // Correct! Key should be specified inside the array. &lt;ListItem key=&#123;number.toString()&#125; value=&#123;number&#125; /&gt; ); return ( &lt;ul&gt; &#123;listItems&#125; &lt;/ul&gt; );&#125;const numbers = [1, 2, 3, 4, 5];ReactDOM.render( &lt;NumberList numbers=&#123;numbers&#125; /&gt;, document.getElementById(&apos;root&apos;)); 对于key值，只有在不同的数组上才能重复使用 12345678910111213141516171819202122//重复使用Keyclass Blog extends Component &#123; constructor(props)&#123; super(props) this.sidebar =(&lt;ul&gt;&#123;props.posts.map((post) =&gt; &lt;li key=&#123;post.id&#125;&gt;&#123;post.title&#125;&lt;/li&gt;)&#125;&lt;/ul&gt;); this.content = props.posts.map((post) =&gt; &lt;div key=&#123;post.id&#125;&gt;&lt;h3&gt;&#123;post.title&#125;&lt;/h3&gt;;&lt;p&gt;&#123;post.content&#125;&lt;/p&gt; &lt;/div&gt;); &#125; render ()&#123; return (&lt;div&gt; &#123;this.sidebar&#125; &lt;hr/&gt; &#123;this.content&#125; &lt;/div&gt;) &#125;&#125;const posts = [ &#123;id: 1, title: &apos;Hello World&apos;, content: &apos;Welcome to learning React!&apos;&#125;, &#123;id: 2, title: &apos;Installation&apos;, content: &apos;You can install React from npm.&apos;&#125;]; Embedding map() in JSX map的两种用法 第一种 123456789101112function NumberList(props) &#123; const numbers = props.numbers; const listItems = numbers.map((number) =&gt; &lt;ListItem key=&#123;number.toString()&#125; value=&#123;number&#125; /&gt; ); return ( &lt;ul&gt; &#123;listItems&#125; &lt;/ul&gt; );&#125; 第二种 1234567891011function NumberList(props) &#123; const numbers = props.numbers; return ( &lt;ul&gt; &#123;numbers.map((number) =&gt; &lt;ListItem key=&#123;number.toString()&#125; value=&#123;number&#125; /&gt; )&#125; &lt;/ul&gt; );&#125;]]></content>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[react- react-Conditional Rendering]]></title>
    <url>%2F2017%2F07%2F09%2Freact-react-Conditional-Rendering%2F</url>
    <content type="text"><![CDATA[条件渲染，通过某些条件加载不同功能的组件1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465class Toggle extends Component&#123; constructor(props)&#123; super(props) this.state = &#123;isToggleOn:true&#125; // This binding is necessary to make `this` work in the callback // this.handleClick = this.handleClick.bind(this) &#125; /*handleClick()&#123; // var that = this; this.setState(prevState =&gt;(&#123; isToggleOn:!prevState.isToggleOn &#125;)); &#125;*/ handleClick = () =&gt;&#123; this.setState(prevState =&gt;(&#123; isToggleOn:!prevState.isToggleOn &#125;)); &#125; render()&#123; if(this.state.isToggleOn)&#123; return ( &lt;div&gt; &lt;button onClick=&#123;this.handleClick&#125;&gt; &#123;this.state.isToggleOn ? &apos;ON&apos; : &apos;OFF&apos;&#125; &lt;/button&gt; &lt;UserGreeting/&gt; &lt;/div&gt; ) &#125;else&#123; return ( &lt;div&gt; &lt;button onClick=&#123;this.handleClick&#125;&gt; &#123;this.state.isToggleOn ? &apos;ON&apos; : &apos;OFF&apos;&#125; &lt;/button&gt; &lt;GuestGreeting/&gt; &lt;/div&gt; ) &#125; &#125;&#125;function UserGreeting(props) &#123; return ( &lt;div&gt; &lt;h1&gt; Welcome back! &lt;/h1&gt; &lt;/div&gt; )&#125;function GuestGreeting(props) &#123; return ( &lt;div&gt; &lt;h1&gt; sign up &lt;/h1&gt; &lt;/div&gt; )&#125; Element Variables 元素变量 通过条件展示适合的组件123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566class LoginControl extends Component &#123; constructor(props)&#123; super(props) this.handleLoginClick = this.handleLoginClick.bind(this); this.handleLogoutClick = this.handleLogoutClick.bind(this); this.state = &#123;isLoggedIn:false&#125; &#125; handleLoginClick() &#123; this.setState(&#123;isLoggedIn:true&#125;) &#125; handleLogoutClick()&#123; this.setState(&#123;isLoggedIn:false&#125;) &#125; render()&#123; const isLoggedIn = this.state.isLoggedIn; let button = null; if(isLoggedIn) &#123; button = &lt;LogoutButton onClick =&#123;this.handleLogoutClick&#125; /&gt; &#125;else&#123; button = &lt;LoginButton onClick =&#123;this.handleLoginClick&#125; /&gt; &#125; return ( &lt;div&gt; &lt;Greeting isLoggedIn=&#123;isLoggedIn&#125; /&gt; &#123;button&#125; &lt;/div&gt; ) &#125;&#125;function UserGreeting() &#123; return &lt;h1&gt;Welcome back!&lt;/h1&gt;&#125;function GuestGreeting() &#123; return &lt;h1&gt;please sign up&lt;/h1&gt;&#125;function Greeting(props) &#123; const isLoggedIn = props.isLoggedIn; if(isLoggedIn)&#123; return &lt;UserGreeting/&gt; &#125; return &lt;GuestGreeting/&gt;&#125;function LoginButton(props) &#123; return ( &lt;button onClick=&#123;props.onClick&#125;&gt; Login &lt;/button&gt; )&#125;function LogoutButton(props) &#123; return ( &lt;button onClick=&#123;props.onClick&#125;&gt; logout &lt;/button&gt; )&#125; Inline If with Logical &amp;&amp; Operator 在jsx中可以插入任何表达式在花括号中，当然也包括元素 12345678910111213141516171819function Mailbox (props) &#123; const unreadMessages = props.unreadMessages; return ( &lt;div&gt; &lt;h1&gt; Hello! &lt;/h1&gt; &#123; unreadMessages.length &gt;2 &amp;&amp; &lt;h2&gt; you have &#123;unreadMessages.length&#125; unread messages. &lt;/h2&gt; &#125; //表达式为真输出元素 &lt;/div&gt; )&#125;const messages = [&apos;React&apos;,&apos;re:react&apos;,&apos;react:React&apos;]; nline If-Else with Conditional Operator 改写上面的例子 12345678910111213141516171819202122232425262728293031323334353637class LoginControl extends Component &#123; constructor(props)&#123; super(props) this.handleLoginClick = this.handleLoginClick.bind(this); this.handleLogoutClick = this.handleLogoutClick.bind(this); this.state = &#123;isLoggedIn:false&#125; &#125; handleLoginClick() &#123; this.setState(&#123;isLoggedIn:true&#125;) &#125; handleLogoutClick()&#123; this.setState(&#123;isLoggedIn:false&#125;) &#125; render()&#123; const isLoggedIn = this.state.isLoggedIn; let button = null; /*if(isLoggedIn) &#123; button = &lt;LogoutButton onClick =&#123;this.handleLogoutClick&#125; /&gt; &#125;else&#123; button = &lt;LoginButton onClick =&#123;this.handleLoginClick&#125; /&gt; &#125;*/ return ( &lt;div&gt; &lt;Greeting isLoggedIn=&#123;isLoggedIn&#125; /&gt; &#123; isLoggedIn ? (&lt;LogoutButton onClick =&#123;this.handleLogoutClick&#125; /&gt;) : (&lt;LoginButton onClick =&#123;this.handleLoginClick&#125; /&gt;) &#125; &lt;/div&gt; ) &#125;&#125; Preventing Component from Rendering 阻止组件的渲染//阻止组件的渲染 1234567891011121314151617181920212223242526272829303132function WaringBanner(props) &#123; if(!props.warn)&#123; console.log(&quot;nihao &quot;); return null; &#125; return (&lt;div className=&quot;waring&quot;&gt;警告&lt;/div&gt;)&#125;class Page extends Component &#123; constructor(props) &#123; super(props) this.state = &#123;showWarning:true&#125; this.handleToggleClick = this.handleToggleClick.bind(this); &#125; handleToggleClick() &#123; this.setState( prevState =&gt;(&#123; showWarning:!prevState.showWarning &#125;) ) &#125; render ()&#123; return (&lt;div&gt; &lt;WaringBanner warn=&#123;this.state.showWarning&#125;/&gt; &lt;button onClick=&#123;this.handleToggleClick&#125;&gt; &#123;this.state.showWarning ? &apos;Hide&apos; : &apos;Show&apos;&#125; &lt;/button&gt; &lt;/div&gt;) &#125;&#125;]]></content>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[react-Handling Events]]></title>
    <url>%2F2017%2F07%2F06%2Freact-Handling-Events%2F</url>
    <content type="text"><![CDATA[事件处理函数 采用驼峰命名 使用JSX，将一个函数作为事件处理程序传递，而不是一个字符串 12345678910111213141516171819202122class Button extends Component&#123; constructor (props) &#123; super(props) &#125; render () &#123; return ( &lt;div&gt; &lt;button onClick=&#123;changeColor&#125;&gt; 我是按钮 &lt;/button&gt; &lt;/div&gt; ) &#125;&#125;function changeColor ()&#123; console.log(&quot;我被执行了&quot;);&#125; 在jsx语法中，必须要小心this，我们如果不绑定this。这个this将为undefined 12345678910111213141516171819202122232425class Toggle extends Component&#123; constructor(props)&#123; super(props) this.state = &#123;isToggleOn:true&#125; // This binding is necessary to make `this` work in the callback this.handleClick = this.handleClick.bind(this) &#125; handleClick()&#123; // var that = this; this.setState(prevState =&gt;(&#123; isToggleOn:!prevState.isToggleOn &#125;)); &#125; render()&#123; return ( &lt;div&gt; &lt;button onClick=&#123;this.handleClick&#125;&gt; &#123;this.state.isToggleOn ? &apos;ON&apos; : &apos;OFF&apos;&#125; &lt;/button&gt; &lt;/div&gt; ) &#125;&#125; 两种方式解决 this的指向问题 属性初始化语法property initializer syntax 12345678910111213141516171819202122232425262728293031class Toggle extends Component&#123; constructor(props)&#123; super(props) this.state = &#123;isToggleOn:true&#125; // This binding is necessary to make `this` work in the callback // this.handleClick = this.handleClick.bind(this) &#125; /*handleClick()&#123; // var that = this; this.setState(prevState =&gt;(&#123; isToggleOn:!prevState.isToggleOn &#125;)); &#125;*/ handleClick = () =&gt;&#123; this.setState(prevState =&gt;(&#123; isToggleOn:!prevState.isToggleOn &#125;)); &#125; render()&#123; return ( &lt;div&gt; &lt;button onClick=&#123;this.handleClick&#125;&gt; &#123;this.state.isToggleOn ? &apos;ON&apos; : &apos;OFF&apos;&#125; &lt;/button&gt; &lt;/div&gt; ) &#125;&#125; arrow function 箭头函数 123456789101112131415161718192021222324252627class Toggle extends Component&#123; constructor(props)&#123; super(props) this.state = &#123;isToggleOn:true&#125; // This binding is necessary to make `this` work in the callback // this.handleClick = this.handleClick.bind(this) &#125; handleClick()&#123; // var that = this; this.setState(prevState =&gt;(&#123; isToggleOn:!prevState.isToggleOn &#125;)); &#125; render()&#123; return ( &lt;div&gt; &lt;button onClick=&#123;(e) =&gt;this.handleClick(e)&#125;&gt; &#123;this.state.isToggleOn ? &apos;ON&apos; : &apos;OFF&apos;&#125; &lt;/button&gt; &lt;/div&gt; ) &#125;&#125;//这种箭头函数方法每次执行都会创建不同的回调，大多数情况下是好的，但是在向子组件传递时，会导致子组件的再一次渲染。 #]]></content>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[react-State and Lifecycle]]></title>
    <url>%2F2017%2F07%2F04%2Freact-State-and-Lifecycle%2F</url>
    <content type="text"><![CDATA[利用定时器实现UI的刷新1234567891011121314151617function Clock(props) &#123; return ( &lt;div&gt; &lt;h1&gt;Hello, world!&lt;/h1&gt; &lt;h2&gt;It is &#123;props.date.toLocaleTimeString()&#125;.&lt;/h2&gt; &lt;/div&gt; );&#125;function tick() &#123; ReactDOM.render( &lt;Clock date=&#123;new Date()&#125; /&gt;, document.getElementById(&apos;root&apos;) );&#125;setInterval(tick, 1000); 这样的方法导致ui每秒都在更新，即时用户没有改变数据也在实时刷新，导致性能差，替代的方法是定义一个state作为一个定时器，他类似于props，但是他是私有的，控制着整个组件。 从函数到类的转变 Converting a Function to a Class function的写法 12345function Add(props)&#123; return (&lt;div&gt; &#123;props.a&#125;+&#123;props.b&#125;=&#123;props.a+props.b&#125; &lt;/div&gt;)&#125; es6写法 12345678910class Add extends Component &#123; render() &#123; return ( &lt;div&gt; 这是es6的语法哦 &#123;this.props.a&#125;+&#123;this.props.b&#125; = &#123;this.props.a+this.props.b&#125; &lt;/div&gt; ) &#125;&#125; 新增一个class constructor 来初始化 this.state 12345678910111213141516171819class Show extends Component&#123; constructor(props) &#123; super(props) this.state=&#123; name:&apos;ly&apos;, age:18 &#125; &#125; render () &#123; return ( &lt;div&gt; &lt;p&gt;name:&#123;this.state.name&#125;&lt;/p&gt; &lt;p&gt;age:&#123;this.state.age&#125;&lt;/p&gt; &lt;/div&gt; ) &#125;&#125; 生命周期 Adding Lifecycle Methods to a Class componentDidMount执行的条件是在第一次加载组件完成时触发 componentWillUnmount 执行的条件是组件即将被销毁 利用这两个钩子函数可以实现时钟的实时更新，仅在局部的更新 1234567891011121314151617181920212223242526272829303132333435363738class Show extends Component&#123; constructor(props) &#123; super(props) this.state=&#123; name:&apos;ly&apos;, age:18, date: new Date().toLocaleString() &#125; &#125; componentDidMount()&#123; this.timer = setInterval(() =&gt; this.show(),1000) &#125; show () &#123; this.setState(&#123; date:new Date().toLocaleString() &#125;) //状态不能通过this.state.date=new Date().toLocalString() The only place where you can assign this.state is the constructor. 构造器可以直接操作 &#125; componentWillUnmount()&#123; clearInterval(this.timer) &#125; render () &#123; return ( &lt;div&gt; &lt;p&gt;name:&#123;this.state.name&#125;&lt;/p&gt; &lt;p&gt;age:&#123;this.state.age&#125;&lt;/p&gt; &lt;p&gt;现在的时间:&#123;this.state.date&#125;&lt;/p&gt; &lt;/div&gt; ) &#125;&#125; state 状态的改变是异步的 State Updates May Be Asynchronous 我们在使用props 和state 时 不应该依赖它们的值来计算下一个状态 12345678910111213141516171819//wrongcomponentDidMount () &#123; this.setState(&#123; counter1:this.state.counter1+this.state.counter2 &#125;) &#125;// correctcomponentDidMount () &#123; this.setState(function (prevState,props) &#123; console.log(prevState,props); return &#123; counter1:prevState.counter1+props.counter2 &#125; &#125;) &#125; 父元素向子元素传递信息 The Data Flows Down A component may choose to pass its state down as props to its child components 12345678910111213141516171819202122232425262728293031323334class Down extends Component&#123; constructor(props)&#123; super(props) &#125; render () &#123; return ( &lt;div&gt; &lt;p&gt;从父元素传数据过来了&#123;this.props.data&#125;&lt;/p&gt; &lt;/div&gt; ) &#125;&#125;class App extends Component &#123; constructor(props)&#123; super(props) this.state=&#123; data:&quot;飞呀飞呀&quot; &#125; &#125; render() &#123; return ( &lt;div className=&quot;App&quot;&gt; &lt;Show/&gt; &lt;Add/&gt; &lt;Down data=&#123;this.state.data&#125;/&gt; &lt;/div&gt; ); &#125;&#125; This is commonly called a “top-down” or “unidirectional” data flow]]></content>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[react-Components and Props]]></title>
    <url>%2F2017%2F07%2F03%2Freact-Components-and-Props%2F</url>
    <content type="text"><![CDATA[定义组件 Functional and Class Components 组件类似于一个函数，可以是function 也可以是class 他们返回的结果是一个组件（jsx） 第一种写法 123function Welcome(props) &#123; return &lt;h1&gt;Hello, &#123;props.name&#125;&lt;/h1&gt;;&#125; 第二种写法 12345class Welcome extends React.Component &#123; render() &#123; return &lt;h1&gt;Hello, &#123;this.props.name&#125;&lt;/h1&gt;; &#125;&#125; 渲染组件 通过ReactDOM.render()方法进行渲染 Rendering a Component, 123456789function Welcome(props) &#123; return &lt;h1&gt;Hello, &#123;props.name&#125;&lt;/h1&gt;;&#125;const element = &lt;Welcome name=&quot;Sara&quot; /&gt;;ReactDOM.render( element, document.getElementById(&apos;root&apos;)); 只是一个普通的dom元素，但是这是一个具有自己作用域的组件 组件使用 组件之间是可以重复使用的，看下面这个例子 Composing Components 12345678910111213141516171819202122232425262728293031function formatDate() &#123; return Date.now()+Math.random();&#125;function DateNow(props) &#123; return ( &lt;div&gt; &lt;h1&gt;Hello1,&#123;props.date&#125;&lt;/h1&gt; &lt;/div&gt; )&#125;class App extends Component &#123; render() &#123; return ( &lt;div className=&quot;App&quot;&gt; &lt;DateNow date=&#123;formatDate()&#125;/&gt; &lt;DateNow date=&#123;formatDate()&#125;/&gt; &lt;DateNow date=&#123;formatDate()&#125;/&gt; &lt;/div&gt; ); &#125;&#125;function tick() &#123; ReactDOM.render(&lt;App /&gt;, document.getElementById(&apos;root&apos;));&#125;setInterval(tick,1000) 组件与组件之间的提取与嵌套 Extracting Components 1234567891011121314151617181920212223242526272829303132333435363738394041//渲染页面function formatDate() &#123; return Date.now()+Math.random();&#125;function DateNow(props) &#123; return ( &lt;div&gt; &lt;h1&gt;Hello1,&#123;props.date&#125;&lt;/h1&gt; &lt;/div&gt; )&#125;function Show() &#123; return ( &lt;div&gt; &lt;DateNow date=&#123;formatDate()&#125;/&gt; &lt;DateNow date=&#123;formatDate()&#125;/&gt; &lt;DateNow date=&#123;formatDate()&#125;/&gt; &lt;/div&gt; )&#125;class App extends Component &#123; render() &#123; return ( &lt;div className=&quot;App&quot;&gt; &lt;Show/&gt; &lt;/div&gt; ); &#125;&#125;function tick() &#123; ReactDOM.render(&lt;App /&gt;, document.getElementById(&apos;root&apos;));&#125;setInterval(tick,1000) 组件传入的的属性必须是纯的 Props are Read-Only 正确的写法 123function sum(a, b) &#123; return a + b;&#125; 错误的写法 不能改变props的值 123function withdraw(account, amount) &#123; account.total -= amount;&#125; All React components must act like pure functions with respect to their props.react 的另一个属性state将可以间接的改变状态值，但是不违背它的初衷。`]]></content>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面试问题小计]]></title>
    <url>%2F2017%2F06%2F20%2F%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98%E5%B0%8F%E8%AE%A1%2F</url>
    <content type="text"><![CDATA[说一下undefind和null那个是全局变量 答:javaScript权威指南： null 和 undefined 都表示“值的空缺”，你可以认为undefined是表示系统级的、出乎意料的或类似错误的值的空缺，而null是表示程序级的、正常的或在意料之中的值的空缺。javaScript高级程序设计： 在使用var声明变量但未对其加以初始化时，这个变量的值就是undefined。 null值则是表示空对象指针。所以undefind是全局变量 一个页面适合写多少行代码？ 答：我记得是300行。 后台返回一个对象包含null怎么处理? 答:对所有使用到的json中的对象做判断,或者使用第三方json解析库http://www.cnblogs.com/LQCQ-Silent/p/6763264.html 参考 require和import的区别，那个是按需加载 答:require按需加载 为什么vue不能和jquery一起使用? 答:因为jquery是操作dom的，而vue是虚拟dom let var const 区别 答:let是块级作用域，函数内部使用let定义后，对函数外部无影响。var定义的变量可以修改，如果不初始化会输出undefined，不会报错。const定义的变量不可以修改，而且必须初始化。 vue如何做权限认证? 答:在路由阶段定义一个校验的阈值，然后在登录阶段保存状态信息，路由进行跳转，进行校验 良好的编程习惯体现在哪里? 答:打注释，代码整洁，函数命名要有意义]]></content>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[async与await体验]]></title>
    <url>%2F2017%2F02%2F11%2Fasync%E4%B8%8Eawait%E4%BD%93%E9%AA%8C%2F</url>
    <content type="text"><![CDATA[async与await体验 第一次用es7的语法，在实际的开发中可能用的比较少，但是作为前端这也算是一个趋势，先留个坑，以后慢慢学习 基本语法 async是一个异步的函数，通过它进行定义 await只能用在async函数的里面，它的出现必须要等到一个promise返回结构才能继续执行 基本用法12345678910111213141516const sleep = (time) =&gt; new Promise((resolve,reject) =&gt; &#123; setTimeout(() =&gt; &#123; resolve(&quot;ok&quot;); &#125;,time)&#125;)const test = async() =&gt; &#123; console.log(&quot;start&quot;); const ok = await sleep(3000); console.log(ok); console.log(&quot;end&quot;);&#125;test(); //start ok end 捕捉错误123456789101112131415161718192021const sleep = (time) =&gt; new Promise((resolve,reject) =&gt;&#123; setTimeout(() =&gt; reject(&quot;你错了&quot;),time)&#125;)const run = async() =&gt; &#123; try&#123; console.log(&apos;start&apos;); await sleep(3000); console.log(&apos;end&apos;); &#125;catch(err)&#123; console.log(err); &#125;finally&#123; console.log(&apos;over&apos;); &#125; console.log(&apos;over1&apos;);&#125;run();// start 你错了 over over1 循环多个await 它类似于同步代码 不用担心需要闭包才能解决问题12345678910111213const sleep = (time) =&gt; new Promise((resolve,reject) =&gt;&#123; setTimeout(() =&gt; resolve(true),time)&#125;)var run = async() =&gt; &#123; for (let i = 0;i&lt;3;i++) &#123; console.log(`当前是第$&#123;i&#125;次等待..`); await sleep(1000); &#125;&#125;run();//当前是第0次等待.. 当前是第1次等待.. 当前是第2次等待.. async返回的是什么 返回的是promise对象！！！！1234567const add =async() =&gt; &#123; return &quot;hello world&quot;&#125;console.log(add()); //Promise &#123;[[PromiseStatus]]: &quot;resolved&quot;, [[PromiseValue]]: &quot;hello world&quot;&#125;add().then((value)=&gt;console.log(value)); //hello world]]></content>
      <tags>
        <tag>异步</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[promise的用法深入3]]></title>
    <url>%2F2017%2F02%2F11%2Fpromise%E7%9A%84%E7%94%A8%E6%B3%95%E6%B7%B1%E5%85%A53%2F</url>
    <content type="text"><![CDATA[Promise.all()Promise.all方法用于将多个 Promise 实例，包装成一个新的 Promise 实例。 var p = Promise.all([p1, p2, p3]);上面代码中，Promise.all方法接受一个数组作为参数，p1、p2、p3都是 Promise 实例，如果不是，就会先调用下面讲到的Promise.resolve方法，将参数转为 Promise 实例，再进一步处理。（Promise.all方法的参数可以不是数组，但必须具有 Iterator 接口，且返回的每个成员都是 Promise 实例。） p的状态由p1、p2、p3决定，分成两种情况。 （1）只有p1、p2、p3的状态都变成fulfilled，p的状态才会变成fulfilled，此时p1、p2、p3的返回值组成一个数组，传递给p的回调函数。 （2）只要p1、p2、p3之中有一个被rejected，p的状态就变成rejected，此时第一个被reject的实例的返回值，会传递给p的回调函数。 下面是一个具体的例子。 // 生成一个Promise对象的数组 var promises = [2, 3, 5, 7, 11, 13].map(function (id) { return getJSON(&apos;/post/&apos; + id + &quot;.json&quot;); }); Promise.all(promises).then(function (posts) { // ... }).catch(function(reason){ // ... }); 上面代码中，promises是包含6个 Promise 实例的数组，只有这6个实例的状态都变成fulfilled，或者其中有一个变为rejected，才会调用Promise.all方法后面的回调函数。 下面是另一个例子。 const databasePromise = connectDatabase(); const booksPromise = databasePromise .then(findAllBooks); const userPromise = databasePromise .then(getCurrentUser); Promise.all([ booksPromise, userPromise ]) .then(([books, user]) =&gt; pickTopRecommentations(books, user)); 上面代码中，booksPromise和userPromise是两个异步操作，只有等到它们的结果都返回了，才会触发pickTopRecommentations这个回调函数。 注意，如果作为参数的 Promise 实例，自己定义了catch方法，那么它一旦被rejected，并不会触发Promise.all()的catch方法。 const p1 = new Promise((resolve, reject) =&gt; { resolve(&apos;hello&apos;); }) .then(result =&gt; result) .catch(e =&gt; e); const p2 = new Promise((resolve, reject) =&gt; { throw new Error(&apos;报错了&apos;); }) .then(result =&gt; result) .catch(e =&gt; e); Promise.all([p1, p2]) .then(result =&gt; console.log(result)) .catch(e =&gt; console.log(e)); // [&quot;hello&quot;, Error: 报错了] 上面代码中，p1会resolved，p2首先会rejected，但是p2有自己的catch方法，该方法返回的是一个新的 Promise 实例，p2指向的实际上是这个实例。该实例执行完catch方法后，也会变成resolved，导致Promise.all()方法参数里面的两个实例都会resolved，因此会调用then方法指定的回调函数，而不会调用catch方法指定的回调函数。 如果p2没有自己的catch方法，就会调用Promise.all()的catch方法。 const p1 = new Promise((resolve, reject) =&gt; { resolve(&apos;hello&apos;); }) .then(result =&gt; result); const p2 = new Promise((resolve, reject) =&gt; { throw new Error(&apos;报错了&apos;); }) .then(result =&gt; result); Promise.all([p1, p2]) .then(result =&gt; console.log(result)) .catch(e =&gt; console.log(e)); // Error: 报错了 Promise.race()Promise.race方法同样是将多个Promise实例，包装成一个新的Promise实例。 var p = Promise.race([p1, p2, p3]);上面代码中，只要p1、p2、p3之中有一个实例率先改变状态，p的状态就跟着改变。那个率先改变的 Promise 实例的返回值，就传递给p的回调函数。 Promise.race方法的参数与Promise.all方法一样，如果不是 Promise 实例，就会先调用下面讲到的Promise.resolve方法，将参数转为 Promise 实例，再进一步处理。 下面是一个例子，如果指定时间内没有获得结果，就将Promise的状态变为reject，否则变为resolve。 const p = Promise.race([ fetch(&apos;/resource-that-may-take-a-while&apos;), new Promise(function (resolve, reject) { setTimeout(() =&gt; reject(new Error(&apos;request timeout&apos;)), 5000) }) ]); p.then(response =&gt; console.log(response)); p.catch(error =&gt; console.log(error)); 上面代码中，如果5秒之内fetch方法无法返回结果，变量p的状态就会变为rejected，从而触发catch方法指定的回调函数。 Promise.resolve()有时需要将现有对象转为Promise对象，Promise.resolve方法就起到这个作用。 var jsPromise = Promise.resolve($.ajax(‘/whatever.json’));上面代码将jQuery生成的deferred对象，转为一个新的Promise对象。 Promise.resolve等价于下面的写法。 Promise.resolve(‘foo’)// 等价于new Promise(resolve =&gt; resolve(‘foo’))Promise.resolve方法的参数分成四种情况。 （1）参数是一个Promise实例 如果参数是Promise实例，那么Promise.resolve将不做任何修改、原封不动地返回这个实例。 （2）参数是一个thenable对象 thenable对象指的是具有then方法的对象，比如下面这个对象。 let thenable = { then: function(resolve, reject) { resolve(42); } }; Promise.resolve方法会将这个对象转为Promise对象，然后就立即执行thenable对象的then方法。 let thenable = { then: function(resolve, reject) { resolve(42); } }; let p1 = Promise.resolve(thenable); p1.then(function(value) { console.log(value); // 42 }); 上面代码中，thenable对象的then方法执行后，对象p1的状态就变为resolved，从而立即执行最后那个then方法指定的回调函数，输出42。 （3）参数不是具有then方法的对象，或根本就不是对象 如果参数是一个原始值，或者是一个不具有then方法的对象，则Promise.resolve方法返回一个新的Promise对象，状态为Resolved。 var p = Promise.resolve(&apos;Hello&apos;); p.then(function (s){ console.log(s) }); // Hello 上面代码生成一个新的Promise对象的实例p。由于字符串Hello不属于异步操作（判断方法是字符串对象不具有then方法），返回Promise实例的状态从一生成就是Resolved，所以回调函数会立即执行。Promise.resolve方法的参数，会同时传给回调函数。 （4）不带有任何参数 Promise.resolve方法允许调用时不带参数，直接返回一个Resolved状态的Promise对象。 所以，如果希望得到一个Promise对象，比较方便的方法就是直接调用Promise.resolve方法。 var p = Promise.resolve(); p.then(function () { // ... }); 上面代码的变量p就是一个Promise对象。 需要注意的是，立即resolve的Promise对象，是在本轮“事件循环”（event loop）的结束时，而不是在下一轮“事件循环”的开始时。 setTimeout(function () { console.log(&apos;three&apos;); }, 0); Promise.resolve().then(function () { console.log(&apos;two&apos;); }); console.log(&apos;one&apos;); // one // two // three 上面代码中，setTimeout(fn, 0)在下一轮“事件循环”开始时执行，Promise.resolve()在本轮“事件循环”结束时执行，console.log(‘one’)则是立即执行，因此最先输出。 Promise.reject()Promise.reject(reason)方法也会返回一个新的 Promise 实例，该实例的状态为rejected。 var p = Promise.reject(&apos;出错了&apos;); // 等同于 var p = new Promise((resolve, reject) =&gt; reject(&apos;出错了&apos;)) p.then(null, function (s) { console.log(s) }); // 出错了上面代码生成一个Promise对象的实例p，状态为rejected，回调函数会立即执行。 注意，Promise.reject()方法的参数，会原封不动地作为reject的理由，变成后续方法的参数。这一点与Promise.resolve方法不一致。 const thenable = { then(resolve, reject) { reject(&apos;出错了&apos;); } }; Promise.reject(thenable) .catch(e =&gt; { console.log(e === thenable) }) // true 上面代码中，Promise.reject方法的参数是一个thenable对象，执行以后，后面catch方法的参数不是reject抛出的“出错了”这个字符串，而是thenable对象。 两个有用的附加方法ES6的Promise API提供的方法不是很多，有些有用的方法可以自己部署。下面介绍如何部署两个不在ES6之中、但很有用的方法。 done()Promise对象的回调链，不管以then方法或catch方法结尾，要是最后一个方法抛出错误，都有可能无法捕捉到（因为Promise内部的错误不会冒泡到全局）。因此，我们可以提供一个done方法，总是处于回调链的尾端，保证抛出任何可能出现的错误。 asyncFunc() .then(f1) .catch(r1) .then(f2) .done(); 它的实现代码相当简单。 Promise.prototype.done = function (onFulfilled, onRejected) { this.then(onFulfilled, onRejected) .catch(function (reason) { // 抛出一个全局错误 setTimeout(() =&gt; { throw reason }, 0); }); }; 从上面代码可见，done方法的使用，可以像then方法那样用，提供Fulfilled和Rejected状态的回调函数，也可以不提供任何参数。但不管怎样，done都会捕捉到任何可能出现的错误，并向全局抛出。 finally()finally方法用于指定不管Promise对象最后状态如何，都会执行的操作。它与done方法的最大区别，它接受一个普通的回调函数作为参数，该函数不管怎样都必须执行。 下面是一个例子，服务器使用Promise处理请求，然后使用finally方法关掉服务器。 server.listen(0) .then(function () { // run test }) .finally(server.stop); 它的实现也很简单。 Promise.prototype.finally = function (callback) { let P = this.constructor; return this.then( value =&gt; P.resolve(callback()).then(() =&gt; value), reason =&gt; P.resolve(callback()).then(() =&gt; { throw reason }) ); }; 上面代码中，不管前面的Promise是fulfilled还是rejected，都会执行回调函数callback。]]></content>
      <tags>
        <tag>promise</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[promise的用法深入2]]></title>
    <url>%2F2017%2F02%2F08%2Fpromise%E7%9A%84%E7%94%A8%E6%B3%95%E6%B7%B1%E5%85%A52%2F</url>
    <content type="text"><![CDATA[Promise.prototype.then()Promise 实例具有then方法，也就是说，then方法是定义在原型对象Promise.prototype上的。它的作用是为 Promise 实例添加状态改变时的回调函数。前面说过，then方法的第一个参数是Resolved状态的回调函数，第二个参数（可选）是Rejected状态的回调函数。 then方法返回的是一个新的Promise实例（注意，不是原来那个Promise实例）。因此可以采用链式写法，即then方法后面再调用另一个then方法。 getJSON(&quot;/posts.json&quot;).then(function(json) { return json.post; }).then(function(post) { // ... }); 上面的代码使用then方法，依次指定了两个回调函数。第一个回调函数完成以后，会将返回结果作为参数，传入第二个回调函数。 采用链式的then，可以指定一组按照次序调用的回调函数。这时，前一个回调函数，有可能返回的还是一个Promise对象（即有异步操作），这时后一个回调函数，就会等待该Promise对象的状态发生变化，才会被调用。 getJSON(&quot;/post/1.json&quot;).then(function(post) { return getJSON(post.commentURL); }).then(function funcA(comments) { console.log(&quot;Resolved: &quot;, comments); }, function funcB(err){ console.log(&quot;Rejected: &quot;, err); }); 上面代码中，第一个then方法指定的回调函数，返回的是另一个Promise对象。这时，第二个then方法指定的回调函数，就会等待这个新的Promise对象状态发生变化。如果变为Resolved，就调用funcA，如果状态变为Rejected，就调用funcB。 如果采用箭头函数，上面的代码可以写得更简洁。 getJSON(&quot;/post/1.json&quot;).then( post =&gt; getJSON(post.commentURL) ).then( comments =&gt; console.log(&quot;Resolved: &quot;, comments), err =&gt; console.log(&quot;Rejected: &quot;, err) ); # Promise.prototype.catch() Promise.prototype.catch方法是.then(null, rejection)的别名，用于指定发生错误时的回调函数。 getJSON(&apos;/posts.json&apos;).then(function(posts) { // ... }).catch(function(error) { // 处理 getJSON 和 前一个回调函数运行时发生的错误 console.log(&apos;发生错误！&apos;, error); }); 上面代码中，getJSON方法返回一个 Promise 对象，如果该对象状态变为Resolved，则会调用then方法指定的回调函数；如果异步操作抛出错误，状态就会变为Rejected，就会调用catch方法指定的回调函数，处理这个错误。另外，then方法指定的回调函数，如果运行中抛出错误，也会被catch方法捕获。 p.then((val) =&gt; console.log(&apos;fulfilled:&apos;, val)) .catch((err) =&gt; console.log(&apos;rejected&apos;, err)); // 等同于 p.then((val) =&gt; console.log(&apos;fulfilled:&apos;, val)) .then(null, (err) =&gt; console.log(&quot;rejected:&quot;, err)); 下面是一个例子。 var promise = new Promise(function(resolve, reject) { throw new Error(&apos;test&apos;); }); promise.catch(function(error) { console.log(error); }); // Error: test 上面代码中，promise抛出一个错误，就被catch方法指定的回调函数捕获。注意，上面的写法与下面两种写法是等价的。 // 写法一 var promise = new Promise(function(resolve, reject) { try { throw new Error(&apos;test&apos;); } catch(e) { reject(e); } }); promise.catch(function(error) { console.log(error); }); // 写法二 var promise = new Promise(function(resolve, reject) { reject(new Error(&apos;test&apos;)); }); promise.catch(function(error) { console.log(error); }); 比较上面两种写法，可以发现reject方法的作用，等同于抛出错误。 如果Promise状态已经变成Resolved，再抛出错误是无效的。 var promise = new Promise(function(resolve, reject) { resolve(&apos;ok&apos;); throw new Error(&apos;test&apos;); }); promise .then(function(value) { console.log(value) }) .catch(function(error) { console.log(error) }); // ok 上面代码中，Promise 在resolve语句后面，再抛出错误，不会被捕获，等于没有抛出。因为 Promise 的状态一旦改变，就永久保持该状态，不会再变了。 Promise 对象的错误具有“冒泡”性质，会一直向后传递，直到被捕获为止。也就是说，错误总是会被下一个catch语句捕获。 getJSON(&apos;/post/1.json&apos;).then(function(post) { return getJSON(post.commentURL); }).then(function(comments) { // some code }).catch(function(error) { // 处理前面三个Promise产生的错误 }); 上面代码中，一共有三个Promise对象：一个由getJSON产生，两个由then产生。它们之中任何一个抛出的错误，都会被最后一个catch捕获。 一般来说，不要在then方法里面定义Reject状态的回调函数（即then的第二个参数），总是使用catch方法。 // bad promise .then(function(data) { // success }, function(err) { // error }); // good promise .then(function(data) { //cb // success }) .catch(function(err) { // error }); 上面代码中，第二种写法要好于第一种写法，理由是第二种写法可以捕获前面then方法执行中的错误，也更接近同步的写法（try/catch）。因此，建议总是使用catch方法，而不使用then方法的第二个参数。 跟传统的try/catch代码块不同的是，如果没有使用catch方法指定错误处理的回调函数，Promise对象抛出的错误不会传递到外层代码，即不会有任何反应。 var someAsyncThing = function() { return new Promise(function(resolve, reject) { // 下面一行会报错，因为x没有声明 resolve(x + 2); }); }; someAsyncThing().then(function() { console.log(&apos;everything is great&apos;); }); 上面代码中，someAsyncThing函数产生的 Promise 对象会报错，但是由于没有指定catch方法，这个错误不会被捕获，也不会传递到外层代码。正常情况下，运行后不会有任何输出，但是浏览器此时会打印出错误“ReferenceError: x is not defined”，不过不会终止脚本执行，如果这个脚本放在服务器执行，退出码就是0（即表示执行成功）。 var promise = new Promise(function (resolve, reject) { resolve(‘ok’); setTimeout(function () { throw new Error(‘test’) }, 0)});promise.then(function (value) { console.log(value) });// ok// Uncaught Error: test上面代码中，Promise 指定在下一轮“事件循环”再抛出错误。到了那个时候，Promise 的运行已经结束了，所以这个错误是在 Promise 函数体外抛出的，会冒泡到最外层，成了未捕获的错误。 Node 有一个unhandledRejection事件，专门监听未捕获的reject错误。 process.on(&apos;unhandledRejection&apos;, function (err, p) { console.error(err.stack) }); 上面代码中，unhandledRejection事件的监听函数有两个参数，第一个是错误对象，第二个是报错的 Promise 实例，它可以用来了解发生错误的环境信息。。 需要注意的是，catch方法返回的还是一个 Promise 对象，因此后面还可以接着调用then方法。 var someAsyncThing = function() { return new Promise(function(resolve, reject) { // 下面一行会报错，因为x没有声明 resolve(x + 2); }); }; someAsyncThing() .catch(function(error) { console.log(&apos;oh no&apos;, error); }) .then(function() { console.log(&apos;carry on&apos;); }); // oh no [ReferenceError: x is not defined] // carry on 上面代码运行完catch方法指定的回调函数，会接着运行后面那个then方法指定的回调函数。如果没有报错，则会跳过catch方法。 Promise.resolve() .catch(function(error) { console.log(&apos;oh no&apos;, error); }) .then(function() { console.log(&apos;carry on&apos;); }); // carry on 上面的代码因为没有报错，跳过了catch方法，直接执行后面的then方法。此时，要是then方法里面报错，就与前面的catch无关了。 catch方法之中，还能再抛出错误。 var someAsyncThing = function() { return new Promise(function(resolve, reject) { // 下面一行会报错，因为x没有声明 resolve(x + 2); }); }; someAsyncThing().then(function() { return someOtherAsyncThing(); }).catch(function(error) { console.log(&apos;oh no&apos;, error); // 下面一行会报错，因为y没有声明 y + 2; }).then(function() { console.log(&apos;carry on&apos;); }); // oh no [ReferenceError: x is not defined]上面代码中，catch方法抛出一个错误，因为后面没有别的catch方法了，导致这个错误不会被捕获，也不会传递到外层。如果改写一下，结果就不一样了。 someAsyncThing().then(function() { return someOtherAsyncThing(); }).catch(function(error) { console.log(&apos;oh no&apos;, error); // 下面一行会报错，因为y没有声明 y + 2; }).catch(function(error) { console.log(&apos;carry on&apos;, error); }); // oh no [ReferenceError: x is not defined] // carry on [ReferenceError: y is not defined] 上面代码中，第二个catch方法用来捕获，前一个catch方法抛出的错误。]]></content>
      <tags>
        <tag>promise</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[promise的用法深入1]]></title>
    <url>%2F2017%2F02%2F04%2Fpromise%E7%9A%84%E7%94%A8%E6%B3%95%E6%B7%B1%E5%85%A51%2F</url>
    <content type="text"><![CDATA[Promise 的含义 Promise 是异步编程的一种解决方案，比传统的解决方案——回调函数和事件——更合理和更强大。它由社区最早提出和实现，ES6将其写进了语言标准，统一了用法，原生提供了Promise对象。 所谓Promise，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。从语法上说，Promise 是一个对象，从它可以获取异步操作的消息。Promise 提供统一的 API，各种异步操作都可以用同样的方法进行处理。 Promise对象有以下两个特点。 （1）对象的状态不受外界影响。Promise对象代表一个异步操作，有三种状态：Pending（进行中）、Resolved（已完成，又称 Fulfilled）和Rejected（已失败）。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。这也是Promise这个名字的由来，它的英语意思就是“承诺”，表示其他手段无法改变。 （2）一旦状态改变，就不会再变，任何时候都可以得到这个结果。Promise对象的状态改变，只有两种可能：从Pending变为Resolved和从Pending变为Rejected。只要这两种情况发生，状态就凝固了，不会再变了，会一直保持这个结果。如果改变已经发生了，你再对Promise对象添加回调函数，也会立即得到这个结果。这与事件（Event）完全不同，事件的特点是，如果你错过了它，再去监听，是得不到结果的。 有了Promise对象，就可以将异步操作以同步操作的流程表达出来，避免了层层嵌套的回调函数。此外，Promise对象提供统一的接口，使得控制异步操作更加容易。 Promise也有一些缺点。首先，无法取消Promise，一旦新建它就会立即执行，无法中途取消。其次，如果不设置回调函数，Promise内部抛出的错误，不会反应到外部。第三，当处于Pending状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）。 如果某些事件不断地反复发生，一般来说，使用 Stream 模式是比部署Promise更好的选择。来自阮一峰的es6 基本示例 ES6 规定，Promise对象是一个构造函数，用来生成Promise实例。 下面代码创造了一个Promise实例。 var promise = new Promise(function(resolve, reject) { // ... some code if (/* 异步操作成功 */){ resolve(value); } else { reject(error); } }); Promise构造函数接受一个函数作为参数，该函数的两个参数分别是resolve和reject。它们是两个函数，由 JavaScript 引擎提供，不用自己部署。 resolve函数的作用是，将Promise对象的状态从“未完成”变为“成功”（即从 Pending 变为 Resolved），在异步操作成功时调用，并将异步操作的结果，作为参数传递出去；reject函数的作用是，将Promise对象的状态从“未完成”变为“失败”（即从 Pending 变为 Rejected），在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去。 Promise实例生成以后，可以用then方法分别指定Resolved状态和Reject状态的回调函数。 promise.then(function(value) { // success }, function(error) { // failure }); then方法可以接受两个回调函数作为参数。第一个回调函数是Promise对象的状态变为Resolved时调用，第二个回调函数是Promise对象的状态变为Rejected时调用。其中，第二个函数是可选的，不一定要提供。这两个函数都接受Promise对象传出的值作为参数。 下面是一个Promise对象的简单例子。 function timeout(ms) { return new Promise((resolve, reject) =&gt; { setTimeout(resolve, ms, &apos;done&apos;); }); } timeout(100).then((value) =&gt; { console.log(value); }); 上面代码中，timeout方法返回一个Promise实例，表示一段时间以后才会发生的结果。过了指定的时间（ms参数）以后，Promise实例的状态变为Resolved，就会触发then方法绑定的回调函数。 Promise 新建后就会立即执行。 let promise = new Promise(function(resolve, reject) { console.log(&apos;Promise&apos;); resolve(); }); promise.then(function() { console.log(&apos;Resolved.&apos;); }); console.log(&apos;Hi!&apos;); // Promise // Hi! // Resolved 上面代码中，Promise 新建后立即执行，所以首先输出的是Promise。然后，then方法指定的回调函数，将在当前脚本所有同步任务执行完才会执行，所以Resolved最后输出。 下面是异步加载图片的例子。 function loadImageAsync(url) { return new Promise(function(resolve, reject) { var image = new Image(); image.onload = function() { resolve(image); }; image.onerror = function() { reject(new Error(&apos;Could not load image at &apos; + url)); }; image.src = url; }); } 上面代码中，使用Promise包装了一个图片加载的异步操作。如果加载成功，就调用resolve方法，否则就调用reject方法。 下面是一个用Promise对象实现的 Ajax 操作的例子。 var getJSON = function(url) { var promise = new Promise(function(resolve, reject){ var client = new XMLHttpRequest(); client.open(&quot;GET&quot;, url); client.onreadystatechange = handler; client.responseType = &quot;json&quot;; client.setRequestHeader(&quot;Accept&quot;, &quot;application/json&quot;); client.send(); function handler() { if (this.readyState !== 4) { return; } if (this.status === 200) { resolve(this.response); } else { reject(new Error(this.statusText)); } }; }); return promise; }; getJSON(&quot;/posts.json&quot;).then(function(json) { console.log(&apos;Contents: &apos; + json); }, function(error) { console.error(&apos;出错了&apos;, error); }); 上面代码中，getJSON是对 XMLHttpRequest 对象的封装，用于发出一个针对 JSON 数据的 HTTP 请求，并且返回一个Promise对象。需要注意的是，在getJSON内部，resolve函数和reject函数调用时，都带有参数。 如果调用resolve函数和reject函数时带有参数，那么它们的参数会被传递给回调函数。reject函数的参数通常是Error对象的实例，表示抛出的错误；resolve函数的参数除了正常的值以外，还可能是另一个 Promise 实例，表示异步操作的结果有可能是一个值，也有可能是另一个异步操作，比如像下面这样。 var p1 = new Promise(function (resolve, reject) { // ... }); var p2 = new Promise(function (resolve, reject) { // ... resolve(p1); }) 上面代码中，p1和p2都是Promise的实例，但是p2的resolve方法将p1作为参数，即一个异步操作的结果是返回另一个异步操作。 注意，这时p1的状态就会传递给p2，也就是说，p1的状态决定了p2的状态。如果p1的状态是Pending，那么p2的回调函数就会等待p1的状态改变；如果p1的状态已经是Resolved或者Rejected，那么p2的回调函数将会立刻执行。 var p1 = new Promise(function (resolve, reject) { setTimeout(() =&gt; reject(new Error(&apos;fail&apos;)), 3000) }) var p2 = new Promise(function (resolve, reject) { setTimeout(() =&gt; resolve(p1), 1000) }) p2 .then(result =&gt; console.log(result)) .catch(error =&gt; console.log(error)) // Error: fail 上面代码中，p1是一个Promise，3秒之后变为rejected。p2的状态在1秒之后改变，resolve方法返回的是p1。由于p2返回的是另一个 Promise，导致p2自己的状态无效了，由p1的状态决定p2的状态。所以，后面的then语句都变成针对后者（p1）。又过了2秒，p1变为rejected，导致触发catch方法指定的回调函数。]]></content>
      <tags>
        <tag>promise</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[es6学习--数组的扩展]]></title>
    <url>%2F2016%2F11%2F10%2Fes6%E5%AD%A6%E4%B9%A0-%E6%95%B0%E7%BB%84%E7%9A%84%E6%89%A9%E5%B1%95%2F</url>
    <content type="text"><![CDATA[Array.from()Array.from方法用于将两类对象转为真正的数组：类似数组的对象（array-like object）和可遍历（iterable）的对象（包括ES6新增的数据结构Set和Map）。 必须具有length属性 123456789101112 let arrayLike = &#123; &apos;0&apos;: &apos;a&apos;, &apos;1&apos;: &apos;b&apos;, &apos;2&apos;: &apos;c&apos;, length: 3&#125;;// ES5的写法var arr1 = [].slice.call(arrayLike); // [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;]// ES6的写法let arr2 = Array.from(arrayLike); // [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;] 常见的类似数组的对象是DOM操作返回的NodeList集合，以及函数内部的arguments对象。Array.from都可以将它们转为真正的数组。 1234567891011// NodeList对象let ps = document.querySelectorAll(&apos;p&apos;);Array.from(ps).forEach(function (p) &#123; console.log(p);&#125;);// arguments对象function foo() &#123; var args = Array.from(arguments); // ...&#125; 只要是部署了Iterator接口的数据结构，Array.from都能将其转为数组。 12345Array.from(&apos;hello&apos;) // [&apos;h&apos;, &apos;e&apos;, &apos;l&apos;, &apos;l&apos;, &apos;o&apos;] let namesSet = new Set([&apos;a&apos;, &apos;b&apos;]) Array.from(namesSet) // [&apos;a&apos;, &apos;b&apos;] 扩展运算符（...）也可以将某些数据结构转为数组。 12345678910// arguments对象function foo() &#123; var args = [...arguments];&#125;// NodeList对象[...document.querySelectorAll(&apos;div&apos;)]Array.from(&#123; length: 3 &#125;);// [ undefined, undefined, undefined ] Array.from还可以接受第二个参数，作用类似于数组的map方法，用来对每个元素进行处理，将处理后的值放入返回的数组。 123456Array.from(arrayLike, x =&gt; x * x);// 等同于Array.from(arrayLike).map(x =&gt; x * x);Array.from([1, 2, 3], (x) =&gt; x * x)// [1, 4, 9] #Array.of() Array.of方法用于将一组值，转换为数组。123Array.of(3, 11, 8) // [3,11,8]Array.of(3) // [3]Array.of(3).length // 1 1234Array.of() // []Array.of(undefined) // [undefined]Array.of(1) // [1]Array.of(1, 2) // [1, 2] Array.of方法可以用下面的代码模拟实现。 123function ArrayOf()&#123; return [].slice.call(arguments);&#125; 数组实例的copyWithin()数组实例的copyWithin方法，在当前数组内部，将指定位置的成员复制到其他位置（会覆盖原有成员），然后返回当前数组。也就是说，使用这个方法，会修改当前数组。 12345Array.prototype.copyWithin(target, start = 0, end = this.length)它接受三个参数。 target（必需）：从该位置开始替换数据。 start（可选）：从该位置开始读取数据，默认为0。如果为负值，表示倒数。 end（可选）：到该位置前停止读取数据，默认等于数组长度。如果为负值，表示倒数。 12[1, 2, 3, 4, 5].copyWithin(0, 3)// [4, 5, 3, 4, 5] 123456789101112131415161718192021// 将3号位复制到0号位[1, 2, 3, 4, 5].copyWithin(0, 3, 4)// [4, 2, 3, 4, 5]// -2相当于3号位，-1相当于4号位[1, 2, 3, 4, 5].copyWithin(0, -2, -1)// [4, 2, 3, 4, 5]// 将3号位复制到0号位[].copyWithin.call(&#123;length: 5, 3: 1&#125;, 0, 3)// &#123;0: 1, 3: 1, length: 5&#125;// 将2号位到数组结束，复制到0号位var i32a = new Int32Array([1, 2, 3, 4, 5]);i32a.copyWithin(0, 2);// Int32Array [3, 4, 5, 4, 5]// 对于没有部署TypedArray的copyWithin方法的平台// 需要采用下面的写法[].copyWithin.call(new Int32Array([1, 2, 3, 4, 5]), 0, 3, 4);// Int32Array [4, 2, 3, 4, 5] 123456789101112131415161718192021// 将3号位复制到0号位[1, 2, 3, 4, 5].copyWithin(0, 3, 4)// [4, 2, 3, 4, 5]// -2相当于3号位，-1相当于4号位[1, 2, 3, 4, 5].copyWithin(0, -2, -1)// [4, 2, 3, 4, 5]// 将3号位复制到0号位[].copyWithin.call(&#123;length: 5, 3: 1&#125;, 0, 3)// &#123;0: 1, 3: 1, length: 5&#125;// 将2号位到数组结束，复制到0号位var i32a = new Int32Array([1, 2, 3, 4, 5]);i32a.copyWithin(0, 2);// Int32Array [3, 4, 5, 4, 5]// 对于没有部署TypedArray的copyWithin方法的平台// 需要采用下面的写法[].copyWithin.call(new Int32Array([1, 2, 3, 4, 5]), 0, 3, 4);// Int32Array [4, 2, 3, 4, 5] 数组实例的find()和findIndex()数组实例的find方法，用于找出第一个符合条件的数组成员。它的参数是一个回调函数，所有数组成员依次执行该回调函数，直到找出第一个返回值为true的成员，然后返回该成员。如果没有符合条件的成员，则返回undefined 1[1, 4, -5, 10].find((n) =&gt; n &lt; 0)//-5 find方法的回调函数可以接受三个参数，依次为当前的值、当前的位置和原数组。 findIndex方法的用法与find方法非常类似返回第一个符合条件的数组成员的位置，如果所有成员都不符合条件，则返回-1。 123[1, 5, 10, 15].findIndex(function(value, index, arr) &#123; return value &gt; 9;&#125;) // 2 12345[NaN].indexOf(NaN)// -1[NaN].findIndex(y =&gt; Object.is(NaN, y))// 0 数组实例的fill()fill方法使用给定值，填充一个数组。 12345[&apos;a&apos;, &apos;b&apos;, &apos;c&apos;].fill(7) // [7, 7, 7] new Array(3).fill(7) // [7, 7, 7] 数组实例的entries()，keys()和values()ES6提供三个新的方法——entries()，keys()和values()——用于遍历数组。它们都返回一个遍历器对象（详见《Iterator》一章），可以用for...of循环进行遍历，唯一的区别是keys()是对键名的遍历、values()是对键值的遍历，entries()是对键值对的遍历。 1234567891011121314151617for (let index of [&apos;a&apos;, &apos;b&apos;].keys()) &#123; console.log(index);&#125;// 0// 1for (let elem of [&apos;a&apos;, &apos;b&apos;].values()) &#123; console.log(elem);&#125;// &apos;a&apos;// &apos;b&apos;for (let [index, elem] of [&apos;a&apos;, &apos;b&apos;].entries()) &#123; console.log(index, elem);&#125;// 0 &quot;a&quot;// 1 &quot;b&quot; 12345let letter = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;];let entries = letter.entries();console.log(entries.next().value); // [0, &apos;a&apos;]console.log(entries.next().value); // [1, &apos;b&apos;]console.log(entries.next().value); // [2, &apos;c&apos;] 数组实例的includes()Array.prototype.includes方法返回一个布尔值，表示某个数组是否包含给定的值，与字符串的includes方法类似。该方法属于ES7，但Babel转码器已经支持。 123[1, 2, 3].includes(2); // true[1, 2, 3].includes(4); // false[1, 2, NaN].includes(NaN); // true indexOf方法有两个缺点，一是不够语义化，它的含义是找到参数值的第一个出现位置，所以要去比较是否不等于-1，表达起来不够直观。二是，它内部使用严格相当运算符（===）进行判断，这会导致对NaN的误判。 数组的空位数组的空位指，数组的某一个位置没有任何值。比如，Array构造函数返回的数组都是空位 1234567891011121314151617181920// forEach方法[,&apos;a&apos;].forEach((x,i) =&gt; console.log(i)); // 1// filter方法[&apos;a&apos;,,&apos;b&apos;].filter(x =&gt; true) // [&apos;a&apos;,&apos;b&apos;]// every方法[,&apos;a&apos;].every(x =&gt; x===&apos;a&apos;) // true// some方法[,&apos;a&apos;].some(x =&gt; x !== &apos;a&apos;) // false// map方法[,&apos;a&apos;].map(x =&gt; 1) // [,1]// join方法[,&apos;a&apos;,undefined,null].join(&apos;#&apos;) // &quot;#a##&quot;// toString方法[,&apos;a&apos;,undefined,null].toString() // &quot;,a,,&quot; 123forEach(), filter(), every() 和some()都会跳过空位。map()会跳过空位，但会保留这个值join()和toString()会将空位视为undefined，而undefined和null会被处理成空字符串。 Array.from方法会将数组的空位，转为undefined，也就是说，这个方法不会忽略空位 12Array.from([&apos;a&apos;,,&apos;b&apos;])// [ &quot;a&quot;, undefined, &quot;b&quot; ] 扩展运算符（...）也会将空位转为undefined。 12[...[&apos;a&apos;,,&apos;b&apos;]]// [ &quot;a&quot;, undefined, &quot;b&quot; ] copyWithin()会连空位一起拷贝。 1[,&apos;a&apos;,&apos;b&apos;,,].copyWithin(2,0) // [,&quot;a&quot;,,&quot;a&quot;] fill()会将空位视为正常的数组位置。 1new Array(3).fill(&apos;a&apos;) // [&quot;a&quot;,&quot;a&quot;,&quot;a&quot;] for...of循环也会遍历空位。 123456let arr = [, ,];for (let i of arr) &#123; console.log(1);&#125;// 1// 1 entries()、keys()、values()、find()和findIndex()会将空位处理成undefined。 1234567891011121314// entries()[...[,&apos;a&apos;].entries()] // [[0,undefined], [1,&quot;a&quot;]]// keys()[...[,&apos;a&apos;].keys()] // [0,1]// values()[...[,&apos;a&apos;].values()] // [undefined,&quot;a&quot;]// find()[,&apos;a&apos;].find(x =&gt; true) // undefined// findIndex()[,&apos;a&apos;].findIndex(x =&gt; true) // 0]]></content>
      <tags>
        <tag>es6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[es6学习--字符串的扩展]]></title>
    <url>%2F2016%2F11%2F10%2Fes6%E5%AD%A6%E4%B9%A0-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%89%A9%E5%B1%95%2F</url>
    <content type="text"><![CDATA[数组的解构赋值ES6 允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构（Destructuring）。 这种写法属于“模式匹配”，只要等号两边的模式相同，左边的变量就会被赋予对应的值 1234es5写法let a = 1;let b = 2;let c = 3; 12345678910111213141516171819202122es6写法let [a, b, c] = [1, 2, 3];let [foo, [[bar], baz]] = [1, [[2], 3]];foo // 1bar // 2baz // 3let [ , , third] = ["foo", "bar", "baz"];third // "baz"let [x, , y] = [1, 2, 3];x // 1y // 3let [head, ...tail] = [1, 2, 3, 4];head // 1tail // [2, 3, 4]let [x, y, ...z] = ['a'];x // "a"y // undefined //解构不成功，变量的值就等于undefinedz // [] 不完全解构：即等号左边的模式，只匹配一部分的等号右边的数组 12345678let [x, y] = [1, 2, 3];x // 1y // 2let [a, [b], d] = [1, [2, 3], 4];a // 1b // 2d // 4 解构的大前提在于必须具备 Iterator 接口 默认值:解构赋值允许指定默认值 1234567891011let [foo = true] = [];foo // truelet [x, y = 'b'] = ['a']; // x='a', y='b'let [x, y = 'b'] = ['a', undefined]; // x='a', y='b'//ES6 内部使用严格相等运算符（===），判断一个位置是否有值。所以，如果一个数组成员不严格等于undefined，默认值是不会生效的let [x = 1] = [undefined];x // 1let [x = 1] = [null];x // null 对象的解构赋值对象的解构与数组有一个重要的不同。数组的元素是按次序排列的，变量的取值由它的位置决定；而对象的属性没有次序，变量必须与属性同名，才能取到正确的值 123456789let &#123; foo, bar &#125; = &#123; foo: "aaa", bar: "bbb" &#125;;foo // "aaa"bar // "bbb"let &#123; bar, foo &#125; = &#123; foo: "aaa", bar: "bbb" &#125;;foo // "aaa"bar // "bbb"let &#123; baz &#125; = &#123; foo: "aaa", bar: "bbb" &#125;;baz // undefined 变量名与属性名不一致，必须写成下面这样 1234567891011var &#123; foo: baz &#125; = &#123; foo: 'aaa', bar: 'bbb' &#125;;baz // "aaa"let obj = &#123; first: 'hello', last: 'world' &#125;;let &#123; first: f, last: l &#125; = obj;f // 'hello'l // 'world'let &#123; foo: baz &#125; = &#123; foo: "aaa", bar: "bbb" &#125;;baz // "aaa"foo // error: foo is not defined//foo是匹配的模式，baz才是变量。真正被赋值的是变量baz，而不是模式foo。 采用这种写法时，变量的声明和赋值是一体的。对于let和const来说，变量不能重新声明，所以一旦赋值的变量以前声明过，就会报错。 1234567891011let foo;let &#123;foo&#125; = &#123;foo: 1&#125;; // SyntaxError: Duplicate declaration "foo"let baz;let &#123;bar: baz&#125; = &#123;bar: 1&#125;; // SyntaxError: Duplicate declaration "baz"//let命令下面一行的圆括号是必须的，否则会报错。因为解析器会将起首的大括号，理解成一个代码块，而不是赋值语句。let foo;(&#123;foo&#125; = &#123;foo: 1&#125;); // 成功let baz;(&#123;bar: baz&#125; = &#123;bar: 1&#125;); // 成功 对象的解构也可以指定默认值。对象的属性值严格等于undefined 123456789101112131415var &#123;x = 3&#125; = &#123;&#125;;x // 3var &#123;x, y = 5&#125; = &#123;x: 1&#125;;x // 1y // 5var &#123;x:y = 3&#125; = &#123;&#125;;y // 3var &#123;x:y = 3&#125; = &#123;x: 5&#125;;y // 5var &#123; message: msg = 'Something went wrong' &#125; = &#123;&#125;;msg // "Something went wrong" 可以对现有对象赋值 12let &#123; log, sin, cos &#125; = Math;//Math对象的对数、正弦、余弦三个方法，赋值到对应的变量上，使用起来就会方便很多。 数组本质是特殊的对象，因此可以对数组进行对象属性的解构 1234let arr = [1, 2, 3];let &#123;0 : first, [arr.length - 1] : last&#125; = arr;first // 1last // 3 字符串的解构赋值字符串也可以解构赋值。这是因为此时，字符串被转换成了一个类似数组的对象。 123456 const [a, b, c, d, e] = 'hello';a // "h"b // "e"c // "l"d // "l"e // "o" 类似数组的对象都有一个length属性，因此还可以对这个属性解构赋值。 12 let &#123;length : len&#125; = 'hello';len // 5 数值和布尔值的解构赋值解构赋值时，如果等号右边是数值和布尔值，则会先转为对象 12345let &#123;toString: s&#125; = 123;s === Number.prototype.toString // truelet &#123;toString: s&#125; = true;s === Boolean.prototype.toString // true 只要等号右边的值不是对象或数组，就先将其转为对象。由于undefined和null无法转为对象，所以对它们进行解构赋值，都会报错。 12let &#123; prop: x &#125; = undefined; // TypeErrorlet &#123; prop: y &#125; = null; // TypeError 函数参数的解构赋值函数的参数也可以使用解构赋值 12345678function add([x, y])&#123; return x + y;&#125;add([1, 2]); // 3[[1, 2], [3, 4]].map(([a, b]) =&gt; a + b);// [ 3, 7 ] 函数参数的解构也可以使用默认值 123456789101112131415161718function move(&#123;x = 0, y = 0&#125; = &#123;&#125;) &#123; return [x, y];&#125;move(&#123;x: 3, y: 8&#125;); // [3, 8]move(&#123;x: 3&#125;); // [3, 0]move(&#123;&#125;); // [0, 0]move(); // [0, 0]写法不同，结果不一样function move(&#123;x, y&#125; = &#123; x: 0, y: 0 &#125;) &#123; return [x, y];&#125;move(&#123;x: 3, y: 8&#125;); // [3, 8]move(&#123;x: 3&#125;); // [3, undefined]move(&#123;&#125;); // [undefined, undefined]move(); // [0, 0] 圆括号问题 解构赋值虽然很方便，但是解析起来并不容易。对于编译器来说，一个式子到底是模式，还是表达式，没有办法从一开始就知道，必须解析到（或解析不到）等号才能知道。 由此带来的问题是，如果模式中出现圆括号怎么处理。ES6的规则是，只要有可能导致解构的歧义，就不得使用圆括号。 但是，这条规则实际上不那么容易辨别，处理起来相当麻烦。因此，建议只要有可能，就不要在模式中放置圆括号。 变量声明语句中，不能带有圆括号。 123456789 // 全部报错:因为它们都是变量声明语句，模式不能使用圆括号let [(a)] = [1];let &#123;x: (c)&#125; = &#123;&#125;;let (&#123;x: c&#125;) = &#123;&#125;;let &#123;(x: c)&#125; = &#123;&#125;;let &#123;(x): c&#125; = &#123;&#125;;let &#123; o: (&#123; p: p &#125;) &#125; = &#123; o: &#123; p: 2 &#125; &#125;; 函数参数中，模式不能带有圆括号,函数参数也属于变量声明 12// 报错function f([(z)]) &#123; return z; &#125; 赋值语句中，不能将整个模式，或嵌套模式中的一层，放在圆括号之中。 1234// 全部报错 (&#123; p: a &#125;) = &#123; p: 42 &#125;; ([a]) = [5]; [(&#123; p: a &#125;), &#123; x: c &#125;] = [&#123;&#125;, &#123;&#125;]; 可以使用圆括号的情况 1234[(b)] = [3]; // 正确(&#123; p: (d) &#125; = &#123;&#125;); // 正确[(parseInt.prop)] = [3]; // 正确//上面三行语句都可以正确执行，因为首先它们都是赋值语句，而不是声明语句；其次它们的圆括号都不属于模式的一部分。第一行语句中，模式是取数组的第一个成员，跟圆括号无关；第二行语句中，模式是p，而不是d；第三行语句与第一行语句的性质一致。 用途（1）交换变量的值 1234let x = 1;let y = 2;[x, y] = [y, x]; （2）从函数返回多个值：函数只能返回一个值，如果要返回多个值，只能将它们放在数组或对象里返回。有了解构赋值，取出这些值就非常方便 12345678910111213141516// 返回一个数组function example() &#123; return [1, 2, 3];&#125;let [a, b, c] = example();// 返回一个对象function example() &#123; return &#123; foo: 1, bar: 2 &#125;;&#125;let &#123; foo, bar &#125; = example(); （3）函数参数的定义:解构赋值可以方便地将一组参数与变量名对应起来。 1234567// 参数是一组有次序的值function f([x, y, z]) &#123; ... &#125;f([1, 2, 3]);// 参数是一组无次序的值function f(&#123;x, y, z&#125;) &#123; ... &#125;f(&#123;z: 3, y: 2, x: 1&#125;); （4）提取JSON数据：解构赋值对提取JSON对象中的数据，尤其有用 12345678910let jsonData = &#123; id: 42, status: "OK", data: [867, 5309] &#125;; let &#123; id, status, data: number &#125; = jsonData; console.log(id, status, number); // 42, "OK", [867, 5309] （5）函数参数的默认值 123456789101112jQuery.ajax = function (url, &#123; async = true, beforeSend = function () &#123;&#125;, cache = true, complete = function () &#123;&#125;, crossDomain = false, global = true, // ... more config&#125;) &#123; // ... do stuff&#125;;//指定参数的默认值，就避免了在函数体内部再写var foo = config.foo || 'default foo';这样的语句 （6）遍历Map结构：任何部署了Iterator接口的对象，都可以用for...of循环遍历。Map结构原生支持Iterator接口，配合变量的解构赋值，获取键名和键值就非常方便。 123456789var map = new Map();map.set('first', 'hello');map.set('second', 'world');for (let [key, value] of map) &#123; console.log(key + " is " + value);&#125;// first is hello// second is world]]></content>
      <tags>
        <tag>es6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue2]]></title>
    <url>%2F2016%2F11%2F08%2Fvue2%2F</url>
    <content type="text"><![CDATA[# 条件与循环1234567891011121314&lt;div id="app"&gt; &lt;p v-if="seen"&gt;我是显示的&lt;/p&gt; &lt;p v-else&gt;当条件不满足时我显示&lt;/p&gt;&lt;/div&gt;&lt;script src="https://unpkg.com/vue/dist/vue.js"&gt;&lt;/script&gt;&lt;script&gt; var app = new Vue(&#123; el: '#app', data: &#123; seen: false &#125; &#125;)&lt;/script&gt; v-if v-else 这两个指令 进行条件的判断 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061&lt;div id="app"&gt; &lt;ul&gt; &lt;div v-for="(ingredient,i) in ingredients" :key="i"&gt; &lt;h1&gt;&#123;&#123;ingredient&#125;&#125;&lt;/h1&gt; &lt;p&gt;(&#123;&#123;i&#125;&#125;)&lt;/p&gt; &lt;/div&gt; &lt;/ul&gt; &lt;ul&gt; &lt;li v-for="person in persons"&gt; &lt;span v-for="(value,key,index) in person"&gt; &lt;!-- value 是键值,key是键名，index是下标--&gt; &#123;&#123;key&#125;&#125;: &#123;&#123;value&#125;&#125;--&#123;&#123;index&#125;&#125; &lt;/span&gt; &lt;/li&gt; &lt;/ul&gt; &lt;span v-for="n in 10"&gt;&#123;&#123;n&#125;&#125;,&lt;/span&gt;&lt;/div&gt;&lt;script type="text/javascript" src="vue.js"&gt;&lt;/script&gt;&lt;script type="text/javascript"&gt; new Vue(&#123; el:"#app", data:&#123; ingredients:['meat','fruit','cookies'], persons:[ &#123;name:'vane',age:38,color:'red'&#125;, &#123;name:'rose',age:18,color:'blue'&#125;, &#123;name:'jack',age:28,color:'green'&#125; ] &#125; &#125;)&lt;/script&gt;``` &gt; v-for 进行循环判断 ``` javascript &lt;div id="app"&gt; &lt;p&gt;&#123;&#123;value&#125;&#125;&lt;/p&gt; &lt;button v-on:click="reserve"&gt;翻转字符串&lt;/button&gt; &lt;/div&gt; &lt;script src="vue.js"&gt;&lt;/script&gt; &lt;script&gt; var app = new Vue(&#123; el: '#app', data: &#123; value: 'Ｉ ＬＯＶＥ ＹＯＵ', &#125;, methods: &#123; reserve() &#123; this.value = this.value.split('').reverse().join(''); &#125; &#125; &#125;) &lt;/script&gt; v-on 指令绑定一个事件监听器，通过它调用我们 Vue 实例中定义的方法 表单的指令1234567891011121314&lt;div id="app"&gt; &lt;p&gt;&#123;&#123;value&#125;&#125;&lt;/p&gt; &lt;input v-model="value" /&gt;&lt;/div&gt;&lt;script src="vue.js"&gt;&lt;/script&gt;&lt;script&gt; var app = new Vue(&#123; el: '#app', data: &#123; value: '家具', &#125; &#125;)&lt;/script&gt; v-model 指令，它能轻松实现表单输入和应用状态之间的双向绑定 组件化应用构建 组件系统是 Vue 的另一个重要概念，因为它是一种抽象，允许我们使用小型、自包含和通常可复用的组件构建大型应用。仔细想想，几乎任意类型的应用界面都可以抽象为一个组件树 123456789101112131415161718192021222324252627&lt;div id="app"&gt; &lt;ul&gt; &lt;todolist v-for="item in list" v-bind:todo="item"&gt;&lt;/todolist&gt; &lt;/ul&gt; &lt;/div&gt; &lt;script src="vue.js"&gt;&lt;/script&gt; &lt;script&gt; Vue.component('todolist', &#123; props: ['todo'], template: '&lt;li&gt;&#123;&#123;todo.text&#125;&#125;&lt;/li&gt;' &#125;) var app = new Vue(&#123; el: '#app', data: &#123; value: '家具', list: [&#123; text: '吃饭' &#125;, &#123; text: '睡觉' &#125;, &#123; text: '吃饭' &#125;, &#123; text: '睡觉' &#125;] &#125; &#125;) &lt;/script&gt;]]></content>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[模板语法]]></title>
    <url>%2F2016%2F11%2F08%2F%E6%A8%A1%E6%9D%BF%E8%AF%AD%E6%B3%95%2F</url>
    <content type="text"><![CDATA[# 模板语法&gt; Vue.js 使用了基于 HTML 的模版语法，允许开发者声明式地将 DOM 绑定至底层 Vue 实例的数据。所有 Vue.js 的模板都是合法的 HTML ，所以能被遵循规范的浏览器和 HTML 解析器解析。在底层的实现上， Vue 将模板编译成虚拟 DOM 渲染函数。结合响应系统，在应用状态改变时， Vue 能够智能地计算出重新渲染组件的最小代价并应用到 DOM 操作上# 插值&gt;文本 Mustache 标签将会被替代为对应数据对象上 msg 属性的值。无论何时，绑定的数据对象上 msg 属性发生了改变，插值处的内容都会更新。1&lt;span&gt; Message: &#123;&#123; msg &#125;&#125;&lt;/span&gt; v-once 指令，你也能执行一次性地插值，当数据改变时，插值处的内容不会更新。但请留心这会影响到该节点上所有的数据绑定：1&lt;span v-once&gt;This will never change: &#123;&#123; msg &#125;&#125;&lt;/span&gt; 纯 HTML 双大括号会将数据解释为纯文本，而非 HTML 。为了输出真正的 HTML ，你需要使用 v-html 指令： 12345678910111213141516&lt;div id="app"&gt; &lt;p v-html="finishedLink"&gt;&lt;/p&gt; &lt;p v-html="list"&gt; &lt;/p&gt; &lt;/div&gt; &lt;script src="vue.js"&gt;&lt;/script&gt; &lt;script&gt; var app = new Vue(&#123; el: '#app', data: &#123; value: '家具', list: "&lt;a href='www.baidu.com'&gt;&lt;/a&gt;", finishedLink: '你好，vue。&lt;a href="http://www.baidu.com"&gt;baidu&lt;/a&gt;，怎么想想呢?' &#125; &#125;) &lt;/script&gt; 属性 Mustache 不能在 HTML 属性中使用，应使用 v-bind 指令：1&lt;div v-bind:id="dynamicId"&gt;&lt;/div&gt; 使用 JavaScript 表达式 模板表达式都被放在沙盒中，只能访问全局变量的一个白名单，如 Math 和 Date 。你不应该在模板表达式中试图访问用户定义的全局变量。1234&#123;&#123; number + 1 &#125;&#125;&#123;&#123; ok ? 'YES' : 'NO' &#125;&#125;&#123;&#123; message.split('').reverse().join('') &#125;&#125;&lt;div v-bind:id="'list-' + id"&gt;&lt;/div&gt; 指令 指令（Directives）是带有 v- 前缀的特殊属性。指令属性的值预期是单一 JavaScript 表达式（除了 v-for，之后再讨论）。指令的职责就是当其表达式的值改变时相应地将某些行为应用到 DOM 上。 123&lt;p v-if="seen"&gt;Now you see me&lt;/p&gt;v-if 指令将根据表达式 seen 的值的真假来移除/插入 &lt;p&gt; 元素 参数 一些指令能接受一个“参数”，在指令后以冒号指明。例如， v-bind 指令被用来响应地更新 HTML 属性 1234567&lt;a v-bind:href="url"&gt;&lt;/a&gt;href 是参数，告知 v-bind 指令将该元素的 href 属性与表达式 url 的值绑定。&lt;a v-on:click="doSomething"&gt;v-on 指令，它用于监听 DOM 事件 修饰符 （Modifiers）是以半角句号 . 指明的特殊后缀，用于指出一个指令应该以特殊方式绑定。例如，.prevent 修饰符告诉 v-on 指令对于触发的事件调用 event.preventDefault()：1&lt;form v-on:submit.prevent="onSubmit"&gt;&lt;/form&gt; 过滤器 Vue.js 允许你自定义过滤器，可被用作一些常见的文本格式化。过滤器可以用在两个地方：mustache 插值和 v-bind 表达式。过滤器应该被添加在 JavaScript 表达式的尾部，由“管道”符指示： 1234&lt;!-- in mustaches --&gt;&#123;&#123; message | capitalize &#125;&#125;&lt;!-- in v-bind --&gt;&lt;div v-bind:id="rawId | formatId"&gt;&lt;/div&gt; 自定义过滤器 类似于自定义指令，可以用全局方法 Vue.filter() 注册一个自定义过滤器，它接收两个参数：过滤器 ID 和过滤器函数。过滤器函数以值为参数，返回转换后的值12345678910111213141516171819202122&lt;div id="app"&gt; &lt;ul&gt; &lt;li v-for="item in list"&gt; &#123;&#123;item | vuefilter&#125;&#125; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;script src="vue.js"&gt;&lt;/script&gt; &lt;script&gt; Vue.filter('vuefilter', function(value) &#123; return value &gt; 4; &#125;) var app = new Vue(&#123; el: '#app', data: &#123; value: '家具', list: ['6', '5', '4'], finishedLink: '你好，vue。&lt;a href="http://www.baidu.com"&gt;baidu&lt;/a&gt;，怎么想想呢?' &#125; &#125;) &lt;/script&gt; 缩写 v- 前缀在模板中是作为一个标示 Vue 特殊属性的明显标识。当你使用 Vue.js 为现有的标记添加动态行为时，它会很有用，但对于一些经常使用的指令来说有点繁琐。同时，当搭建 Vue.js 管理所有模板的 SPA 时，v- 前缀也变得没那么重要了。因此，Vue.js 为两个最为常用的指令提供了特别的缩写： v-bind 缩写1234&lt;!-- 完整语法 --&gt;&lt;a v-bind:href="url"&gt;&lt;/a&gt;&lt;!-- 缩写 --&gt;&lt;a :href="url"&gt;&lt;/a&gt; v-on 缩写1234&lt;!-- 完整语法 --&gt;&lt;a v-on:click="doSomething"&gt;&lt;/a&gt;&lt;!-- 缩写 --&gt;&lt;a @click="doSomething"&gt;&lt;/a&gt;]]></content>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue实例]]></title>
    <url>%2F2016%2F11%2F03%2Fvue%E5%AE%9E%E4%BE%8B%2F</url>
    <content type="text"><![CDATA[# vue实例# 构造器&gt; 每个 Vue.js 应用都是通过构造函数 Vue 创建一个 Vue 的根实例 启动的123var vm = new Vue(&#123;// 选项&#125;) 扩展 Vue 构造器，从而用预定义选项创建可复用的组件构造器 12345var MyComponent = Vue.extend(&#123;// 扩展选项&#125;)// 所有的 `MyComponent` 实例都将以预定义的扩展选项被创建var myComponentInstance = new MyComponent() 属性与方法 data 属性 1234567891011var data = &#123; a: 1 &#125;var vm = new Vue(&#123;data: data&#125;)vm.a === data.a // -&gt; true// 设置属性也会影响到原始数据vm.a = 2data.a // -&gt; 2// ... 反之亦然data.a = 3vm.a // -&gt; 3 Vue 实例暴露了一些有用的实例属性与方法。这些属性与方法都有前缀 $，以便与代理的 data 属性区分 1234567891011var data = &#123; a: 1 &#125;var vm = new Vue(&#123;el: '#example',data: data&#125;)vm.$data === data // -&gt; truevm.$el === document.getElementById('example') // -&gt; true// $watch 是一个实例方法vm.$watch('a', function (newVal, oldVal) &#123;// 这个回调将在 `vm.a` 改变后调用&#125;) 注意，不要在实例属性或者回调函数中（如 vm.$watch(‘a’, newVal =&gt; this.myMethod())）使用箭头函数。因为箭头函数绑定父上下文，所以 this 不会像预想的一样是 Vue 实例，而是 this.myMethod 未被定义。 实例生命周期12345678910var vm = new Vue(&#123;data: &#123; a: 1&#125;,created: function () &#123; // `this` 指向 vm 实例 console.log('a is: ' + this.a)&#125;&#125;)// -&gt; "a is: 1" 原文:]]></content>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[es6学习-let和const命令]]></title>
    <url>%2F2016%2F10%2F28%2Fes6%E5%AD%A6%E4%B9%A0-let%E5%92%8Cconst%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[前言：做的学习笔记，参考的是http://es6.ruanyifeng.com/#docs/intro，里面的博客 let和const命令let:它所声明的变量，只在本代码块内有效 123for (let i = 0; i &lt; 10; i++) &#123;&#125; console.log(i); //ReferenceError: i is not define for循环还有一个特别之处，就是循环语句部分是一个父作用域，而循环体内部是一个单独的子作用域 1234567for (let i = 0; i &lt; 3; i++) &#123; let i = 'abc'; console.log(i); &#125; // abc // abc // abc 不存在变量提升 let 它所声明的变量一定要在声明后使用，否则报错。 1234567// var 的情况 console.log(foo); // 输出undefined var foo = 2; // let 的情况 console.log(bar); // 报错ReferenceError let bar = 2; 暂时性死区（temporal dead zone，简称 TDZ）：只要块级作用域内存在let命令，它所声明的变量就“绑定”（binding）这个区域，不再受外部的影响，对于typeof来说不再是安全的操作了 12345678var tmp = 123; if (true) &#123; tmp = 'abc'; // ReferenceError let tmp; &#125; typeof x; // ReferenceErrorlet x; 不允许重复声明 1234567891011// 报错 function () &#123; let a = 10; var a = 1; &#125; // 报错 function () &#123; let a = 10; let a = 1; &#125; const 命令const声明一个只读的常量。一旦声明，常量的值就不能改变。 12345const PI = 3.1415;PI // 3.1415PI = 3;// TypeError: Assignment to constant variable. const的作用域与let命令相同：只在声明所在的块级作用域内有效。 12345if (true) &#123; const MAX = 5;&#125;MAX // Uncaught ReferenceError: MAX is not defined const命令声明的常量也是不提升，同样存在暂时性死区，只能在声明的位置后面使用。 1234if (true) &#123; console.log(MAX); // ReferenceError const MAX = 5;&#125; 本质：实际上保证的，并不是变量的值不得改动，而是变量指向的那个内存地址不得改动。对于简单类型的数据（数值、字符串、布尔值），值就保存在变量指向的那个内存地址，因此等同于常量。但对于复合类型的数据（主要是对象和数组），变量指向的内存地址，保存的只是一个指针，const只能保证这个指针是固定的，至于它指向的数据结构是不是可变的，就完全不能控制了。因此，将一个对象声明为常量必须非常小心。 12345678const foo = &#123;&#125;;// 为 foo 添加一个属性，可以成功foo.prop = 123;foo.prop // 123// 将 foo 指向另一个对象，就会报错foo = &#123;&#125;; // TypeError: "foo" is read-only 1234const a = [];a.push('Hello'); // 可执行a.length = 0; // 可执行a = ['Dave']; // 报错 如果真的想将对象冻结，应该使用Object.freeze方法。 const foo = Object.freeze({}); // 常规模式时，下面一行不起作用；// 严格模式时，该行会报错foo.prop = 123; ES6 声明变量的六种方法ES5 只有两种声明变量的方法：var命令和function命令。ES6除了添加let和const命令，后面章节还会提到，另外两种声明变量的方法：import命令和class命令。所以，ES6 一共有6种声明变量的方法。 顶层对象请参考博客吧]]></content>
      <tags>
        <tag>es6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AngularJS学习2]]></title>
    <url>%2F2016%2F10%2F23%2FAngularJS%E5%AD%A6%E4%B9%A02%2F</url>
    <content type="text"><![CDATA[AngularJS ng-model 指令ng-model 指令用于绑定应用程序数据到 HTML 控制器(input, select, textarea)的值。 12345678910&lt;div ng-app="myApp" ng-controller="myCtrl"&gt; 名字: &lt;input ng-model="name"&gt;&lt;/div&gt;&lt;script&gt;var app = angular.module('myApp', []);app.controller('myCtrl', function($scope) &#123; $scope.name = "ly";&#125;);&lt;/script&gt; 可以实现双重绑定 验证用户输入12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body ng-app="form"&gt; &lt;h2&gt;表单验证&lt;/h2&gt; &lt;form ng-controller='validateCtrl' name="myfrom"&gt; &lt;p&gt;用户名&lt;br /&gt; &lt;input type="text" ng-model="user" name="user" required=""/&gt; &lt;span style="color:red" ng-show="myfrom.user.$invalid &amp;&amp; myfrom.user.$dirty"&gt; &lt;span ng-show="myfrom.user.$error.required"&gt;用户名是必填项&lt;/span&gt; &lt;/span&gt; &lt;/p&gt; &lt;p&gt;邮箱:&lt;br /&gt; &lt;input type="email" ng-model="email" required="" name="email" /&gt; &lt;span style="color:red" ng-show="myfrom.email.$invalid &amp;&amp; myfrom.email.$dirty"&gt; &lt;span ng-show="myfrom.email.$error.required"&gt;邮箱是必填项&lt;/span&gt; &lt;span ng-show="myfrom.email.$error.email"&gt;邮箱必须合法&lt;/span&gt; &lt;/span&gt; &lt;/p&gt; &lt;p&gt; &lt;input type="submit" ng-disabled="myfrom.user.$invalid &amp;&amp; myfrom.user.$dirty || myfrom.email.$invalid &amp;&amp; myfrom.email.$dirty"/&gt; &lt;/p&gt; &lt;/form&gt; &lt;script src="js/angular.js" type="text/javascript" charset="utf-8"&gt;&lt;/script&gt; &lt;script type="text/javascript"&gt; var app=angular.module('form',[]); app.controller('validateCtrl', function($scope) &#123; $scope.user = 'John Doe'; $scope.email = 'john.doe@gmail.com'; &#125;); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt;&lt;!--$dirty 表单有填写记录$valid 字段内容合法的$invalid 字段内容是非法的$pristine 表单没有填写记录提示信息会在 ng-show 属性返回 true 的情况下显示。--&gt; #CSS 类 ng-model 指令基于它们的状态为 HTML 元素提供了 CSS 类 1234567891011&lt;style&gt; input.ng-invalid &#123;/*元素名+状态值*/ background-color: lightblue; &#125; &lt;/style&gt; &lt;body&gt; &lt;form ng-app="" name="myForm"&gt; 输入你的名字: &lt;input name="myAddress" ng-model="text" required&gt; &lt;/form&gt; ng-model 指令根据表单域的状态添加/移除以下类：ng-emptyng-not-emptyng-touchedng-untouchedng-validng-invalidng-dirty 表单有填写记录ng-pending 未发生时ng-pristine 初始时 AngularJS Scope(作用域)Scope(作用域) 是应用在 HTML (视图) 和 JavaScript (控制器)之间的纽带。 Scope 是一个对象，有可用的方法和属性。 Scope 可应用在视图和控制器上。 12345678910111213141516171819202122232425262728293031323334&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body ng-app="event"&gt; &lt;div ng-controller="personCtrl"&gt; &lt;button ng-click="toggle()"&gt;隐藏/显示&lt;/button&gt; &lt;p ng-hide="myVar"&gt; 名: &lt;input type="text" ng-model="firstName"&gt;&lt;br&gt; 姓名: &lt;input type="text" ng-model="lastName"&gt;&lt;br&gt; &lt;br&gt; Full Name: &#123;&#123;firstName + " " + lastName&#125;&#125; &lt;/p&gt; &lt;/div&gt; &lt;!-----------分割线---------------------------------------------&gt; &lt;script src="js/angular.js" type="text/javascript" charset="utf-8"&gt;&lt;/script&gt; &lt;script type="text/javascript" charset="utf-8"&gt; var app=angular.module('event',[]); app.controller('personCtrl', function($scope) &#123; $scope.firstName = "John", //属性 $scope.lastName = "Doe" $scope.myVar = false; $scope.toggle = function() &#123; //方法 $scope.myVar = !$scope.myVar; &#125;; &#125;); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 视图中，你不需要添加 $scope 前缀, 只需要添加属性名即可，如： {{firstName + " " + lastName}}。 Scope 概述AngularJS 应用组成如下： View(视图), 即 HTML。 Model(模型), 当前视图中可用的数据。 Controller(控制器), 即 JavaScript 函数，可以添加或修改属性。 Scope 作用范围$scop只能管，它所在控制器定义的范围 123456789101112131415&lt;div ng-app="myApp" ng-controller="myCtrl"&gt; &lt;ul&gt; &lt;li ng-repeat="x in names"&gt;&#123;&#123;x&#125;&#125;&lt;/li&gt;//每个 &lt;li&gt; 元素可以访问当前的重复对象，这里对应的是一个字符串， 并使用变量 x 表示 &lt;/ul&gt; &lt;/div&gt; &lt;script&gt; var app = angular.module('myApp', []); app.controller('myCtrl', function($scope) &#123; $scope.names = ["Emil", "Tobias", "Linus"]; &#125;); &lt;/script&gt; 根作用域所有的应用都有一个 $rootScope，它可以作用在 ng-app 指令包含的所有 HTML 元素中。$rootScope 可作用于整个应用中。是各个 controller 中 scope 的桥梁。用 rootscope 定义的值，可以在各个 controller 中使用。 123456789101112131415161718&lt;div ng-app="myApp" ng-controller="myCtrl"&gt; &lt;h1&gt;&#123;&#123;lastname&#125;&#125; 家族成员:&lt;/h1&gt; &lt;ul&gt; &lt;li ng-repeat="x in names"&gt;&#123;&#123;x&#125;&#125; &#123;&#123;lastname&#125;&#125;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;script&gt; var app = angular.module('myApp', []); app.controller('myCtrl', function($scope, $rootScope) &#123; $scope.names = ["Emil", "Tobias", "Linus"]; $rootScope.lastname = "Refsnes"; &#125;); &lt;/script&gt; AngularJS 控制器ng-controller 指令定义了应用程序控制器。控制器是 JavaScript 对象，由标准的 JavaScript 对象的构造函数 创建 12345678910111213141516&lt;div ng-app="myApp" ng-controller="myCtrl"&gt;名: &lt;input type="text" ng-model="firstName"&gt;&lt;br&gt;姓: &lt;input type="text" ng-model="lastName"&gt;&lt;br&gt;&lt;br&gt;姓名: &#123;&#123;firstName + " " + lastName&#125;&#125;&lt;/div&gt;&lt;script&gt;var app = angular.module('myApp', []);app.controller('myCtrl', function($scope) &#123; $scope.firstName = "l"; $scope.lastName = "y";&#125;);&lt;/script&gt; 控制器和scope一起使用，控制器的范围就是scope作用的范围 AngularJS 过滤器1234567891011121314151617181920212223242526272829303132331、uppercase，lowercase 大小写转换&#123;&#123; "lower cap string" | uppercase &#125;&#125; // 结果：LOWER CAP STRING&#123;&#123; "TANK is GOOD" | lowercase &#125;&#125; // 结果：tank is good2、date 格式化&#123;&#123;1490161945000 | date:"yyyy-MM-dd HH:mm:ss"&#125;&#125; // 2017-03-22 13:52:253、number 格式化（保留小数）&#123;&#123;149016.1945000 | number:2&#125;&#125;4、currency货币格式化&#123;&#123; 250 | currency &#125;&#125; // 结果：$250.00&#123;&#123; 250 | currency:"RMB ￥ " &#125;&#125; // 结果：RMB ￥ 250.005、filter查找输入过滤器可以通过一个管道字符（|）和一个过滤器添加到指令中，该过滤器后跟一个冒号和一个模型名称。filter 过滤器从数组中选择一个子集 // 查找name为iphone的行&#123;&#123; [&#123;"age": 20,"id": 10,"name": "iphone"&#125;,&#123;"age": 12,"id": 11,"name": "sunm xing"&#125;,&#123;"age": 44,"id": 12,"name": "test abc"&#125;] | filter:&#123;'name':'iphone'&#125; &#125;&#125; 6、limitTo 截取&#123;&#123;"1234567890" | limitTo :6&#125;&#125; // 从前面开始截取6位&#123;&#123;"1234567890" | limitTo:-4&#125;&#125; // 从后面开始截取4位7、orderBy 排序 // 根id降序排&#123;&#123; [&#123;"age": 20,"id": 10,"name": "iphone"&#125;,&#123;"age": 12,"id": 11,"name": "sunm xing"&#125;,&#123;"age": 44,"id": 12,"name": "test abc"&#125;] | orderBy:'id':true &#125;&#125;// 根据id升序排&#123;&#123; [&#123;"age": 20,"id": 10,"name": "iphone"&#125;,&#123;"age": 12,"id": 11,"name": "sunm xing"&#125;,&#123;"age": 44,"id": 12,"name": "test abc"&#125;] | orderBy:'id' &#125;&#125; 自定义过滤器12345678//过滤器 number &#123;&#123;10000 | filternumber &#125;&#125; //100 app.filter('filternumber',function()&#123; return function(target)&#123; target=target/100; return parseFloat(target); &#125; &#125;) AngularJS 服务(Service)在 AngularJS 中，服务是一个函数或对象，可在你的 AngularJS 应用中使用。AngularJS 内建了30 多个服务。 $location 服务，它可以返回当前页面的 URL 地址 1234var app = angular.module('myApp', []);app.controller('customersCtrl', function($scope, $location) &#123; $scope.myUrl = $location.absUrl();&#125;); $http 是 AngularJS 应用中最常用的服务。 服务向服务器发送请求，应用响应服务器传送过来的数据。 123456 var app = angular.module('myApp', []);app.controller('myCtrl', function($scope, $http) &#123; $http.get("welcome.htm").then(function (response) &#123; $scope.myWelcome = response.data; &#125;);&#125;); $timeout 服务 AngularJS $timeout 服务对应了 JS window.setTimeout 函数。 $interval 服务 AngularJS $interval 服务对应了 JS window.setInterval 函数。 创建自定义服务 12345678app.service('hexafy', function() &#123; this.myFunc = function (x) &#123; return x.toString(16); &#125;&#125;);app.controller('myCtrl', function($scope, hexafy) &#123; $scope.hex = hexafy.myFunc(255);&#125;); server的小demo html页面 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;!DOCTYPE html&gt;&lt;html ng-app="demo3"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;!--AngularJS 服务(Service)--&gt; &lt;div id="" ng-controller="myDemo1"&gt; &lt;p&gt;获去url地址&lt;/p&gt; &lt;p&gt;&#123;&#123;"我的地址是"+myUrl&#125;&#125;&lt;/p&gt; &lt;/div&gt; &lt;div id="" ng-controller="myDemo2"&gt; &lt;p&gt;获取服务端传来的数据&lt;/p&gt; &lt;p&gt;&#123;&#123;"刘洋说:"+data&#125;&#125;&lt;/p&gt; &lt;/div&gt; &lt;div id="" ng-controller="myDemo3"&gt; &lt;p&gt;延时定时器&lt;/p&gt; &lt;p&gt;&#123;&#123;"刘洋说:"+data&#125;&#125;&lt;/p&gt; &lt;/div&gt; &lt;div id="" ng-controller="myDemo4"&gt; &lt;p&gt;定时器&lt;/p&gt; &lt;p&gt;&#123;&#123;"刘洋说现在时间:"+data&#125;&#125;&lt;/p&gt; &lt;/div&gt; &lt;div ng-controller="myDemo5"&gt; &lt;p&gt;自定义函数，讲数字转换成16进制数&lt;/p&gt; &lt;input type="text" ng-model="data"/&gt; &lt;p&gt;&#123;&#123;"我是16进制数"+data1&#125;&#125;&lt;/p&gt; &lt;/div&gt; &lt;!--去抖动--&gt; &lt;div ng-controller="myDemo6"&gt; &lt;p&gt;用ajax发送请求&lt;/p&gt; &lt;input type="text" ng-model="key"/&gt; &lt;ul&gt; &lt;li ng-repeat="x in arr"&gt; &#123;&#123;x.name&#125;&#125; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;script src="js/angular.js" type="text/javascript" charset="utf-8"&gt;&lt;/script&gt; &lt;script src="js/server.js" type="text/javascript" charset="utf-8"&gt;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; js页面 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475var app=angular.module('demo3',[]);app.controller('myDemo1',['$scope',"$location",function(s,l)&#123; s.myUrl=l.absUrl();&#125;])app.controller('myDemo2',['$scope',"$http",function(s,h)&#123; h.get("other/welcome.php").then(function(r)&#123; s.data=r.data; &#125;)&#125;])app.controller('myDemo3',['$scope',"$timeout",function(s,t)&#123; s.data="今天天气不错呀"; t(function()&#123; s.data="我们去爬山吧" &#125;,2000)&#125;])app.controller('myDemo4',['$scope',"$interval",function(s,i)&#123; s.data=new Date().toLocaleTimeString(); i(function()&#123; s.data=new Date().toLocaleTimeString(); &#125;,1000)&#125;])app.service('hexafy',function()&#123; this.myfun=function(x)&#123; return parseInt(x,16); &#125;&#125;)app.controller('myDemo5',['$scope','hexafy',function(s,h)&#123; s.$watch('data1',function(newkey,oldkey)&#123; console.log(h.myfun(s.data)); s.data1=h.myfun(s.data); &#125;)&#125;])app.controller('myDemo6',['$scope','$http',function(scope,http)&#123; // function debounce(fn,wait)&#123; var last=null; return function()&#123; var arg=arguments; var later=function()&#123; fn.apply(null,arg); &#125; clearTimeout(last); last=setTimeout(function()&#123; later(); &#125;,300); &#125; &#125; scope.$watch('key',debounce(function(newv,old)&#123; console.log(arguments,"woyou"); http(&#123; url:'/bgs/poi/search_poi_nearby', params: &#123; keyword: newv, offset: 0, limit: 20 &#125; &#125;).then(function(data)&#123; console.log('hh',data.data); scope.arr=data.data; &#125;,function()&#123;&#125;) &#125;,300))&#125;])]]></content>
      <tags>
        <tag>Angular</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AngularJS学习1]]></title>
    <url>%2F2016%2F10%2F20%2FAngularJS%E5%AD%A6%E4%B9%A01%2F</url>
    <content type="text"><![CDATA[AngularJS 简介AngularJS 是一个 JavaScript 框架。它可通过 script 标签添加到 HTML 页面。AngularJS 通过 指令 扩展了 HTML，且通过 表达式 绑定数据到 HTML。 AngularJS 是一个 JavaScript 框架AngularJS 是一个 JavaScript 框架。它是一个以 JavaScript 编写的库。AngularJS 是以一个 JavaScript 文件形式发布的，可通过 script 标签添加到网页中 什么是 AngularJS？AngularJS 使得开发现代的单一页面应用程序（ **SPAs：Single Page Applications** ）变得更加容易。 AngularJS 把应用程序数据绑定到 HTML 元素。 AngularJS 可以克隆和重复 HTML 元素。 AngularJS 可以隐藏和显示 HTML 元素。 AngularJS 可以在 HTML 元素”背后”添加代码。 AngularJS 支持输入验证。AngularJS 指令 AngularJS 指令是以 ng 作为前缀的 HTML 属性。AngularJS 表达式 AngularJS 表达式写在双大括号内：。 AngularJS 表达式把数据绑定到 HTML，这与 ng-bind 指令有异曲同工之妙。 AngularJS 将在表达式书写的位置”输出”数据。 AngularJS 表达式 很像 JavaScript 表达式：它们可以包含文字、运算符和变量。AngularJS 应用 AngularJS 模块（Module） 定义了 AngularJS 应用。 AngularJS 控制器（Controller） 用于控制 AngularJS 应用。 ng-app指令定义了应用, ng-controller 定义了控制器。开始学习语法表达式 AngularJS 表达式写在双大括号内： AngularJS 表达式也可以写在ng-bind=”expression”里面 expression 可以是 字符串 数字 对象 数组举个栗子 数字 123 &lt;div ng-app="" ng-init="num1=1;num2=5"&gt; //ng-appy:指定angularjs的应用范围，ng-init:初始化变量 &lt;p&gt;总价： &#123;&#123; num1*num2 &#125;&#125;&lt;/p&gt; &lt;/div&gt; 字符串 123&lt;div ng-app="" ng-init="firstName='l';lastName='y'"&gt; &lt;p&gt;姓名： &#123;&#123; firstName + " " + lastName &#125;&#125;&lt;/p&gt;&lt;/div&gt; 对象 123&lt;div ng-app="" ng-init="person=&#123;firstName:'l',lastName:'y'&#125;"&gt; &lt;p&gt;姓为 &#123;&#123; person.lastName &#125;&#125;&lt;/p&gt;&lt;/div&gt; 数组 123&lt;div ng-app="" ng-init="points=[1,15,19,2,40]"&gt; &lt;p&gt;第三个值为 &#123;&#123; points[2] &#125;&#125;&lt;/p&gt;&lt;/div&gt; ng-bind 123&lt;div ng-app="" ng-init="points=[1,15,19,2,40]"&gt;&lt;p&gt;第三个值为 &lt;span ng-bind="points[2]"&gt;&lt;/span&gt;&lt;/p&gt; &lt;/div&gt; 指令 ng-app 指令初始化一个 AngularJS 应用程序。 ng-init 指令初始化应用程序数据。 ng-model 指令把元素值（比如输入域的值）绑定到应用程序。主要用在表单 ng-repeat 指令会重复一个 HTML 元素 自定义指令使用 .directive 函数来添加自定义的指令，使用驼峰法来命名一个指令，它时需要以 - 分割 举个栗子12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970&lt;!DOCTYPE html&gt;&lt;html ng-app="directive"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;input type="checkbox" ng-model="toggle"/&gt; &lt;div ly-show="toggle"&gt;//这是自定义属性，使用时加：restrict:"A" Lorem ipsum dolor sit amet, consectetur adipisicing elit. Nesciunt iste ex labore iure ut blanditiis eos eum voluptates odit nulla nisi delectus aut assumenda qui facere iusto nobis quis possimus. &lt;/div&gt; &lt;input type="text" ng-model="color"/&gt; &lt;ly-color r="color" name="我是不一样的烟火" ng-click="test()"&gt; &lt;/ly-color&gt;//这是自定义元素，使用时加：restrict:"E" &lt;script src="js/angular.js" type="text/javascript" charset="utf-8"&gt;&lt;/script&gt; &lt;script type="text/javascript"&gt; var app=angular.module("directive",[]); //定义一个全局的应用（必须写） app.run(function($rootScope)&#123; $rootScope.toggle=true; &#125;) //可以自定义全局属性 app.directive("lyShow",function()&#123; return &#123; restrict:'A', /*限制使用:restrict 值可以是以下几种: E 作为元素名使用 A 作为属性使用 C 作为类名使用 M 作为注释使用*/ restrict 默认值为 EA, 即可以通过元素名和属性名来调用指令。 link:function(scope,element,attr)&#123;//方法，三个参数：作用域,dom，以及，属性 scope.$watch('value',function(newv,oldv)&#123;//对某个元素进行监听它的值得变化，参数1新值，参数2旧值 console.log(newv); if(newv)&#123; element[0].style.display="block"; &#125;else&#123; element[0].style.display="none"; &#125; &#125;) &#125;, scope:&#123; value:"=lyShow" //进行元素绑定 = 表示是一个相关的变量，@表示是某个字符，&amp;表示方法 &#125; &#125; &#125;) app.directive('lyColor',function()&#123; return &#123; restroct:"E", templateUrl:"directive-mess.html", link:function(scope,ele,attr)&#123; scope.test=function()&#123; console.log("ahahahhah"); &#125; &#125;, scope:&#123; name:"@name", color:"=r" &#125;, replace:true &#125; &#125;) &lt;/script&gt; &lt;/body&gt;&lt;/html&gt;]]></content>
      <tags>
        <tag>Angular</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git温习]]></title>
    <url>%2F2016%2F10%2F08%2Fgit%E6%B8%A9%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[#Git是一款免费、开源的分布式版本控制系统，用于敏捷高效地处理任何或小或大的项目。 #安装 需要下载:Git-2.10.0-64-bit.exe #配置 ssh 配置：Git GUI — 帮助 —show ssh key–拷贝 进入 github – 右上角 – setting – SSH and GPG keys 利用命令:ssh-keygen -t rsa -C “你的邮箱” ##配置个人用户信息和电子邮件地址 1234git config --global user.name “ ”git config --global user.email “ ”git config --list (查看所有配置项)git commit --amend --author='Your Name ' 修改用户名 常用的命令命令查看git config --list 1. GIT （工作区/暂存区/版本git clone [url] ： 取远git status（查看当前状态） 取代码之后本地代码哪些发生改变git add filename（将文件从工作区添加到暂存区）git add .（上面的简写，所有的文件）git commit -m “注释” （将缓存区的文件放到版本区）git reset HEAD filename 撤销操作：将 filename 从暂存区撤回到工作区。git remote 获取远程仓库的名称 origin（远程仓库的名称可以修改的）git remote -v 获取远程仓库的地址这里写代码片git push origin master(分支) 将本地资源同步到远程仓库2、例如：工作区的文件删除了，可以通过此命令还原 checkout commit_id （commit_id log 信息 id 名称。）git log 日志 操作情况git ls-files：查看暂存区的文件123456### 3、对比：查看三个分区的差异``` bashgit diff 对比的是工作区和暂存区代码的不同git diff --cached（--staged） 对比的是暂存区与版本库代码的不同git diff master 对比的是工作区与版本库代码的不同 4、删除：git rm filename 删除暂存区的文件，前提是工作区已经删除此文件了。 git rm -f filename 删除暂存区和工作区的文件。 git rm --cached filename 删除暂存区的文件，不会删除工作区。 5、多人协作解决冲突：同步更新远程仓库里面的代码12345git fetch 将远程中的代码与本地代码手动合并git fetch 显示冲突git diff master origin/master 对比代码 显示区别git merge origin/master 手动合并git pull 将远程中的代码与本地代码自动合并(commit) 6、分支12345678910git branch 查看分支git branch new1 创建分支git checkout new1 切换分支git merge new1 合并分支git checkout -b new2 创建并切换分支（组合的写法）git branch --merged 查看当前分支下合并的分支git branch --no-merged 查看当前分支下没有合并的分支git branch -d new1 删除一个与当前分支合并下的分支。git branch -D new2 强制删除一个本地分支git push origin :branchname 删除远程创库的分支。 标签12git tag v1.0git push origin v1.0 创建分支12git branch new1git push origin master]]></content>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mysql（php操作）]]></title>
    <url>%2F2016%2F10%2F05%2Fmysql%EF%BC%88php%E6%93%8D%E4%BD%9C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[警告：装mysql和卸载mysql要小心谨慎，心塞啊 mysql基本概念什么是数据库？数据库（Database）是按照数据结构来组织、存储和管理数据的仓库，每个数据库都有一个或多个不同的API用于创建，访问，管理，搜索和复制所保存的数据。我们也可以将数据存储在文件中，但是在文件中读写数据速度相对较慢。所以，现在我们使用关系型数据库管理系统（RDBMS）来存储和管理的大数据量。所谓的关系型数据库，是建立在关系模型基础上的数据库，借助于集合代数等数学概念和方法来处理数据库中的数据。 RDBMS即关系数据库管理系统(Relational Database Management System)的特点 数据以表格的形式出现 每行为各种记录名称 每列为记录名称所对应的数据域 许多的行和列组成一张表单 若干的表单组成database 术语 数据库: 数据库是一些关联表的集合。. 数据表: 表是数据的矩阵。在一个数据库中的表看起来像一个简单的电子表格。 列: 一列(数据元素) 包含了相同的数据, 例如邮政编码的数据。 行：一行（=元组，或记录）是一组相关的数据，例如一条用户订阅的数据。 冗余：存储两倍数据，冗余可以使系统速度更快。 主键：主键是唯一的。一个数据表中只能包含一个主键。你可以使用主键来查询数据。 外键：外键用于关联两个表。 复合键：复合键（组合键）将多个列作为一个索引键，一般用于复合索引。 索引：使用索引可快速访问数据库表中的特定信息。索引是对数据库表中一列或多列的值进行排序的一种结构。类似于书籍的目录。 参照完整性: 参照的完整性要求关系中不允许引用不存在的实体。与实体完整性是关系模型必须满足的完整性约束条件，目的是保证数据的一致性。 下载https://www.mysql.com/downloads/ 安装mysql 小心就好，注意选择utf-8，用户名和密码记住，path要添加到系统上去 MySQL数据库过程中常用的命令USE 数据库名 选择要操作的MySQL数据库，使用该命令后所有MySQL命令都只针对该数据库。 12mysql&gt; use ly;Database changed show databases 数据库名 列出 MySQL 数据库管理系统的数据库列表 1234567891011mysql&gt; SHOW DATABASES;+--------------------+| Database |+--------------------+| information_schema || RUNOOB || cdcol || mysql || ly || |+--------------------+ SHOW TABLES 显示指定数据库的所有表，使用该命令前需要使用 use 命令来选择要操作的数据库 12345678910mysql&gt; use RUNOOB;Database changedmysql&gt; SHOW TABLES;+------------------+| Tables_in_runoob |+------------------+| employee_tbl || runoob_tbl || tcount_tbl |+------------------+ SHOW COLUMNS FROM 数据表 显示数据表的属性，属性类型，主键信息 ，是否为 NULL，默认值等其他信息。 1mysql&gt; SHOW COLUMNS FROM ly_table; SHOW INDEX FROM 数据表 显示数据表的详细索引信息，包括PRIMARY KEY（主键） 1mysql&gt; SHOW INDEX FROM ly_table; SHOW TABLE STATUS LIKE 数据表\G 该命令将输出MySQL数据库管理系统的性能及统计信息 123mysql&gt; SHOW TABLE STATUS FROM RUNOOB; # 显示数据库 RUNOOB 中所有表的信息mysql&gt; SHOW TABLE STATUS from RUNOOB LIKE &apos;runoob%&apos;; # 表名以runoob开头的表的信息mysql&gt; SHOW TABLE STATUS from RUNOOB LIKE &apos;runoob%&apos;\G; # 加上 \G，查询结果按列打印 php操作mysql链接数据库12345678910111213//连接数据库 $conn=mysql_connect('localhost','root','123456'); /* * 第一参数：地址 localhost代表本地 * 第二参数:用户名 默认root *第三个参数：密码 123456 * */ //判断是否链接 if(!$conn)&#123; die('不能链接呀：'.mysql_error()); &#125; //关闭数据库链接 mysql_close($conn); 操作数据库创建数据库1.mysql下创建数据库 12mysql&gt; create database ly ;Query OK, 1 row affected (0.00 sec) 2.php创建数据库名，删除，选择 123456789101112131415161718192021//设置字符集header('Content-Type:text/html;charset="utf-8"'); //创建数据库 mysql下：'create database 数据库名 $sql='create database ly'; $retval=mysql_query($sql,$conn);//1.sql语句2.链接对象 if(!$retval)&#123; die('创建失败'.mysql_error()); &#125; //选择数据库 mysql下：use 数据库名 $flag=mysql_select_db("ly",$conn);//1.选择的数据库2.连接对象 if(!$flag)&#123; die('选择失败'.mysql_error()); &#125; //删除数据库 mysql下：drop database 数据库名 $sql='drop database ly'; $retval=mysql_query($sql,$conn); if(!$retval)&#123; die('删除数据库失败'.mysql_error()); &#125; MySQL 数据类型基本类型 日期和时间类型 字符串类型 操作数据表mysql语法12345678910mysql&gt; use ly;Database changedmysql&gt; CREATE TABLE w3cschool_tbl( -&gt; ly_id INT NOT NULL AUTO_INCREMENT, -&gt; ly_title VARCHAR(100) NOT NULL, -&gt; ly_author VARCHAR(40) NOT NULL, -&gt; submission_date DATE, -&gt; PRIMARY KEY ( ly_id ) -&gt; );Query OK, 0 rows affected (0.16 sec) 1234567891011//创建表结构 $sql="create table yueguang(". "yg_id tinyint not null auto_increment, ". "yg_title varchar(100) not null, ". "yg_atuhor varchar(40) not null, ". "sub_date DATE, ". "primary key (yg_id));"; $retval=mysql_query($sql,$conn); if(!$retval)&#123; die('创建表失败'.mysql_error()); &#125; 123456//删除表/*$sql='drop table yueguang';$retval=mysql_query($sql,$conn);if(!$retval)&#123; die('删除数据表失败'.mysql_error()); &#125;*/ 1234567891011121314151617181920212223mysql_query('SET NAMES UTF8');//设置字符集$sql="create table yueguang(". "yg_id tinyint not null auto_increment, ". "yg_title varchar(100) not null, ". "yg_atuhor varchar(40) not null, ". "sub_date DATE, ". "primary key (yg_id));"; $retval=mysql_query($sql,$conn); if(!$retval)&#123; die('删除数据库失败'.mysql_error()); &#125;$sql='drop table yueguang'; $retval=mysql_query($sql,$conn); if(!$retval)&#123; die('删除数据表失败'.mysql_error()); &#125;$sql="insert into ly.yueguang(yg_title,yg_atuhor,sub_date) ". "values('从你的全世界路过','张嘉佳',NOW());"; $retval=mysql_query($sql,$conn); if(!$retval)&#123; die('插入失败'.mysql_error()); &#125; 123456789101112131415161718192021222324252627 //查询数据 $sql="select yg_id,yg_title,yg_atuhor,sub_date ". "from ly.yueguang"; $result=mysql_query($sql,$conn); if(!$result)&#123; die('查询失败'.mysql_error()); &#125; //mysql_fetch_array: 从结果集中取得一行作为关联数组，或数字数组，或二者兼有 //1.结果集 2.可选参数 //MYSQL_NUM //print_r(mysql_fetch_array($result,MYSQL_NUM)); //显示数字Array ( [0] =&gt; 1 [1] =&gt; 挪威森林 [2] =&gt; 村上春树 [3] =&gt; 2017-03-07 ) //MYSQL_ASSOC //print_r(mysql_fetch_array($result,MYSQL_ASSOC)); //显示属性：Array ( [yg_id] =&gt; 1 [yg_title] =&gt; 挪威森林 [yg_atuhor] =&gt; 村上春树 [sub_date] =&gt; 2017-03-07 ) //MYSQL_BOTH 默认 //print_r(mysql_fetch_array($result)); //Array ( [0] =&gt; 1 [yg_id] =&gt; 1 [1] =&gt; 挪威森林 [yg_title] =&gt; 挪威森林 [2] =&gt; 村上春树 [yg_atuhor] =&gt; 村上春树 [3] =&gt; 2017-03-07 [sub_date] =&gt; 2017-03-07 ) while($rows=mysql_fetch_array($result,MYSQL_ASSOC))&#123; echo "我的id&#123;$rows['yg_id']&#125;:&#123;$rows['yg_title']&#125;:&#123;$rows['yg_atuhor']&#125;:&#123;$rows['sub_date']&#125; &lt;/br&gt;"; &#125;/* 我的id1:挪威森林:村上春树:2017-03-07 我的id2:我的太阳:我的:2017-03-07 我的id3:从你的全世界路过:张嘉佳:2017-03-07 */ 各种查询方法MySQL where 子句123456789101112//where $sql="select yg_id,yg_title,yg_atuhor,sub_date ". "from ly.yueguang where yg_id=2 "; $result=mysql_query($sql,$conn); if(!$result)&#123; die('查询失败'.mysql_error()); &#125; while($rows=mysql_fetch_array($result,MYSQL_ASSOC))&#123; echo "我的id&#123;$rows['yg_id']&#125;:&#123;$rows['yg_title']&#125;:&#123;$rows['yg_atuhor']&#125;:&#123;$rows['sub_date']&#125; &lt;/br&gt;"; &#125; //我的id2:我的太阳:我的:2017-03-07 123456789101112131415161718//updata更新数据 $sql="update ly.yueguang set yg_title='我要太阳'". "where yg_id=2 "; $result=mysql_query($sql,$conn); if(!$result)&#123; die('更新失败'.mysql_error()); &#125; $sql="select yg_id,yg_title,yg_atuhor,sub_date ". "from ly.yueguang where yg_id=2 "; $result=mysql_query($sql,$conn); if(!$result)&#123; die('查询失败'.mysql_error()); &#125; while($rows=mysql_fetch_array($result,MYSQL_ASSOC))&#123; echo "我的id&#123;$rows['yg_id']&#125;:&#123;$rows['yg_title']&#125;:&#123;$rows['yg_atuhor']&#125;:&#123;$rows['sub_date']&#125; &lt;/br&gt;"; &#125; 123456//删除数据项 $sql="delete from ly.yueguang where yg_id=2"; $result=mysql_query($sql,$conn); if(!$result)&#123; die('删除数据项'.mysql_error()); &#125; 1234567891011//like匹配 $sql="select * from ly.yueguang where yg_atuhor like '%村%'";$result=mysql_query($sql,$conn); if(!$result)&#123; die('查找数据项'.mysql_error()); &#125; while($rows=mysql_fetch_array($result,MYSQL_ASSOC))&#123; echo "我的id&#123;$rows['yg_id']&#125;:&#123;$rows['yg_title']&#125;:&#123;$rows['yg_atuhor']&#125;:&#123;$rows['sub_date']&#125; &lt;/br&gt;"; &#125; //我的id1:挪威森林:村上春树:2017-03-07 1234567891011121314151617//排序 $sql="select * from ly.yueguang order by yg_id desc"; $result=mysql_query($sql,$conn); if(!$result)&#123; die('查找数据项'.mysql_error()); &#125; while($rows=mysql_fetch_array($result,MYSQL_ASSOC))&#123; echo "我的id&#123;$rows['yg_id']&#125;:&#123;$rows['yg_title']&#125;:&#123;$rows['yg_atuhor']&#125;:&#123;$rows['sub_date']&#125; &lt;/br&gt;"; &#125; /*我的id5:你的孤独虽败犹荣:刘同:2017-03-07 我的id4:摆渡人:佚名:2017-03-07 我的id3:从你的全世界路过:张嘉佳:2017-03-07 我的id1:挪威森林:村上春树:2017-03-07 */desc降序asc升序 小结暂时就写到这里，对于登录验证应该是够了，以下是学习的网站http://www.w3cschool.cn/mysql/mysql-group-by-statement.html]]></content>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[require.js使用]]></title>
    <url>%2F2016%2F09%2F15%2Frequire-js%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[问题：如何解决前端js出现的文件依赖和命名空间问题可以通过命名空间和采用模块化的方式解决，今天学的require.js可以同时解决这两个问题. requirejs能带来什么好处1.异步加载，防止js加载阻塞页面渲染 2.不必引用很多js文件 3.以上两个问题可以解决 掌握模块化的思想模块化思想就是指将页面根据内容的关联性分解成不同的且相互独立的模块进行开发，每个模块之间没有必然的联系，互不影响。 模块化思想的主要优势就体现在：提高重用性，提高开发效率，降低维护成本，提升代码质量等方面。 AMD(require.js)和CMD(sea.js)规范AMD是&quot;Asynchronous Module Definition&quot;的缩写，意思就是&quot;异步模块定义&quot;。它采用异步方式加载模块，模块的加载不影响它后面语句的运行。所有依赖这个模块的语句，都定义在一个回调函数中，等到加载完成之后，这个回调函数才会运行。 CMD规范，全称”Common Module Definition”，称为 通用模块加载规范 。一般也是用在浏览器端。浏览器端异步加载库Sea.js实现的就是CMD规范。在CMD规范中，一个模块就是一个文件。 引用require.js123456789101112131415161718192021222324252627282930313233343536&lt;script data-main="main.js" src="js/require.js"&gt;&lt;/script&gt; data-main:指定网页程序的主模块,意思是整个网页的入口代码,所有代码都从这儿开始运行.以后不用再引入js代码了，由于require.js默认的文件后缀名是js，所以可以把main.js简写成main。当我们在里面写了路径之后，以后引入js目录下面的直接写文件名不加后缀，否则不仅要加后缀还要加文件路径 require.js：引入模块 下载地址：http://requirejs.org/docs/release/2.3.3/minified/require.js# 主程序入口（主模块main.js）## 测试是否引入成功![一如](http://img.blog.csdn.net/20170306193718505?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjkxMDQ5OTk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast) ## 调用模块写法（放在mian.js中）``` bashrequire([],function()&#123; alert(1);&#125;)require 调用模块，接收二个参数。第1个参数是一个数组，表示所依赖的模块 (也就是js了) ；第2个参数是一个回调函数，当前面指定的模块都加载成功后，它将被调用。## 依赖模块写法（独立单独的js--module.js）define([],function()&#123; alert(1);&#125;)## 在入口函数添加依赖(main.js)main.js require(["js/module1.js","js/module2.js"],function(m1)&#123; alert("我是入口函数"); &#125;) 1234module1.js define([],function()&#123; alert("我是模块一"); &#125;) 1234module.js define([],function()&#123; alert("我是模块2"); &#125;) 结果：我是模块一 我是模块2 我是入口函数 小结：由于依赖模块是异步的，所以必须先执行完，才能调用回调函数,两个依赖的顺序出现不一定按顺序来 加载文件（加载服务器文件）//引入jquery 1234567891011121314require.config(&#123; paths:&#123; "jquery":["http://libs.baidu.com/jquery/2.0.3/jquery"]//可引入多个 &#125;&#125;)require(["js/module1.js","js/module2.js"],function(m1)&#123; alert("我是入口函数");&#125;)require(["jquery"],function($)&#123; console.log(typeof $);//function&#125;) 其实当我们在data-main=“js/main”这样设定其实相当于：123 require.config(&#123; baseUrl : "js"&#125;) 引入第三方模块暂时没学，回头补充 补充：主模块的依赖模块是[&apos;jquery&apos;, &apos;module1&apos;, &apos;module2&apos;]。默认情况下，require.js假定这三个模块与main.js在同一个目录，文件名分别为 jquery.js，module1.js和module2.js，然后自动加载。]]></content>
      <tags>
        <tag>require.js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[pubsub-js的简单使用]]></title>
    <url>%2F2016%2F08%2F20%2Fpubsub-js%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[发布与订阅 它是一个库，通过这个库，我们能很好的将事件事件发布出去，而不需要关心接受者是谁 https://www.npmjs.com/package/pubsub-js 这是npm库 https://github.com/mroderick/PubSubJS 这是地址 安装 cnpm i pubsub-js -S 我把它运用在了一个小demo配合react 这是 App.js 12345678910111213141516171819202122232425262728293031323334353637383940414243444546import React, &#123; Component &#125; from 'react';import logo from './logo.svg';import './App.css';import Alert from './Alert'import PubSub from "pubsub-js"class Button extends Component&#123; constructor(props)&#123; super(props) this.state=&#123; time:false &#125; this.bundEvent=this.bundEvent.bind(this); &#125; bundEvent() &#123; this.setState(prevState =&gt; (&#123;time: !prevState.time&#125;)) if(this.state.time)&#123; PubSub.publishSync("SHOW_TIME","测试啦") &#125;else&#123; PubSub.publish("HIDE_TIME","继续") &#125; &#125; render()&#123; return (&lt;div&gt; &lt;button onClick=&#123;this.bundEvent&#125;&gt;&#123;this.props.children&#125;&lt;/button&gt; &lt;/div&gt;) &#125;&#125;class App extends Component &#123; render() &#123; return ( &lt;div className="App"&gt; &lt;Alert/&gt; &lt;Button&gt;大时代&lt;/Button&gt; &lt;/div&gt; ); &#125;&#125;export default App; 这是自定义的提示，名字请忽略，没写弹窗 1234567891011121314151617181920212223242526272829303132333435363738import React, &#123; Component &#125; from 'react';import './App.css';import PubSub from "pubsub-js"class Alert extends Component &#123; constructor(props) &#123; super(props) this.state=&#123; flag:false &#125; &#125; Show(e) &#123; console.log(e,11); this.setState(&#123; flag:true &#125;) &#125; Hide(e) &#123; console.log(e,22); this.setState(&#123; flag:false &#125;) &#125; componentDidMount() &#123; PubSub.subscribe("SHOW_TIME",this.Show.bind(this)) PubSub.subscribe("HIDE_TIME",this.Hide.bind(this)) &#125; render() &#123; console.log(this.state.flag); return ( &lt;div className="App" style=&#123;&#123;display:this.state.flag ? 'block' : 'none'&#125;&#125;&gt; &lt;p&gt;测试&lt;/p&gt; &lt;/div&gt; ); &#125;&#125;export default Alert; PubSub.subscribe(“SHOW_TIME”,this.Show.bind(this)) 这是用来订阅一个方法 PubSub.publish(“HIDE_TIME”,”继续”) 这就是用来发布方法的了 PubSub.unsubscribe() 用来取消订阅 对于全局都需要的弹窗和tips以及loding，我们可以用这个来改，不用每次都在局部写了 官网上提供的小栗子1234567891011121314151617181920Basic example// create a function to subscribe to topicsvar mySubscriber = function( msg, data )&#123; console.log( msg, data );&#125;;// add the function to the list of subscribers for a particular topic// we're keeping the returned token, in order to be able to unsubscribe// from the topic later onvar token = PubSub.subscribe( 'MY TOPIC', mySubscriber );// publish a topic asyncronouslyPubSub.publish( 'MY TOPIC', 'hello world!' );// publish a topic syncronously, which is faster in some environments,// but will get confusing when one topic triggers new topics in the// same execution chain// USE WITH CAUTION, HERE BE DRAGONS!!!PubSub.publishSync( 'MY TOPIC', 'hello world!' ); 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364Cancel specific subscription// create a function to receive the topicvar mySubscriber = function( msg, data )&#123; console.log( msg, data );&#125;;// add the function to the list of subscribers to a particular topic// we're keeping the returned token, in order to be able to unsubscribe// from the topic later onvar token = PubSub.subscribe( 'MY TOPIC', mySubscriber );// unsubscribe this subscriber from this topicPubSub.unsubscribe( token );Cancel all subscriptions for a function// create a function to receive the topicvar mySubscriber = function( msg, data )&#123; console.log( msg, data );&#125;;// unsubscribe mySubscriber from ALL topicsPubSub.unsubscribe( mySubscriber );Clear all subscriptions for a topicPubSub.subscribe('a', myFunc1);PubSub.subscribe('a.b', myFunc2);PubSub.subscribe('a.b.c', myFunc3);PubSub.unsubscribe('a.b');// no further notications for 'a.b' and 'a.b.c' topics// notifications for 'a' will still get publishedClear all subscriptionsPubSub.clearAllSubscriptions();// all subscriptions are removedHierarchical addressing// create a subscriber to receive all topics from a hierarchy of topicsvar myToplevelSubscriber = function( msg, data )&#123; console.log( 'top level: ', msg, data );&#125;// subscribe to all topics in the 'car' hierarchyPubSub.subscribe( 'car', myToplevelSubscriber );// create a subscriber to receive only leaf topic from hierarchy op topicsvar mySpecificSubscriber = function( msg, data )&#123; console.log('specific: ', msg, data );&#125;// subscribe only to 'car.drive' topicsPubSub.subscribe( 'car.drive', mySpecificSubscriber );// Publish some topicsPubSub.publish( 'car.purchase', &#123; name : 'my new car' &#125; );PubSub.publish( 'car.drive', &#123; speed : '14' &#125; );PubSub.publish( 'car.sell', &#123; newOwner : 'someone else' &#125; );// In this scenario, myToplevelSubscriber will be called for all// topics, three times in total// But, mySpecificSubscriber will only be called once, as it only// subscribes to the 'car.drive' topic Tips12345678910111213141516Example of use of "constants"// BADPubSub.subscribe("hello", function( msg, data )&#123; console.log( data )&#125;);PubSub.publish("helo", "world");// BETTERvar MY_TOPIC = "hello";PubSub.subscribe(MY_TOPIC, function( msg, data )&#123; console.log( data )&#125;);PubSub.publish(MY_TOPIC, "world");]]></content>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[gulp-smushit--无损压缩jpg和png]]></title>
    <url>%2F2016%2F08%2F15%2Fgulp-smushit-%E6%97%A0%E6%8D%9F%E5%8E%8B%E7%BC%A9jpg%E5%92%8Cpng%2F</url>
    <content type="text"><![CDATA[12345678910var gulp = require('gulp');var smushit = require('gulp-smushit'); gulp.task('img1', function () &#123; return gulp.src('images/*.png') .pipe(smushit(&#123; verbose: true &#125;)) .pipe(gulp.dest('smushit-dist'));&#125;);]]></content>
      <tags>
        <tag>gulp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jquery回调函数复习]]></title>
    <url>%2F2016%2F08%2F11%2Fjquery%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0%E5%A4%8D%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[jquery回调函数复习callbacks.add(); 可以添加一个或者多个回调 创建一个回调函数 123456789var callbacks = $.Callbacks();var foo = function (value) &#123; console.log('foo:'+value);&#125;var bar = function (value) &#123; console.log("bar:"+value);&#125; 这是一个函数的情况 123callbacks.add(foo);callbacks.fire('hello');//foo:hello 继续添加一个函数 123callbacks.add(bar);callbacks.fire('world');// foo:world bar:world callbacks.disable() 禁止列表中的回调列表123456789101112131415161718192021var foo = function (value) &#123; console.log('foo:'+value);&#125;var bar = function (value) &#123; console.log("bar:"+value);&#125; var callbacks = $.Callbacks();callbacks.add(foo);callbacks.fire('hello');//foo:hellocallbacks.disable(foo);//后面不执行了callbacks.fire('hello');callbacks.add(bar);callbacks.fire('world'); callbacks.empty() 清空所有队列12345678910111213141516171819202122var callbacks = $.Callbacks();var foo = function()&#123; console.log("测试1");&#125;var bar = function(value)&#123; console.log("测试1 ",value);&#125;callbacks.add(foo);callbacks.add(bar);console.log(callbacks.has(foo)); //truecallbacks.fire("我出来了"); //测试1 测试1 我出来了callbacks.empty();callbacks.fire("我出来了"); //console.log(callbacks.has(foo)); //false callbacks.fire(args); 执行加入在队列里面的所有函数123456789101112131415var callbacks = $.Callbacks();var foo = function(value)&#123; console.log("测试1",value);&#125;var bar = function(value)&#123; console.log("测试2",value);&#125;callbacks.add(foo)callbacks.add(bar)callbacks.fire("我是","liuyang"); //测试1 我是 测试2 我是callbacks.fire(["我是","liuyang"]); //测试1 (2) ["我是", "liuyang"] 测试2 (2) ["我是", "liuyang"] callbacks.fired() 判定回调是否执行过一次123456789101112131415161718var callbacks = $.Callbacks();var foo = function(value)&#123; console.log("测试1",value);&#125;var bar = function(value)&#123; console.log("测试2",value);&#125;callbacks.add(foo)callbacks.add(foo)console.log(callbacks.fired()); //falsecallbacks.fire("试试"); //测试1 试试console.log(callbacks.fired()); //true callbacks.fireWith([context],[args]) context: 该列表中的回调被触发的上下文引用 args: 一个参数或参数列表传回给回调列表。 1234567891011var callbacks = $.Callbacks();var foo = function(value1,value2)&#123; console.log("测试1",value1,value2);&#125;callbacks.add(foo);callbacks.fireWith(window,["我是","aymfx"]); //测试1 我是 aymfxcallbacks.fireWith(null,["我是","aymfx"]); //测试1 我是 aymfx callbacks.has(callback) 判断队列中是否出存在此回调函数1234567891011121314var callbacks = $.Callbacks();var foo = function(value1,value2)&#123; console.log("测试1",value1,value2);&#125;var f00 = function(value1,value2)&#123; console.log("测试1",value1,value2);&#125;callbacks.add(foo);console.log(callbacks.has(foo)); //trueconsole.log(callbacks.has(f00)); //false callbacks.lock() 锁定当前状态 和 callbacks.locked() 判断状态是否锁定123456789101112131415161718var callbacks = $.Callbacks();var foo = function(value)&#123; console.log("测试1",value);&#125;callbacks.add(foo)callbacks.fire("bar"); //测试1 barconsole.log(callbacks.locked()); //falsecallbacks.lock();callbacks.fire("bar1"); //console.log(callbacks.locked()); //true callbacks.remove(callbacks); 移除一个或者多个回调函数123456789101112131415161718192021222324var callbacks = $.Callbacks();var foo = function(value)&#123; console.log("测试1",value);&#125;var bar = function(value)&#123; console.log("测试2",value);&#125;callbacks.add(foo)callbacks.add(bar)callbacks.fire("哈哈"); //测试1 哈哈 测试2 哈哈callbacks.remove(bar);callbacks.fire("呵呵"); //测试1 呵呵callbacks.remove();callbacks.fire("呵呵"); //测试1 呵呵console.log(callbacks.has(bar)); //false]]></content>
      <tags>
        <tag>jquery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javasciptDom操作]]></title>
    <url>%2F2016%2F08%2F03%2FjavasciptDom%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[获取节点document getElementById 通过id属性获取节点（object） getElementsByName 通过names属性获取节点(类数组) getElementsByTagName 通过元素标签获取元素(类数组) getElementsByClassName 通过class属性获取节点(类数组)ie8不兼容 节点指针 firstChild 语法:父节点.firstChild 功能:获取元素首个子节点 lastChild 语法:父节点.lastChild 功能:获取元素的最后一个字节点 childNodes 语法:父节点.childNodes 功能:获取元素子节点列表 previousSibling 语法:兄弟节点.previousSibling 功能:获取已知节点的前一个节点 nextSibling 语法:兄弟节点.nextSibling 功能:获取已知节点的后一个节点 parentNode 语法:子节点.parentNode 功能:获取已知节点的父节点 节点操作创建节点 createElement 语法:document.createElement（元素标签） 功能:创建元素节点 createAttribute 语法:document.createAttribute（元素属性） 功能:创建属性节点 createTextNode 语法:document.createTextNode(文本内容) 功能:创建文本节点插入节点 appendChild(所要添加的节点) 向子节点列表末尾添加新的子节点 insertBefore(所要添加的节点，已知的节点) 在已知的节点插入新的节点，如果没有可以写null； 12345var div=document.getElementById(&apos;myDiv&apos;);var odi=document.createElement(&apos;div&apos;);var text=document.createTextNode(&apos;我不再爱你&apos;);odi.appendChild(text);div.insertBefore(odi,null); 替换节点 replaceChild(要插入的元素，将要替换的元素) 将一个节点替换成另一个 复制节点 cloneNode 语法：需要被复制的节点.cloneNode(true/false)//默认为false 功能:创建指定节点副本 参数 true:复制当前节点以及所有子节点 false:仅复制当前节点删除节点 removeChild(删除的节点) 删除指定的节点 属性操作 获取属性：getAttribute(元素属性名) 获取元素节点中指定的属性值 设置属性: setAttribute(属性名,属性值) 创建或元素节点的属性 删除属性: removeAttribute（属性名） 删除元素中指定的属性 文本操作 insertData(offset,String):从offset指定的位置插入string appendData(string):将string插入到文本节点的末尾处 deleteDate(offset,count) 从off将count个字符用string替代 replaceData(off,count,string);从off将count个字符用string替代 splitData(offset) 从offset起将文本节点分成两个节点 substring(offset,count) 返回由offset起的count个节点]]></content>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javascript流程语句以及运算符，BOW操作图，以及学习路线图]]></title>
    <url>%2F2016%2F08%2F03%2Fjavascript%E6%B5%81%E7%A8%8B%E8%AF%AD%E5%8F%A5%E4%BB%A5%E5%8F%8A%E8%BF%90%E7%AE%97%E7%AC%A6%EF%BC%8CBOW%E6%93%8D%E4%BD%9C%E5%9B%BE%EF%BC%8C%E4%BB%A5%E5%8F%8A%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[前言由于比较简单，就直接附上两张图就好，方便以后查询 流程语句图 运算符图 最后附上一张完整的学习路线，加油]]></content>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javascipt字符串函数]]></title>
    <url>%2F2016%2F08%2F03%2Fjavascipt%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[查找方法字符方法 charAt() 功能:返回字符串第n个字符 参数:超出范围-返回空字符串 返回值:string中第n个字符的实际值 123var str=&quot;assddsddsad&quot;;console.log(str.charAt(3));//dconsole.log(str.charAt(20));//什么没有 空 charCodeAt() 功能:返回字符串中第n个字符的代码 参数：num —-超出范围返回NaN 返回值: 内容：string中第n个字符的Unicode编码 范围:0~65535之间的16位整数 123var str=&quot;assddsddsad&quot;;console.log(str.charCodeAt(3));//100console.log(str.charCodeAt(20));//NaN fromCharCode() 功能：根据字符串编码创建字符串 参数:0个或多个整数 代表字符Unicode编码 返回值:由指定编码字符组成的新字符串 特性:静态方法,实为构造函数String()的属性 12console.log(String.fromCharCode(520));//Ȉconsole.log(String.fromCharCode(880));//Ͱ 位置方法 indexOf():从前向后检索字符串,看其是否含有指定子串 lastIndexOf()：从后向前检索字符串,看其是否含有指定子串 共性 功能:根据指定字符串查找下标位置 参数 必选：将要查询的自字符串 可选:开始查找的位置下标 值为负数:视作0 省略:从默认位置开始 超出0-length-1,返回-1 返回值 找到:子串首次出现的下标 未找到:返回-1 12345678910var str=&quot;asdalove&quot;;console.log(str.indexOf(&quot;2&quot;))//-1console.log(str.indexOf(&quot;2&quot;,8))//-1console.log(str.indexOf(&quot;a&quot;,2))//3console.log(str.indexOf(&quot;a&quot;,0))//0console.log(str.lastIndexOf(&quot;a&quot;,0))//0console.log(str.lastIndexOf(&quot;a&quot;,2))//0console.log(str.lastIndexOf(&quot;a&quot;,-100))//0console.log(str.lastIndexOf(&quot;a&quot;,20))//3 console.log(str.lastIndexOf(&quot;a&quot;,2))//0 匹配方法 match() 功能:找到一个或多个正则表达式的匹配 参数 要进行模式匹配的正则表达式 非正则表达式-将其传递给RegExp()构造函数，并转换为正则表达式的对象 返回值：存放匹配结果的数组 有全局标记g 执行全局检索 找到：返回数组 内容:所有匹配的子串 缺陷: 没有派生属性 不提供与子表达式匹配的文本信息 不声明每个匹配子串的位置 弥补:使用RegExp.exec()方法 没找到:返回null 无全局标记g 执行一次匹配 找到：返回数组 内容 第0个元素：匹配文本 其他元素：与正则表达式匹配的文本 属性 input:调用该方法的字符串对象 index:匹配为本的起始字符在字符串的位置 lastIndex:匹配为本的末尾字符在字符串的位置 没找到:返回null 1234var str = &quot;The rain in SPAIN stays mainly in the plain&quot;;console.log(str.match(/ain/g));//[&quot;ain&quot;, &quot;ain&quot;, &quot;ain&quot;]console.log(str.match(/ain/gi));//[&quot;ain&quot;, &quot;AIN&quot;, &quot;ain&quot;, &quot;AIN&quot;] i可以保证不区分大小写console.log(str.match(/ain/));//[&quot;ain&quot;, index: 5, input: &quot;The rain in SPAIN stays mainly in the plain&quot;] search() 功能:检索字符串中正则表达式匹配的子串 参数:与match()相同 返回值 找到:字符串中第一个与正则表达式相匹配的子串的起始位置 未找到:返回-1 特性:忽略全局标记g和lastIndex()属性 12var str = &quot;The rain in SPAIN stays mainly in the plain&quot;;console.log(str.search(&quot;in&quot;));//6 replace() 功能:替换一个正则表达式匹配的子串 参数 参数1：需要进行替换正则表达式对象或字符串 参数2:替换文本或替换函数 特性 如果参数1仅为字符串则只进行一次匹配替换，若代替所有的子串则必须制定全局标记g 如果参数2仅为字符串则可使用特殊字符序列 $$==$ $&amp;==匹配整个模式的子字符串 $’==匹配的自字符串之前的子字符串 $`==匹配的子字符串之后的子字符串 $n==匹配第n个捕获的子字符串 n=0~9 $nn==匹配第nn个捕获的子字符串 n=01~99 12var str=&apos;i love you&apos;;console.log(str.replace(&apos;i&apos;,&apos;liuyang&apos;)); split 功能:根据指定的分割符将字符串分割成多个子串，并返回成数组 参数 必须:指定的分隔符 可选：指定数组的长度 12var str = &quot;The rain in SPAIN stays mainly in the plain&quot;;console.log(str.split(&quot; &quot;));[&quot;The&quot;, &quot;rain&quot;, &quot;in&quot;, &quot;SPAIN&quot;, &quot;stays&quot;, &quot;mainly&quot;, &quot;in&quot;, &quot;the&quot;, &quot;plain&quot;] 操作方法拼接方法 concat 语法:string.concat(value,….) 功能:链接字符串 参数:要链接到string上的一个或多个值 返回值:把所有参数都连接到字符串string上得到的新字符串 特性：功能与”+”相同原始字符串的实际值并未正真被修改 1234var str1=&quot;i&quot;;var str2=&quot; love &quot;;var str3=&quot;you&quot;;console.log(str1.concat(str2,str3));//i love you 截取方法根据下标截取子串 slice() 参数1：必需。规定从何处开始选取。如果是负数，那么它规定从数组尾部开始算起的位置。也就是说，-1 指最后一个元素，-2 指倒数第二个元素，以此类推。 参数2：可选。规定从何处结束选取。该参数是数组片断结束处的数组下标。如果没有指定该参数，那么切分的数组包含从 start 到数组结束的所有元素。如果这个参数是负数，那么它规定的是从数组尾部开始算起的元素。 123var str=&quot;abcdefghijk&quot;;console.log(str.slice(-7,-5))//4 6 efconsole.log(str);//abcdefghijk substring() from: 必需。一个非负的整数，规定要提取的子串的第一个字符在 string Object 中的位置。 to: 可选。一个非负的整数，比要提取的子串的最后一个字符在 string Object 中的位置多 1。如果省略该参数，那么返回的子串会一直到字符串的结尾。 123var str=&quot;Hello world!&quot;;document.write(str.substring(3)+&quot;&lt;br&gt;&quot;);//lo world!document.write(str.substring(3,7));//lo w 根据长度截取子串 substr() start: 必需。要抽取的子串的起始下标。必须是数值。如果是负数，那么该参数声明从字符串的尾部开始算起的位置。也就是说，-1 指字符串中最后一个字符，-2 指倒数第二个字符，以此类推。 length:可选。子串中的字符数。必须是数值。如果省略了该参数，那么返回从 stringObject 的开始位置到结尾的字串。 123456var str=&quot;abcdefghijk&quot;;console.log();console.log(str.substr(2,3));//cdeconsole.log(str.substr(-20,5));//cdefghijk 从0开始console.log(str.substr(-2,5));//jkconsole.log(str.substr(2,20));//cdefghijk 空格处理 trim 清除前置及后置空格 trimLeft:清除前置空格 trimRight：清除后置空格 比较方法：localeCompare() localeCompare() 功能:用本地特定顺序比较两个字符串 参数:与原字符串进行比较的字符串 返回值:说明比较的数字 负数:原字符串&lt;参数字符串 0：原字符串=参数字符串 正数:原字符串&gt;参数字符串 1234var str=&quot;北京&quot;;var var2=&quot;北京&quot;;var res=str.localeCompare(var2);console.log(res); //0 编码方法#字符串常规编码与解码 escape() unescape()URI字符串编码与解码 encodeURI() decodeURI()URI组件编码与解码 encodeURIComponent() decodeURIComponent() 转换方式大小写转换转换为大写 toUpperCase(); toLocaleUpperCase() 本地转换为小写 toLowerCase(); toLocaleLowerCase()本地代码转换 用js动态格式化html,但不具有语义性 ，舍弃]]></content>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js的严格模式总结]]></title>
    <url>%2F2016%2F07%2F29%2Fjs%E7%9A%84%E4%B8%A5%E6%A0%BC%E6%A8%A1%E5%BC%8F%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[//变量 要声明 123/*&quot;use strict&quot;;a=&apos;liuynag&apos;;console.log(a);//Uncaught ReferenceError: a is not defined*/ //不能调用delete 12345// &quot;use strict&quot;; /*var color=&apos;red&apos;; console.log(color); delete color;//Delete of an unqualified identifier in strict mode. console.log(color);*/ //不能将保留字作为变量名 123/* &quot;use strict&quot;; var public=&apos;hah&apos;; console.log(public);//Unexpected strict mode reserved word*/ //严格模式 对象重名属性报错 123456/*&quot;use strict&quot;; var person=&#123; name:&apos;hahhha&apos;, name:&apos;greg&apos; &#125; console.log(person.name);//编辑器报错，浏览器没有*/ //重名参数 12345678/*&quot;use strict&quot;; function a(num,num)&#123; console.log(num);// Duplicate parameter name not allowed in this context console.log(arguments[1]); console.log(a.length); &#125; a(11,12);*/ //arguments对象 123456// &quot;use strict&quot;; /*function a(num,num1)&#123; num=2; console.log(arguments[0]);//严格11 不严格 2 &#125; a(11,12);*/ //淘汰了arguments.callee arguments.caller 123456789// &quot;use strict&quot; /*function factorial(num)&#123; if(num&lt;=1)&#123; return 1; &#125;else&#123; return num*arguments.callee(num-1); &#125; &#125; console.log(factorial(5));//&apos;caller&apos;, &apos;callee&apos;, and &apos;arguments&apos; properties may not be accessed on strict mode functions or the arguments objects for calls to them*/ //严格模式下 if语句不能创建函数 预编译不会提到if语句外 123456789/*&quot;use strict&quot;if(true)&#123; function dosomething()&#123; console.log(&quot;好像没出错&quot;); &#125;&#125;else&#123; //写完&#125;dosomething();//ReferenceError: dosomething is not defined*/ //eval()，它将不再包含上下文中创建函数或者变量； 1234567/*&quot;use strict&quot;function dosomething()&#123; eval(&quot;var x=10&quot;); console.log(x);//: x is not defined&#125;dosomething()*/ //eval()在严格模式下只有在被求值的特殊作用域下有效，随后被销毁 123/*&quot;use strict&quot;var result=eval(&quot;var x=10,y=11;x+y&quot;);alert(result);//21*/ //抑制this 123456/*&quot;use strict&quot;var color=&apos;red&apos;;function color1()&#123; console.log(this.color);&#125;color1(null);//严格Cannot read property &apos;color&apos; of undefined 不严格 red*/ //抛弃了with语句 1234/*&quot;use strict&quot; with(location)&#123; alert(href);////严格Strict mode code may not include a with statement不严格 一段地址 &#125;*/ //抛弃8进制，0开头不属于8进制 123/*&quot;use strict&quot;; var value=&apos;010&apos;; console.log(parseInt(value));//不严格8 严格10*/]]></content>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javascipt数组]]></title>
    <url>%2F2016%2F07%2F28%2Fjavascipt%E6%95%B0%E7%BB%84%2F</url>
    <content type="text"><![CDATA[JavaScript数组创建方法 构造函数对象创建 空数组：var obj=new Array(); 指定长度:var obj=new Array(size); 指定元素：var obj=new Array(value1,….,valuen); 字面量对象创建 单维数组：var obj=[value1,value2,….,valuen]; 多维数组：var obj=[[v1,v2],[v1,v2],[v1,v2]]； 基本操作 存取数组 单维数组:数组名[下标索引] 多维数组:数组名[外层下标][内层下标] 特性 数组长度是弹性的,可以自由伸缩 数组下标从零开始 下标类型 数值 非数值 转换成字符串(数字字符会转成数字) 1234567891011 var arr=[]; arr[&quot;10&quot;]=0; alert(arr.length);//11alert(arr[10]);//0 var arr1=[]; arr1[&quot;a&quot;]=&quot;hah&quot;; 123arr1[&quot;b&quot;]=&quot;asd&quot;;alert(arr1.length);//0alert(arr1[&quot;b&quot;])//asd - 生成关联数组 12345arr[&quot;name&quot;] = &quot;mary&quot;; arr[&quot;age&quot;] = &quot;3&quot;; arr[&quot;sex&quot;] = &quot;man&quot;; - 下标将作为对象属性的名字 - Javascript数组下标值的范围为0到2的32次方。对于任意给定的数字下标值，如果不在此范围内，js会将它转换为一个字符串，并将该下标对应的值作为该数组对象的一个属性值而不是数组元素，例如array[-1] = &quot;yes&quot; 其实就相当于给array对象添加了一个名为-1的属性，属性值为yes。如果该下标值在合法范围内，则无论该下标值是数字还是数字字符串，都一律会被转化为数字使用，即 array[&quot;100&quot;] = 0 和 array[100] = 0 执行的是相同的操作。 - 数组元素可以添加到对象中 增加数组：使用[]运算符指定新的下标 删除数组:delete 数组名[下标] 1234567 var arr1=[];arr1[&quot;a&quot;]=&quot;hah&quot;;arr1[&quot;b&quot;]=&quot;asd&quot;; console.log(arr1)//[a: &quot;hah&quot;, b: &quot;asd&quot;]delete arr1[&quot;a&quot;];alert(typeof arr1);console.log(arr1);//[b: &quot;asd&quot;] 遍历数组:for(var 数组元素变量 in 数组) 12345678var arr1=[];arr1[&quot;a&quot;]=&quot;hah&quot;;arr1[&quot;b&quot;]=&quot;asd&quot;;arr1[&quot;c&quot;]=&quot;asd&quot;;for (var x in arr1) &#123;document.write(x+&quot;:&quot;+arr1[x]);//a:hahb:asdc:asd&#125; 数组属性 constructor:引用数组对象的构造函数 1234var arr=new Array();var arr1=[];alert(arr.constructor)//function Array() &#123; [native code] &#125;alert(arr1.constructor)//function Array() &#123; [native code] &#125; length:返回数组的长度 数组下标必须是数字，或者数字字符，否则length为0 12345var arr1=[];arr1[&quot;a&quot;]=&quot;hah&quot;;arr1[&quot;b&quot;]=&quot;asd&quot;; arr1[&quot;c&quot;]=&quot;asd&quot;; alert(arr1.length)//0 prototype:通过增加属性和方法扩展数组定义 12345678910111213function array_max( )&#123; var i, max = this[0]; for (i = 1; i &lt; this.length; i++) &#123; if (max &lt; this[i]) max = this[i]; &#125; return max;&#125;Array.prototype.max = array_max;var x = new Array(1, 2, 3, 4, 5, 6);var y = x.max( );//y=6 ECMAScript 3方法添加 push():在数组末尾添加元素 unshift():在数组头部添加元素 cancat() 合并两个数组删除 pop() 删除并返回最后一个元素 shift()删除并返回第一个元素 子数组 splice() 删除任意数量的项 要删除的起始下标 要删除的项数 123var arr=[1,2,3,4,5,6]; alert(arr.splice(1,2));//23 alert(arr);//1456 - 在指定位置插入指定项 - 起始下标 - 0(不删除) - 要插入的项 123var arr=[1,2,3,4,5,6]; alert(arr.splice(2,0,&quot;a&quot;));// alert(arr);//12a3456 - 替换任意数量的项 - 起始下标 - 要删除的项数 - 要插入的项 1234 var arr=[1,2,3,4,5,6]; alert(arr.splice(2,2,&quot;a&quot;,&quot;b&quot;));//34 alert(arr)//12ab56- slice - 功能：从已有的数组中选取部分元素构成新数组 - 参数：起始位置，结束位置 - 特性: - 如果是负数，则用数组长度加上该值的确定位置 - 起始位置开始截取 - 结束位置的前一个 1234var arr=[1,2,3,4,5,6]; var newarr=arr.slice(-5,-3); alert(newarr);//23 alert(arr);//12345 数组排序 reverse()颠倒数组中元素的顺序 sort():对字符数组或者数字数组进行排序 特性 默认按字符串进行比较 按数值大小比较需要函数支持 123456var arr=[1,5,8,5,6,7]; arr.sort(function(a,b)&#123; return a-b; &#125;) alert(arr);//155678 数组转换 toString()转换为字符串并返回 toLocaleString()转换为本地格式字符串并且返回 join() 用于指定分割数组并将其转换成字符串 1234var arr=[1,5,8];alert(arr);//1,5,8alert(arr.join(&quot;&quot;));//158alert(arr);//1,5,8 split()分割字符串转换成数组 1234var str=&quot;abd&quot;;alert(str);//abdalert(str.split(&quot;&quot;));//a,b,dalert(str);//abd ECMAScript 5 方法位置方法 indexOf:从数组的起始位置开始查找 12var arr=[&quot;a&quot;,&quot;b&quot;,&quot;c&quot;];alert(arr.indexOf(&quot;c&quot;,1));//2 lastIndexOf:从数组的结束位置开始查找 12var arr=[&quot;a&quot;,&quot;b&quot;,&quot;c&quot;];alert(arr.lastIndexOf(&quot;a&quot;,1));//0 参数: 要查找的项 表示查找起点的位置索引 迭代方法 every：如果该函数对每一项都返回true,则返回true 12345 var ages = [32, 33, 16, 40];function checkAdult(age) &#123;return age &gt;= 18;&#125; document.write(ages.every(checkAdult)+&quot; &quot;);//fasle filter:返回值为true的所有数组成员 123456var ages = [32, 33, 16, 40];function checkAdult(age) &#123;return age &gt;= 18;&#125; document.write(ages.filter(checkAdult)+&quot; &quot;);//32,33,40 foreach：无返回值 第1个是遍历的数组内容；第2个是对应的数组索引，第3个是数组本身 1[1, 2 ,3, 4].forEach(alert); map:返回每次函数调用的结果数组 12345 var ages = [32, 33, 16, 40];function checkAdult(age) &#123;return age+=18;&#125; 1document.write(ages.map(checkAdult)+&quot; &quot;);//50,51,34,58 some:有任意一项返回true,则返回true 1234567var ages = [32, 33, 16, 40];function checkAdult(age) &#123;return age&gt;18;&#125;document.write(ages.some(checkAdult)+&quot; &quot;);//true 参数 接收参数 要在每一项上运行的函数 运行该函数的作用域对象 传入参数 数组项的值item 该项在数组中的位置index 数组对象本身array 缩小方法 reduce:从数组起始位开始遍历 previousValue（上一次调用回调函数时的返回值，或者初始值） currentValue（当前正在处理的数组元素） currentIndex（当前正在处理的数组元素下标） array（调用reduce()方法的数组） 12var arr = [1,2,3,4];alert(arr.reduce(function(pre,cur)&#123;return pre + cur&#125;) );// return 10 - 对比: 123456789101112131415 var arr = [1,2,3,4]; sum = 0; arr.forEach(function(e)&#123;sum += e;&#125;); // sum = 10 just for demo var arr = [1,2,3,4], sum = 0; arr.map(function(obj)&#123;sum += obj&#125;);//return undefined array. sum = 10``` - reduceRight:从数组末尾开始遍历 ``` bash var arr = [1,2,3,4]; alert(arr.reduceRight(function(pre,cur)&#123;return pre + cur&#125;) ); 参数 接收参数 每一项上调用的函数 作为缩小基础的初始值 传入参数 当前一值 prev 当前值 cur 项的索引 index 数组对象 array]]></content>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javascipt函数基础]]></title>
    <url>%2F2016%2F07%2F25%2Fjavascipt%E5%87%BD%E6%95%B0%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[JavaScript函数基础定义方法 静态方法 function 函数名([参数列表]){函数体；[return [返回值；]]} 动态匿名方法 var 函数名=new Function([“虚参列表”]，”函数体”); var add = new Function(x,y, var sum; sum=x+y;return sum;); var s = add(100,39); alert(s=+s); 直接量方法 函数名=function([参数列表]){函数体；[return [返回值；]]} 调用方法 直接调用： 函数名(实参列表) 在连接中调用：描述文字 在事件中调用：事件类型=”函数名()” 递归调用 自执行 (function(){})() 方法 apply:将函数作为对象的方法来调用将指定参数传递给该方法 call:将函数作为对象的方法来调用将指定参数传递给该方法 &lt;script type=&quot;text/javascript&quot;&gt; function A(){ this.flag = &apos;A&apos;; this.tip = function(){ alert(this.flag); }; } function B(){ this.flag = &apos;B&apos;; } var a = new A(); var b = new B(); //a.tip.call(b); a.tip.apply(b); &lt;/script&gt; toString：返回函数的字符串表示 function a(){ alert(a) } document.write(a.toString());//function a(){ alert(a) } arguments对象 功能:存放实参的参数列表 特性 在函数体内使用 带有下标属性，但并非数组 函数声明时自动初始化 属性 length:获取函数实参的长度 callee:返回当前正在指向的函数 function a(){ document.write(arguments.callee); } a();//function a(){ document.write(arguments.callee); } caler返回调用当前正在执行函数的函数名 函数参数 参数类型 形参 定义函数时使用的参数 接收调用该函数时传递的参数 实参 调用函数时传递给函数的实际参数 特性 参数个数没有限制 实参&lt;形参 ：多余形参=undefined; 实参&gt;形参 ：多余的被忽略 参数的类型没有限制 通过arguments对象访问参数数组 参数始终按值传递 基本类型：传值 引用类型:地址 指针标识 this:指向当前操作的对象 callee:指向参数集合所属函数 prototype:指向函数附带的函数原型对象 constructor:指向创建该对象的构造函数]]></content>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javascipt变量]]></title>
    <url>%2F2016%2F07%2F22%2Fjavascipt%E5%8F%98%E9%87%8F%2F</url>
    <content type="text"><![CDATA[JavaScript变量命名方法 匈牙利命名法：变量名=类型+对象描述 Int整形 i Float浮点 fl Boolean布尔 b String字符串 s Array数组 a Object对象 o Function函数 fn Regular Expressino 正则 re 驼峰命名法 全部小写：单词与单词用下划线分割 大小写混合 大驼峰:每个首字母大写 小驼峰:第一个单词首字母小写，其他首字母大写 规则 首字符:英文或者下滑线或者$符号 var $a=&quot;asd&quot;; alert($a); 组成：英文字母，数字，下划线 $符号 禁忌：不能使用关键字和保留字 声明 显示声明：var 变量名 陋习 没有类型 重复声明 隐式声明 不声明直接赋值 正解 先声明，后读写 先赋值，后运算 变量类型 值类型 占用空间固定，保存在栈中 保存与复制的是值本身 使用typeof检测数据的类型 基本数据类型是值类型 引用类型 占用空间不固定，保存在堆中 保存和赋值的是指向对象的指针 使用instanceof检测数据类型 使用new()方法构造出的对象是引用类型 作用域 全局变量 包含 在函数体外定义的变量 在函数内部定义的无var的变量 调用:任何位置 局部变量 包含 在函数内使用var声明的变量 函数的参数变量 调用：在当前函数体内使用 优先级 局部同名变量&gt;局部同名参数&gt;全局同名变量 特性 忽略块级作用域 全局变量是全局对象的属性 局部变量是调用对象的属性 作用域链 内层函数可以访问外层函数的局部变量 外层函数不能访问内层函数的局部变量 生命周期 全局变量：除非被显示删除，否则一直存在 局部变量：自声明起至函数运行完毕或显示删除 回收机制 标记清除 引用计数]]></content>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css3-布局样式相关-慕课网学习]]></title>
    <url>%2F2016%2F07%2F21%2Fcss3-%E5%B8%83%E5%B1%80%E6%A0%B7%E5%BC%8F%E7%9B%B8%E5%85%B3-%E6%85%95%E8%AF%BE%E7%BD%91%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[Columns语法：columns：&lt;column-width&gt; || &lt;column-count&gt; 参数说明 主要用来定义多列中每列的宽度 主要用来定义多列中的列数 column-width属性值：auto如果column-width设置值为auto或者没有显式的设置值时，元素多列的列宽将由其他属性来决定，比如前面的示例就是由列数column-count来决定。length使用固定值来设置元素列的宽度，其主要是由数值和长度单位组成，不过其值只能是正值，不能为负值。 column-count属性值auto此值为column-count的默认值，表示元素只有一列，其主要依靠浏览器计算自动设置integer此值为正整数值，主要用来定义元素的列数，取值为大于0的整数，负值无效。 column-gapnormal 默认值，默值为1em（如果你的字号是px，其默认值为你的font-size值）。 length&gt; 此值用来设置列与列之间的距离，其可以使用px,em单位的任何整数值，但不能是负值。 column-rule属性值column-rule-width 类似于border-width属性，主要用来定义列边框的宽度，其默认值为“medium”，column-rule-width属性接受任意浮点数，但不接收负值。但也像border-width属性一样，可以使用关键词：medium、thick和thin。 column-rule-style 类似于border-style属性，主要用来定义列边框样式，其默认值为“none”。column-rule-style属性值与border-style属值相同，包括none、hidden、dotted、dashed、solid、double、groove、ridge、inset、outset。 column-rule-color 类似于border-color属性，主要用来定义列边框颜色，其默认值为前景色color的值，使用时相当于border-color。column-rule-color接受所有的颜色。如果不希望显示颜色，也可以将其设置为transparent(透明色) column-span属性值none 此值为column-span的默认值，表示不跨越任何列。 all 这个值跟none值刚好相反，表示的是元素跨越所有列，并定位在列的Ｚ轴之上。 W3C标准盒模型外盒尺寸计算（元素空间尺寸）element空间高度＝内容高度＋内距＋边框＋外距 element空间宽度＝内容宽度＋内距＋边框＋外距 内盒尺寸计算（元素大小）element高度＝内容高度＋内距＋边框（height为内容高度） element宽度＝内容宽度＋内距＋边框（width为内容宽度） #IE传统下盒模型（IE6以下，不包含IE6版本或”QuirksMode下IE5.5+”） 外盒尺寸计算（元素空间尺寸）element空间高度＝内容高度＋外距（height包含了元素内容宽度、边框、内距） element宽间宽度＝内容宽度＋外距（width包含了元素内容宽度、边框、内距） 内盒尺寸计算（元素大小）element高度＝内容高度（height包含了元素内容宽度、边框、内距） element宽度＝内容宽度（width包含了元素内容宽度、边框、内距） box-sizing(css3新自定义盒子属性)box-sizing: content-box | border-box | inherit属性值content-box默认值，其让元素维持W3C的标准盒模型，也就是说元素的宽度和高度（width/height）等于元素边框宽度（border）加上元素内距（padding）加上元素内容宽度或高度（content width/ height），也就是element width/height = border + padding + content width / height border-box重新定义CSS2.1中盒模型组成的模式，让元素维持IE传统的盒模型（IE6以下版本和IE6-7怪异模式），也就是说元素的宽度或高度等于元素内容的宽度或高度。从上面盒模型介绍可知，这里的内容宽度或高度包含了元素的border、padding、内容的宽度或高度（此处的内容宽度或高度＝盒子的宽度或高度—边框—内距）。 inherit使元素继承父元素的盒模型模式]]></content>
      <tags>
        <tag>html</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javascipt数据类型]]></title>
    <url>%2F2016%2F07%2F21%2Fjavascipt%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[javaScript数据类型undefined 使用var声明变量但未初始化,或者直接未声明 var a; alert(a);//undefined alert(b);//控制台输出b is not defined(这是会报错） 区分空对象指针与尚未定义的变量 var a=null; alert(a);//null alert(typeof a);//object var b; alert(a);//undefined 对未初始化的变量以及未声明的变量使用typeof运算符均会返回undefined var a; alert(typeof a);//undefined alert(typeof b);//undefined null 逻辑上null表示一个空对象的指针 var a=null; alert(a);//null 使用typeof检测会返回object alert(typeof a);//object undefined与null的关系 undefinded派生于null因此在使用“==”进行比较会返回一个人true; alert(undefined==null);//true alert(undefined===null);//false，数据类型不同 没必要将变量声明为undefined,声明空对象应将值赋给null var a=null; boolean true为真，false为假 true不一定为1，false不一定为0，会发生转换类型但不同 alert(true==1);//true alert(true===1);//false alert(false==0);//true alert(false===0);//false 使用Boolean()进行转换 转换为true 任何非空字符串 任何非0数值 任何非空对象 null和undefined会转换为false alert(Boolean(undefined)); alert(Boolean(null)); - 转换为false 空字符串 0以及NaN null以及undefined String特性 由0个或多个16位Unicode字符组成 单引号和双引号不能交叉 可以使用.length属性访问字符串长度 转义序列表示一个字符 无法精确返回双字符长度(汉字占两个字节) str=&quot;abc a\x675&quot;; alert(str);//abc ag5 alert(str.length);//7 \x67为16进制转义字符 字符串一旦被创建，其值不能改变，若要改变必须销毁原有的字符串 var lang = “Java”; lang = lang + “Script” 实现这个操作的过程如下：首先创建一个能容纳10个字符的新字符串，然后在这个字符串中填充“Java”和“Script”,最后一步是销毁原来的字符串“Java”和“Script”,因为这两个字符串已经没用了。但是在低版本的浏览器(如IE6)中，字符串拼接速度是很消耗一个性能的过程。 转义序列 \n 换行 \t 制表符 \b 空格 \r 回车 \f 分页符 \反斜杠\ \’单引号 \” 双引号 \xnn 十六进制数,n 代表0~F \unnnn 以十六进制表示一个Unicode字符 类型转换 toString 使用的类型：number boolean String object; 参数:2,8,16,10 进制转换后变字符串 /*var a=289; alert(a.toString()); alert(a.toString(2)); alert(a.toString(8)); alert(a.toString(10)); alert(a.toString(16));*/ var a=null; var b=undefined; var c=NaN; var d=new Object(); var e=true; //alert(a.toString())// Cannot read property &apos;toString&apos; of null //alert(b.toString())// Cannot read property &apos;toString&apos; of undefined alert(c.toString())//NaN alert(d.toString())//object alert(e.toString())//true String() null nudefined var b=undefined; var c=NaN; var d=new Object(); var e=true; alert(String(1));//1 alert(String(b));//undefined alert(String(c));//NaN alert(String(d));//object alert(String(e));//true eval() 计算字符串表达式的值或代码片段并以数值的形式返回 eval(&quot;x=10;y=20;document.write(x*y)&quot;);//200 document.write(&quot;&lt;br&gt;&quot; + eval(&quot;2+2&quot;));//4 document.write(&quot;&lt;br&gt;&quot; + eval(x+17));//27 number进制 十进制 八进制 前导：0 有效序列：0~7 超出范围 前导0被忽略 后续数值以十进制计数 十六进制 前导：0x或者0X 有效序列0~F 浮点数 小数后面至少一位 科学计数法 小数点后有6个0的浮点数 以e或者E为底*10的N次幂 最高的进度 17位小数 缺陷 存在舍入误差 无法测试特定的浮点数值 数值范围 最小大值 Number.MIN_VALUE; Number.Max_VALUE; 超出范围 正无穷 Infinity Number.POSITIVE_INFINITY 负无穷 -Infinity Number.NEGATIVE_INFINITY 缺陷 无法参与下一次计算 检测方法 isFinite() 超出：false 合法:true NaN 含义 Not a Number 非数值 特性 任何涉及NaN操作都将返回NaN NaN与任何数值都不等（包括自己） 检测 isNaN() 可转换数值:(false) 不能:true数值转换 Number() Boolean true:1 false:0 null 0 undefined NaN String 只包含数字或有效浮点格式 十进制数 前导0忽略 包含有效十六进制数格式 相同大小的十进制数 空字符串 0 其他格式字符串 NaN var a=&quot;12asd&quot;; alert(Number(a));//NaN object valueOf()：返回对象的原始值 toString() paseInt() 特性 忽略前置空格 直接找到第一个非空格字符 不是数值或负号：NaN 数字字符 解析数字字符 遇到非数字字符结束 参数 参数1:解析的字符 参数2：转换时的进制 parseInt() 从第一个字符开始解析 遇到无效字符结束 只有第一个小数点有效 忽略前导0 十六进制始终为0 没有小数点或者小数点后全为0：转换整数 object 定义：一组数据或功能的集合 声明: var o=new Object(); 属性与方法 Constructor:用于返回创建的当前对象的函数 var d=new Date(); alert(d.constructor);//function Date() { [native code] } hasOwnProperty(propertyName):是用来判断一个对象是否有你给出名称的属性或对象。不过需要注意的是，此方法无法检查该对象的原型链中是否具有该属性，该属性必须是对象本身的一个成员 isPrototypeOf(object):检测传入的对象是否是另一额对象的原型 propertyIsEnumerable(propertyName):检测给定属性能否用for-in语句枚举 toLocalString():返回对象的字符串表示，该字符串与执行环境的地区对应 toString()返回对象的字符串表示 valueOf()返回对象的字符串，数值或者布尔值：通常与toString()的值相同]]></content>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css3-3d转换和3D动画]]></title>
    <url>%2F2016%2F07%2F18%2Fcss3-3d%E8%BD%AC%E6%8D%A2%E5%92%8C3D%E5%8A%A8%E7%94%BB%2F</url>
    <content type="text"><![CDATA[3D转换3D翻转方法rotateX();沿x轴翻转 rotateY();沿Y轴翻转 rotateZ();沿Z轴翻转(类似于rotate()在水平旋转) 3D位置移动 的3种写法transform: translate3d(30px,30px,800px) transform:translateZ(800px) translateX(30px) translateY(30px); transform:translateZ(800px) translate(30px,30px); 3D视距perspective:value; 用于看3D效果 3D视角transform-style:preserve-3d; 用于子元素保持3d效果 transform-origin:left/right top/bottom 用于确定翻转位置,默认为center 3D动画1.创建动画的运动规则，并且取名 @keyframes name{ from{} to{} to{} } 2.绑定动画在某个元素上 动画属性 animation:(简写)name 5s linear 2s infinite alternate; animation-name: 动画名 animation-duration: 时间 默认0 animation-timing-function:曲线 默认ease linear： 线性过渡。等同于贝塞尔曲线(0.0, 0.0, 1.0, 1.0) ease： 平滑过渡。等同于贝塞尔曲线(0.25, 0.1, 0.25, 1.0) ease-in： 由慢到快。等同于贝塞尔曲线(0.42, 0, 1.0, 1.0) ease-out： 由快到慢。等同于贝塞尔曲线(0, 0, 0.58, 1.0) ease-in-out： 由慢到快再到慢。等同于贝塞尔曲线(0.42, 0, 0.58, 1.0) cubic-bezier(&lt;number&gt;, &lt;number&gt;, &lt;number&gt;, &lt;number&gt;)： 特定的贝塞尔曲线类型，4个数值需在[0, 1]区间内 animation-delay :延时 默认0 animation-iteration-count:播放次数 默认1 infinite： 无限循环 &lt;number&gt;： 指定对象动画的具体循环次数 animation-direction:周期后是否倒放 running： 运动 paused： 暂停 animation-play-state:是否暂停 默认 running running： 运动 paused： 暂停 animation-fill-mode:动画结束后的状态 none： 默认值。不设置对象动画之外的状态 forwards： 设置对象状态为动画结束时的状态 backwards： 设置对象状态为动画开始时的状态 both： 设置对象状态为动画结束或开始的状态 例子: 12345678910111213141516171819202122232425262728293031323334353637&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;正方体&lt;/title&gt;&lt;/head&gt;&lt;style type="text/css"&gt; *&#123;margin:0;padding:0;&#125; li&#123;list-style: none;&#125; .wrap&#123;transform-style:preserve-3d;transition:2s all; margin: 80px auto;width:100px;&#125; .wrap ul&#123;transform:rotateX(45deg) rotateY(45deg);position: relative;transform-style:preserve-3d; width: 100px;height: 100px;&#125; .wrap ul li&#123;width: 100px;height: 100px;opacity:0.2;left: 0;top:0;position: absolute;&#125; .wrap ul .down&#123;background:#f00;transform: translateZ(-50px);&#125; .wrap ul .up&#123;background:#f00;transform: translateZ(50px);&#125; .wrap ul .left&#123;background:#ff0;transform: translateX(-50px) rotateY(90deg) ;&#125; .wrap ul .right&#123;background:#f0f;transform: translateX(50px) rotateY(90deg) ;&#125; .wrap ul .top&#123;background:#f0f;transform: translateX(-50px) rotateX(90deg) ;&#125; .wrap ul .top&#123;background:#ff9;transform: translateX(50px) rotateX(90deg) ;&#125; .wrap:hover&#123;transform:rotateY(360deg);&#125;&lt;/style&gt;&lt;body&gt; &lt;div class="wrap"&gt; &lt;ul&gt; &lt;li class="left"&gt;&lt;/li&gt; &lt;li class="right"&gt;&lt;/li&gt; &lt;li class="top"&gt;&lt;/li&gt; &lt;li class="bottom"&gt;&lt;/li&gt; &lt;li class="up"&gt;&lt;/li&gt; &lt;li class="down"&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;3d导航&lt;/title&gt; &lt;style type="text/css"&gt; *&#123;padding:0;margin: 0;&#125; li&#123;list-style: none;&#125; ul&#123;width: 1000px;margin:50px auto;&#125; ul li&#123;float: left;transform-style: preserve-3d;&#125; ul li a&#123;display: block;width:199px;height:50px;border-right: 1px solid #666;position: relative; text-align: center;transform-style: preserve-3d;transition:1s all;&#125; ul li:last-child a&#123;border: 0;&#125; ul li a p&#123;width:199px;height:50px;position: absolute;left: 0;top: 0; font:700 12px/50px "";&#125; ul li a .a1&#123;background: #f99;&#125; ul li a .a2&#123; background-color: #51938f; -webkit-background-size: 5px 5px; background-size: 5px 5px; background-position: 0 0, 30px 30px; background-image:linear-gradient(45deg, #478480 25%, transparent 25%, transparent 75%, #478480 75%, #478480),linear-gradient(45deg, #478480 25%, transparent 25%, transparent 75%, #478480 75%, #478480); transform-origin: bottom;transform: rotateX(-90deg) translateY(50px); &#125; ul li a:hover&#123;transform-origin: top;transform: rotateX(90deg);&#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;ul&gt; &lt;li&gt; &lt;a href=""&gt; &lt;p class="a1"&gt;首页&lt;/p&gt; &lt;p class="a2"&gt;首页&lt;/p&gt; &lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=""&gt; &lt;p class="a1"&gt;首页&lt;/p&gt; &lt;p class="a2"&gt;首页&lt;/p&gt; &lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=""&gt; &lt;p class="a1"&gt;首页&lt;/p&gt; &lt;p class="a2"&gt;首页&lt;/p&gt; &lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=""&gt; &lt;p class="a1"&gt;首页&lt;/p&gt; &lt;p class="a2"&gt;首页&lt;/p&gt; &lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=""&gt; &lt;p class="a1"&gt;首页&lt;/p&gt; &lt;p class="a2"&gt;首页&lt;/p&gt; &lt;/a&gt; &lt;/li&gt; &lt;/ul&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <tags>
        <tag>html</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css3-渐变，动画过度，2d基础]]></title>
    <url>%2F2016%2F07%2F14%2Fcss3-%E6%B8%90%E5%8F%98%EF%BC%8C%E5%8A%A8%E7%94%BB%E8%BF%87%E5%BA%A6%EF%BC%8C2d%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[1.CSS3 渐变的语法及应用## 线性渐变，从左到右，或者从上倒下，线性变化 linear-gradient:值1,值2 [值3],值4 值1: top,to bottom,180deg 表示从上到下 bottom,to top,0deg 表示从下到上 left,to right,90deg 表示从左到右 right,to left,270deg 表示从右到左 45deg,to top right 从左上到右上 135deg,to top right 从左上到右上 等等 值2： 起始颜色 值3： 可以设置设置颜色的过度的距离，如50%，就是0到50% 值4： 终止颜色 注：起始位置和终止位置可设置多个颜色； ## 径向渐变，从内而外扩散（圆） radial-gradient:值1,值2 [值3],值4 值1: ellipse:椭圆效果，当元素宽高一致时为正圆 circle:正圆 值2： 起始颜色 值3： 可以设置设置颜色的过度的距离，如50%，就是0到50% 值4： 终止颜色 注：起始位置和终止位置可设置多个颜色； ## 重复渐变，按照规律一层一层循环 repeating-radial-gradient值1,值2 [值3],值4 值1: ellipse:椭圆效果，当元素宽高一致时为正圆 circle:正圆 值2： 起始颜色 值3： 可以设置设置颜色的过度的距离，如50%，就是0到50% 值4： 终止颜色 注：起始位置和终止位置可设置多个颜色； repeating-linear-gradient值1,值2 [值3],值4 值1: ellipse:椭圆效果，当元素宽高一致时为正圆 circle:正圆 值2： 起始颜色 值3： 可以设置设置颜色的过度的距离，如50%，就是0到50% 值4： 终止颜色 注：起始位置和终止位置可设置多个颜色； 2.CSS3 过渡的用法transition:值1,值2,值3,值4 值1: transition-property:all 或者其他属性值 值2： transition-duration:设置时间 如：2s 值3： transition-timing-function:设置速度 linear 匀速 ease 慢快慢 ease-in 慢开始 ease-out 慢结束 ease-in-out 慢开始慢结束 cubic-bezier 自定义贝兹尔曲线 值4： transition-delay:设置延时 如2s 3.CSS3 2D 转换的应用transform属性的属性值的运用 translate(x,y):设置位移量 x:横向位移 y:纵向位移 scale(倍数):设置放大和缩小 rotate(角度):设置顺时针旋转的角度 skew(x角度,y角度):设置倾斜角度 当角度为90deg时，消失 matrix()合体写法 matrix() 方法把所有 2D 转换方法组合在一起。 matrix() 方法需要六个参数，包含数学函数，允许您：旋转、缩放、移动以及倾斜元素。 缩放X, tan(X度), tan(Y度),缩放Y,位置X,位置Y 实例渐变12345678910111213141516171819202122232425262728&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;css3元素学习&lt;/title&gt; &lt;style type="text/css"&gt; /*线性渐变*/ div&#123;width: 200px;height: 100px;margin-bottom: 50px;&#125; div:nth-child(1)&#123;background: linear-gradient(to right,red,blue);&#125; div:nth-child(2)&#123;background: radial-gradient(circle,red,blue);&#125; div:nth-child(3)&#123;background: radial-gradient(ellipse,red,blue);&#125; div:nth-child(4)&#123;background: repeating-radial-gradient(circle,red,blue);height: 200px;&#125; div:nth-child(5)&#123;background: repeating-linear-gradient(to right,red,blue);&#125; div:nth-child(6)&#123;background: repeating-radial-gradient(circle,red 20%,blue 40%,green 40%);&#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt;线性渐变&lt;/div&gt; &lt;div&gt;镜像渐变--circle&lt;/div&gt; &lt;div&gt;镜像渐变--ellipse&lt;/div&gt; &lt;div&gt;重复渐变--repeating-radial-gradient&lt;/div&gt; &lt;div&gt;重复渐变--repeating-linear-gradient&lt;/div&gt; &lt;div&gt;重复渐变,多个颜色以及设置范围--repeating-radial-gradient&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 动画过度1234567891011121314151617181920212223242526&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;动画过度&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;style type="text/css"&gt; div&#123;width: 600px;height: 600px;background: #99f;position: relative;&#125; div p&#123; width: 20px;height: 20px;border-radius: 10px;background: #f99;position: absolute;left: 0;top:0; /*transition:2s ease all 2s;*/ opacity: 1; transition-property:all; transition-duration:2s; transition-delay:2s; transition-timing-function:ease-in-out; &#125; div:hover p&#123;left: 200px;top:500px;opacity: 0.2;&#125; &lt;/style&gt;&lt;/body&gt;&lt;div&gt; &lt;p&gt;&lt;/p&gt;&lt;/div&gt;&lt;/html&gt; 2d元素转换12345678910111213141516171819202122&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;动画过度&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;style type="text/css"&gt; div&#123;width: 600px;height: 600px;background: #99f;position: relative;&#125; div p&#123; width: 100px;height: 100px;background: #00f; /*transform: translate(100px,200px) scale(2) rotate(60deg) skew(20deg) ;*/ transform:matrix(1,2,2,1,100,200); &#125; &lt;/style&gt;&lt;/body&gt;&lt;div&gt; &lt;p&gt;&lt;/p&gt;&lt;/div&gt;&lt;/html&gt;]]></content>
      <tags>
        <tag>html</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用CSS做一个三角形]]></title>
    <url>%2F2016%2F07%2F11%2F%E7%94%A8CSS%E5%81%9A%E4%B8%80%E4%B8%AA%E4%B8%89%E8%A7%92%E5%BD%A2%2F</url>
    <content type="text"><![CDATA[利用border的特性来做一个三角形123456789101112131415161718192021222324252627282930313233&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;三角形&lt;/title&gt; &lt;style type="text/css"&gt; .zsanjiao&#123; /*去掉内容*/ width:0; height:0; /*解决兼容性*/ overflow: hidden; /*设置三角形的大小和方向,transparent是显示透明*/ border-left: 50px solid transparent; border-right: 50px solid transparent; border-bottom:50px solid red; /*border-style:dashed dashed solid dashed;*/ &#125; /*它的原理*/ .moxing&#123;width:0;height:0; border-left: 50px solid green; border-right: 50px solid pink; border-bottom:50px solid red; border-top:50px solid red; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="zsanjiao"&gt;&lt;/div&gt; &lt;hr/&gt; &lt;div class="moxing"&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <tags>
        <tag>html</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[html--高度塌陷（css）几种小技巧]]></title>
    <url>%2F2016%2F07%2F08%2Fhtml-%E9%AB%98%E5%BA%A6%E5%A1%8C%E9%99%B7%EF%BC%88css%EF%BC%89%E5%87%A0%E7%A7%8D%E5%B0%8F%E6%8A%80%E5%B7%A7%2F</url>
    <content type="text"><![CDATA[高度塌陷的情况： 当父元素没有设置高度，并且子元素块都向左浮动起来了，那么父元素就会塌陷 解决办法1.在高度塌陷的父div里面加一个div：12345&lt;div id="a"&gt; &lt;div id="a1"&gt;&lt;/div&gt; &lt;div id="a2"&gt;&lt;/div&gt; &lt;div style="clear: both;"&gt;&lt;/div&gt;//加一个标签，清除浮动 &lt;/div&gt; 优点：适合初学者，兼容性 强。缺点：代码不简练，不利于优化。 2.overflow + zoom方法123456#a&#123; background: red; /*第二种方法*/ overflow: hidden; zoom:1; &#125; 优点：兼容性强。缺点：对margin属性会有影响，不能设负值，会被裁掉。负值绝对定位也不可以。 3.after + zoom方法（绝杀)1234567891011#a&#123; background: red; zoom:1; &#125; #a:after&#123; display: block; content: '.'; clear: both; line-height: 0; visibility: hidden; &#125; 优点：通用，兼容性强缺点：不好记。 整个代码片段：12345678910111213141516171819202122232425262728293031323334353637&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;高度塌陷问题&lt;/title&gt; &lt;style type="text/css"&gt; #a&#123; background: red; zoom:1; &#125; #a:after&#123; display: block; content: '.'; clear: both; line-height: 0; visibility: hidden; &#125; #a1,#a2&#123; width: 50px; height: 50px; margin: 10px; background: blue; float: left; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="a"&gt; &lt;div id="a1"&gt;是是是&lt;/div&gt; &lt;div id="a2"&gt;&lt;/div&gt; &lt;!-- &lt;div style="clear: both;"&gt;&lt;/div&gt; --&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <tags>
        <tag>html</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[html--三栏布局（两边固定宽度，中间自适应）]]></title>
    <url>%2F2016%2F07%2F05%2Fhtml-%E4%B8%89%E6%A0%8F%E5%B8%83%E5%B1%80%EF%BC%88%E4%B8%A4%E8%BE%B9%E5%9B%BA%E5%AE%9A%E5%AE%BD%E5%BA%A6%EF%BC%8C%E4%B8%AD%E9%97%B4%E8%87%AA%E9%80%82%E5%BA%94%EF%BC%89%2F</url>
    <content type="text"><![CDATA[一、绝对定位法：左右两栏采用绝对定位，分别固定于页面的左右两侧，中间的主体栏用左右margin值撑开距离。于是实现了三栏自适应布局。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748 #left&#123; width: 180px; height: 100%; background: blue; position: absolute; left: 0px; top: 0px; &#125; #middle&#123; background: red; margin: 0 200px; height: 100%; &#125; #right&#123; width: 180px; background: blue; position: absolute; right: 0px; top: 0px; height: 100%; &#125;``` &gt; 此方法的优点在于：理解容易，上手简单，受内部元素影响而破坏布局的概率低，就是比较经得起折腾。&gt; 缺点在于：如果中间栏含有最小宽度限制，或是含有宽度的内部元素，当浏览器宽度小到一定程度，会发生层重叠的情况## 二、自身浮动法：左栏左浮动，右栏右浮动，中间栏放最后。 ``` bash#left&#123; width: 180px; height: 100%; background: blue; float: left; &#125; #middle&#123; background: red; margin: 0 200px; height: 100%; &#125; #right&#123; width: 180px; height: 100%; background: blue; float: right; &#125; 这种方式需要注意三个div的顺序，左右两栏的顺序不分先后，但是中间一栏必须放在最后。 此方法的优点是：代码足够简洁与高效 缺点是：中间主体存在克星，clear:both属性。如果要使用此方法，需避免明显的clear样式。 三、margin负值法：左右两栏均左浮动，左右两栏采用负的margin值。中间栏被宽度为100%的浮动元素包起来。12345678910111213141516171819202122232425#middle&#123; width: 100%; float: left; &#125; #main&#123; background: red; margin: 0 200px; height: 100%; &#125; #left&#123; width: 200px; float: left; margin-left: -100%; height: 100%; background:blue; &#125; #right&#123; width: 200px; float: left; margin-left: -200px; height: 100%; background:blue; &#125; 此方法的优点在于：三栏相互关联，可谓真正意义上的自适应，有一定的抗性——布局不易受内部影响。缺点在于：相对比较难理解些，上手不容易，代码相对复杂。出现百分比宽度，过多的负值定位，如果出现布局的bug，排查不易。 1234第一种和第二种方法的div排版&lt;div id="middle"&gt;&lt;/div&gt;&lt;div id="left"&gt;xsxsx&lt;/div&gt;&lt;div id="right"&gt;xsxsx&lt;/div&gt; 123456第三种方法的div排版&lt;div id="middle"&gt; &lt;div id="main"&gt;aaaaaaaaa&lt;/div&gt; &lt;/div&gt; &lt;div id="left"&gt;vvvvvvvvvvv&lt;/div&gt; &lt;div id="right"&gt;ccccccccccccc&lt;/div&gt;]]></content>
      <tags>
        <tag>html</tag>
      </tags>
  </entry>
</search>
